#define getCycle(state, cycle)    (((cycle) << 6) | (state))

void m68kResetDpProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2 rstp3
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 296 rstp4
	    reg_ird = reg_ir;
	    setIntState();
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setTrace();
	    // 27e rstp5
	    trapExcept(0x00);
	    reg_ftu = 0x0000;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    // 27f rstp6
	    initST();
	    reg_sr |= 0x700;
	    updateInterrupts();
	    reg_au = ext32(reg_ftu);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    // 2fb rstp7
	    reg_aob = reg_au;
	    setReg16High(reg_da[16], reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, true);
	    setCritical();
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 9):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2ff rstp8
	    reg_aob = reg_au;
	    setReg16High(reg_da[16], reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, true);
	    setCritical();
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 10):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 300 rstp9
	    reg_aob = reg_au;
	    initST();
	    setReg16Low(reg_da[16], reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, true);
	    setCritical();
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 11):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    clearTrace();
	    // 11e rstpa
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, true);
	    setCritical();
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 12):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, true);
	    setCritical();
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 13):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 14):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 15):
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, true);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 16):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kDoubleFaultDpProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1 halt1
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kInterruptDpProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c4 itlx1
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 234 itlx2
	    initST();
	    reg_alub = reg_ftu;
	    reg_pc = reg_au;
	    reg_sr = ((reg_sr & ~0x700) | ((next_state >> 16) & 0x700));
	    updateInterrupts();
	    runALU(AluAnd, reg_au, 0xFFFF);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 235 itlx3
	    reg_ftu = (0xfff0 | ((next_state >> 23) & 0xE));
	    reg_au = reg_da[16] - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    // eb itlx4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, false, true);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    // 236 itlx5
	    reg_aob = reg_at;
	    setFC(true, true, true, true);
	    startIRQVectorLookup();
	    readWordCPU();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    endIRQVectorLookup();
	    checkExcept();
	    reg_irc = reg_edb;
	    // 118 itlx6
	    reg_ir = reg_irc;
	    updateIPL();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 9):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 10):
	{
	    // 292 itlx7
	    reg_ird = reg_ir;
	    setIntState();
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 11):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 12):
	{
	    setTrace();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(reg_int_vec);
	    reg_da[16] = reg_au;
	    reg_ftu = reg_int_vec;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, true);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 13):
	{
	    checkExcept();
	    // ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, false, true);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 14):
	{
	    checkExcept();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, true);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 15):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, true);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 16):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, true);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 17):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 18):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 19):
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, true);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 20):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriByteImm8DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 100 roaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluOrByte, reg_dt, reg_da[ry_index]);
	    updateCCR(CcrNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriByteImm8AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriByteImm8AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriByteImm8PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriByteImm8DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriByteImm8DaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriByteImm8Adr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriByteImm8Adr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriImm8CcrProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1cc stiw1
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 307 stiw2
	    runALU(AluOrByte, reg_ftu, reg_dt);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 320 stiw3
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_aluo;
	    reg_au = reg_au + 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 9):
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 10):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 11):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriWordImm16DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 100 roaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluOr, reg_dt, reg_da[ry_index]);
	    updateCCR(CcrNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriWordImm16AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriWordImm16AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluOr, reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriWordImm16PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - 2;
	    runALU(AluOr, reg_dt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriWordImm16DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriWordImm16DaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriWordImm16Adr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluOr, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriWordImm16Adr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluOr, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriI16uSrProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    if (!checkPriv())
	    {
		setPriv();
		return;
	    }

	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1cc stiw1
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 307 stiw2
	    runALU(AluOr, reg_ftu, reg_dt);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 320 stiw3
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_aluo;
	    reg_au = reg_au + 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
	    updateSupervisor();
	    updateInterrupts();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 9):
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 10):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 11):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriLongImm32DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 10c roal1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluOr, reg_dt, reg_da[ry_index]);
	    updateCCR(CcrNZVC);
	    // 259 roal2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25a roal3
	    runALU(AluOr, high16(reg_dt), high16(reg_da[ry_index]));
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriLongImm32AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluOr, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriLongImm32AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluOr, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriLongImm32PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluOr, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 9):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriLongImm32DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluOr, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriLongImm32DaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluOr, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriLongImm32Adr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluOr, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluOr, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriLongImm32Adr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluOr, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluOr, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 9):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBtstDdDsProgram()
{
    unknownInstr();
}

void m68kMovepWordDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1d2 mpiw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 29a mpiw2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    setReg8High(reg_dbin, reg_edb);
	    // 368 mpiw3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    setReg8(reg_dbin, reg_edb);
	    // 36a mpiw4
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBtstDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBtstDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluXorByte, reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBtstDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluXorByte, reg_da[rx_index], reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBtstDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBtstDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBtstDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluXorByte, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBtstDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluXorByte, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBtstDdDpcProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBtstDdDpciProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBtstDdImmProgram()
{
    unknownInstr();
}

void m68kBchgDdDsProgram()
{
    unknownInstr();
}

void m68kMovepLongDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1d6 mpil1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 29e mpil2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    setReg8High(reg_dbin, reg_edb);
	    // 34e mpil3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    setReg8(reg_dbin, reg_edb);
	    // 34f mpil4
	    reg_aob = reg_au;
	    setReg16High(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setReg8High(reg_dbin, reg_edb);
	    // 368 mpiw3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setReg8(reg_dbin, reg_edb);
	    // 36a mpiw4
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBchgDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBchgDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluXorByte, reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBchgDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluXorByte, reg_da[rx_index], reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBchgDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBchgDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBchgDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluXorByte, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBchgDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluXorByte, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBclrDdDsProgram()
{
    unknownInstr();
}

void m68kMovepWordDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1ca mpow1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 36d mpow2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExHigh(reg_dbout, reg_da[rx_index]);
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 36e mpow3
	    reg_aob = reg_au;
	    setReg8ExLow(reg_dbout, reg_da[rx_index]);
	    reg_au = reg_pc + 4;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBclrDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 69 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    runALU(AluOrByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 67 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBclrDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 69 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    runALU(AluOrByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 67 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBclrDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 69 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    runALU(AluOrByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 67 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBclrDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 69 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    runALU(AluOrByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 67 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBclrDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 69 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    runALU(AluOrByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 67 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBclrDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 69 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    runALU(AluOrByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 67 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBclrDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 69 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    runALU(AluOrByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 67 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBsetDdDsProgram()
{
    unknownInstr();
}

void m68kMovepLongDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1ce mpol1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 36b mpol2
	    reg_aob = reg_au;
	    setReg8ExHigh(reg_dbout, high16(reg_da[rx_index]));
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 36c mpol3
	    reg_aob = reg_au;
	    setReg8ExLow(reg_dbout, high16(reg_da[rx_index]));
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 36d mpow2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExHigh(reg_dbout, reg_da[rx_index]);
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 36e mpow3
	    reg_aob = reg_au;
	    setReg8ExLow(reg_dbout, reg_da[rx_index]);
	    reg_au = reg_pc + 4;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBsetDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluOrByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBsetDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluOrByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBsetDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluOrByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBsetDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluOrByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBsetDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluOrByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBsetDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluOrByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBsetDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluOrByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiByteImm8DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 100 roaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluAndByte, reg_dt, reg_da[ry_index]);
	    updateCCR(CcrNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiByteImm8AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiByteImm8AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiByteImm8PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiByteImm8DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiByteImm8DaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiByteImm8Adr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAndByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiByteImm8Adr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAndByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiImm8CcrProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1cc stiw1
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 307 stiw2
	    runALU(AluAndByte, reg_ftu, reg_dt);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 320 stiw3
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_aluo;
	    reg_au = reg_au + 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 9):
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 10):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 11):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiWordImm16DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 100 roaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluAnd, reg_dt, reg_da[ry_index]);
	    updateCCR(CcrNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiWordImm16AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiWordImm16AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiWordImm16PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - 2;
	    runALU(AluAnd, reg_dt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiWordImm16DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiWordImm16DaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiWordImm16Adr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAnd, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiWordImm16Adr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAnd, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiI16uSrProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    if (!checkPriv())
	    {
		setPriv();
		return;
	    }

	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1cc stiw1
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 307 stiw2
	    runALU(AluAnd, reg_ftu, reg_dt);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 320 stiw3
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_aluo;
	    reg_au = reg_au + 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
	    updateSupervisor();
	    updateInterrupts();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 9):
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 10):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 11):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiLongImm32DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 10c roal1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluAnd, reg_dt, reg_da[ry_index]);
	    updateCCR(CcrNZVC);
	    // 259 roal2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25a roal3
	    runALU(AluAnd, high16(reg_dt), high16(reg_da[ry_index]));
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiLongImm32AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiLongImm32AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiLongImm32PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 9):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiLongImm32DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiLongImm32DaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiLongImm32Adr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAnd, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiLongImm32Adr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAnd, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 9):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiByteImm8DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 100 roaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluSubByte, reg_dt, reg_da[ry_index]);
	    updateCCR(CcrXNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiByteImm8AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiByteImm8AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiByteImm8PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiByteImm8DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiByteImm8DaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiByteImm8Adr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiByteImm8Adr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiWordImm16DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 100 roaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluSub, reg_dt, reg_da[ry_index]);
	    updateCCR(CcrXNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiWordImm16AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiWordImm16AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiWordImm16PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiWordImm16DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiWordImm16DaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiWordImm16Adr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiWordImm16Adr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiLongImm32DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 10c roal1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluSub, reg_dt, reg_da[ry_index]);
	    updateCCR(CcrXNZVC);
	    // 259 roal2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25a roal3
	    runALU(AluSubc, high16(reg_dt), high16(reg_da[ry_index]));
	    updateCCR(CcrXNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiLongImm32AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiLongImm32AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiLongImm32PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 9):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiLongImm32DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiLongImm32DaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiLongImm32Adr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiLongImm32Adr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 9):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiByteImm8DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 100 roaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluAddByte, reg_dt, reg_da[ry_index]);
	    updateCCR(CcrXNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiByteImm8AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiByteImm8AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiByteImm8PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiByteImm8DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiByteImm8DaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiByteImm8Adr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiByteImm8Adr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiWordImm16DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 100 roaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluAdd, reg_dt, reg_da[ry_index]);
	    updateCCR(CcrXNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiWordImm16AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiWordImm16AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiWordImm16PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiWordImm16DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiWordImm16DaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiWordImm16Adr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiWordImm16Adr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiLongImm32DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 10c roal1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluAdd, reg_dt, reg_da[ry_index]);
	    updateCCR(CcrXNZVC);
	    // 259 roal2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25a roal3
	    runALU(AluAddc, high16(reg_dt), high16(reg_da[ry_index]));
	    updateCCR(CcrXNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiLongImm32AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiLongImm32AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiLongImm32PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 9):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiLongImm32DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiLongImm32DaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiLongImm32Adr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiLongImm32Adr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 9):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBtstImm8DsProgram()
{
    unknownInstr();
}

void m68kBtstImm8AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBtstImm8AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBtstImm8PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBtstImm8DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBtstImm8DaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBtstImm8Adr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBtstImm8Adr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBtstImm8DpcProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBtstImm8DpciProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBchgImm8DsProgram()
{
    unknownInstr();
}

void m68kBchgImm8AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBchgImm8AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBchgImm8PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBchgImm8DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBchgImm8DaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBchgImm8Adr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBchgImm8Adr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBclrImm8DsProgram()
{
    unknownInstr();
}

void m68kBclrImm8AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 69 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 67 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBclrImm8AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 69 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 67 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBclrImm8PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    reg_dbin = reg_edb;
	    // 69 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 67 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBclrImm8DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 69 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 67 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBclrImm8DaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 69 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 67 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBclrImm8Adr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 69 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 67 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBclrImm8Adr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    reg_dbin = reg_edb;
	    // 69 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 67 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBsetImm8DsProgram()
{
    unknownInstr();
}

void m68kBsetImm8AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBsetImm8AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBsetImm8PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBsetImm8DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBsetImm8DaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBsetImm8Adr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBsetImm8Adr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriByteImm8DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 100 roaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluXorByte, reg_dt, reg_da[ry_index]);
	    updateCCR(CcrNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriByteImm8AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriByteImm8AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriByteImm8PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriByteImm8DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriByteImm8DaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriByteImm8Adr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriByteImm8Adr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriImm8CcrProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1cc stiw1
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 307 stiw2
	    runALU(AluXorByte, reg_ftu, reg_dt);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 320 stiw3
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_aluo;
	    reg_au = reg_au + 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 9):
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 10):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 11):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriWordImm16DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 100 roaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluXor, reg_dt, reg_da[ry_index]);
	    updateCCR(CcrNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriWordImm16AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXor, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriWordImm16AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluXor, reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXor, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriWordImm16PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - 2;
	    runALU(AluXor, reg_dt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXor, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriWordImm16DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXor, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriWordImm16DaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXor, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriWordImm16Adr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluXor, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXor, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriWordImm16Adr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluXor, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXor, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriI16uSrProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    if (!checkPriv())
	    {
		setPriv();
		return;
	    }

	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1cc stiw1
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 307 stiw2
	    runALU(AluXor, reg_ftu, reg_dt);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 320 stiw3
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_aluo;
	    reg_au = reg_au + 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
	    updateSupervisor();
	    updateInterrupts();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 9):
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 10):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 11):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriLongImm32DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 10c roal1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluXor, reg_dt, reg_da[ry_index]);
	    updateCCR(CcrNZVC);
	    // 259 roal2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25a roal3
	    runALU(AluXor, high16(reg_dt), high16(reg_da[ry_index]));
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriLongImm32AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXor, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluXor, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriLongImm32AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXor, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluXor, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriLongImm32PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXor, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluXor, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 9):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriLongImm32DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXor, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluXor, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriLongImm32DaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXor, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluXor, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriLongImm32Adr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluXor, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXor, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluXor, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriLongImm32Adr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluXor, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXor, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluXor, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 9):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiByteImm8DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 108 rcaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluSubByte, reg_dt, reg_da[ry_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiByteImm8AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 87 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSubByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiByteImm8AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 87 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSubByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiByteImm8PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    reg_dbin = reg_edb;
	    // 87 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSubByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiByteImm8DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 87 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSubByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiByteImm8DaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 87 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSubByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiByteImm8Adr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 87 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSubByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiByteImm8Adr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    reg_dbin = reg_edb;
	    // 87 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSubByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiWordImm16DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 108 rcaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluSub, reg_dt, reg_da[ry_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiWordImm16AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 87 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiWordImm16AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 87 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiWordImm16PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 87 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiWordImm16DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 87 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiWordImm16DaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 87 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiWordImm16Adr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 87 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiWordImm16Adr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 87 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiLongImm32DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 104 rcal1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluSub, reg_dt, reg_da[ry_index]);
	    updateCCR(CcrNZVC);
	    // 239 rcal2
	    runALU(AluSubc, high16(reg_dt), high16(reg_da[ry_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiLongImm32AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 8f cpdl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 171 cpdl2
	    reg_ird = reg_ir;
	    setIntState();
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiLongImm32AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 8f cpdl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 171 cpdl2
	    reg_ird = reg_ir;
	    setIntState();
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiLongImm32PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 8f cpdl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 171 cpdl2
	    reg_ird = reg_ir;
	    setIntState();
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiLongImm32DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 8f cpdl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 171 cpdl2
	    reg_ird = reg_ir;
	    setIntState();
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiLongImm32DaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 8f cpdl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 171 cpdl2
	    reg_ird = reg_ir;
	    setIntState();
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiLongImm32Adr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 8f cpdl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 171 cpdl2
	    reg_ird = reg_ir;
	    setIntState();
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiLongImm32Adr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 8f cpdl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 171 cpdl2
	    reg_ird = reg_ir;
	    setIntState();
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 121 rrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg8(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg8(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveBytePaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg8(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg8(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg8(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg8(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg8(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg8(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg8(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteImm8DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 121 rrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_dt;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDsAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2fa rmrw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_da[ry_index]);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAisAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAipsAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveBytePaisAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDasAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDaisAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAdr16AidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAdr32AidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDpcAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDpciAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteImm8AidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2fa rmrw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_dt);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDsAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2fe rmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_da[ry_index]);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAisAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAipsAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveBytePaisAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDasAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDaisAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAdr16AipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAdr32AipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDpcAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDpciAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteImm8AipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2fe rmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_dt);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDsPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2f8 rmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAipsPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveBytePaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDasPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAdr16PaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAdr32PaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDpcPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDpciPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteImm8PaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2f8 rmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDsDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2da rmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 2db rmdw2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_da[ry_index]);
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAisDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAipsDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveBytePaisDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDasDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDaisDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAdr16DadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAdr32DadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDpcDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDpciDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteImm8DadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2da rmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 2db rmdw2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_dt);
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDsDaidProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1eb rmxw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 109 rmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // rmxw2
	    // 128 rmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // rmxw3
	    // 1e8 rmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // rmdw2
	    // 2db rmdw2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_da[ry_index]);
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAisDaidProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    runALU(AluExt, reg_aluo);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // mmxw2
	    // 28 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // mmxw3
	    // e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // maww2
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAipsDaidProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    runALU(AluExt, reg_aluo);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // mmxw2
	    // 28 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // mmxw3
	    // e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // maww2
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveBytePaisDaidProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    runALU(AluExt, reg_aluo);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // mmxw2
	    // 28 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // mmxw3
	    // e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // maww2
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDasDaidProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    runALU(AluExt, reg_aluo);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // mmxw2
	    // 28 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // mmxw3
	    // e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // maww2
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDaisDaidProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    runALU(AluExt, reg_aluo);
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    jumpCond2(5, 4);
	}
	break;
	case getCycle(4, 0):
	{
	    // mmxw2
	    // 28 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(4, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(6);
	}
	break;
	case getCycle(5, 0):
	{
	    // mmxw3
	    // e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(5, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(6);
	}
	break;
	case getCycle(6, 0):
	{
	    // maww2
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(6, 1):
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(6, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAdr16DaidProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    runALU(AluExt, reg_aluo);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // mmxw2
	    // 28 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // mmxw3
	    // e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // maww2
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAdr32DaidProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    runALU(AluExt, reg_aluo);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // mmxw2
	    // 28 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // mmxw3
	    // e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // maww2
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDpcDaidProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    runALU(AluExt, reg_aluo);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // mmxw2
	    // 28 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // mmxw3
	    // e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // maww2
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDpciDaidProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    runALU(AluExt, reg_aluo);
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    jumpCond2(5, 4);
	}
	break;
	case getCycle(4, 0):
	{
	    // mmxw2
	    // 28 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(4, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(6);
	}
	break;
	case getCycle(5, 0):
	{
	    // mmxw3
	    // e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(5, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(6);
	}
	break;
	case getCycle(6, 0):
	{
	    // maww2
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(6, 1):
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(6, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteImm8DaidProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1eb rmxw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 109 rmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // rmxw2
	    // 128 rmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // rmxw3
	    // 1e8 rmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // rmdw2
	    // 2db rmdw2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_dt);
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDsAdr16Program()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2d9 raww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_da[ry_index]);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAisAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAipsAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveBytePaisAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDasAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDaisAdr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAdr16Adr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAdr32Adr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDpcAdr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDpciAdr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteImm8Adr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2d9 raww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dt);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAndByte, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDsAdr32Program()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1ea ralw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bb ralw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_da[ry_index]);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAisAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAipsAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveBytePaisAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDasAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDaisAdr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAdr16Adr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAdr32Adr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDpcAdr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDpciAdr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteImm8Adr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1ea ralw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bb ralw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dt);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAndByte, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 129 rrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 278 rrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    updateCCR(CcrNZU);
	    reg_da[rx_index] = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 129 rrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 278 rrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_at;
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongImm32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 129 rrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_dt;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 278 rrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_at;
	    runALU(AluAnd, high16(reg_dt), 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaLongDsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 129 rrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    // 278 rrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_at;
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaLongAsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 129 rrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    // 278 rrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    reg_da[rx_index] = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaLongAisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaLongAipsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaLongPaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaLongDasAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaLongDaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaLongAdr16AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaLongAdr32AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaLongDpcAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaLongDpciAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaLongImm32AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 129 rrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_dt;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dt, 0xFFFF);
	    // 278 rrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_at;
	    runALU(AluAnd, high16(reg_dt), 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDsAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2f9 rmrl1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = high16(reg_da[ry_index]);
	    reg_alub = high16(reg_da[ry_index]);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    // 23f rmrl2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    // 258 rmrl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAsAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2f9 rmrl1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = high16(reg_da[ry_index]);
	    reg_alub = high16(reg_da[ry_index]);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    // 23f rmrl2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    // 258 rmrl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAisAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3a9 mmrl1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    // 3aa mmrl2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAipsAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3a9 mmrl1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    // 3aa mmrl2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongPaisAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3a9 mmrl1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 3aa mmrl2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDasAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3a9 mmrl1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 3aa mmrl2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDaisAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3a9 mmrl1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    // 3aa mmrl2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAdr16AidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3a9 mmrl1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 3aa mmrl2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAdr32AidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3a9 mmrl1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 3aa mmrl2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDpcAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3a9 mmrl1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 3aa mmrl2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDpciAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3a9 mmrl1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    // 3aa mmrl2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongImm32AidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2f9 rmrl1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = high16(reg_dt);
	    reg_alub = high16(reg_dt);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    // 23f rmrl2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dt;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 258 rmrl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDsAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2fd rmil1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = high16(reg_da[ry_index]);
	    reg_alub = high16(reg_da[ry_index]);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    // 23c rmil2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    // 23d rmil3
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAsAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2fd rmil1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = high16(reg_da[ry_index]);
	    reg_alub = high16(reg_da[ry_index]);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    // 23c rmil2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    // 23d rmil3
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAisAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3ad mmil1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    // 3ae mmil2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAipsAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3ad mmil1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    // 3ae mmil2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongPaisAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3ad mmil1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 3ae mmil2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDasAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3ad mmil1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 3ae mmil2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDaisAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3ad mmil1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    // 3ae mmil2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAdr16AipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3ad mmil1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 3ae mmil2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAdr32AipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3ad mmil1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 3ae mmil2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDpcAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3ad mmil1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 3ae mmil2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDpciAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3ad mmil1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    // 3ae mmil2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongImm32AipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2fd rmil1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = high16(reg_dt);
	    reg_alub = high16(reg_dt);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    // 23c rmil2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dt;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 23d rmil3
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDsPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2fc rmml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 23e rmml2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAsPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2fc rmml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 23e rmml2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38f mmml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34a mmml2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAipsPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38f mmml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34a mmml2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongPaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38f mmml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34a mmml2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDasPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38f mmml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34a mmml2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38f mmml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34a mmml2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAdr16PaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38f mmml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34a mmml2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAdr32PaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38f mmml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34a mmml2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDpcPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38f mmml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34a mmml2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDpciPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38f mmml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34a mmml2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongImm32PaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2fc rmml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 23e rmml2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_dt), 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDsDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2de rmdl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 2be rmdl2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_da[ry_index]);
	    reg_alub = high16(reg_da[ry_index]);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    // 2df rmdl3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    // 258 rmrl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAsDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2de rmdl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 2be rmdl2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_da[ry_index]);
	    reg_alub = high16(reg_da[ry_index]);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    // 2df rmdl3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    // 258 rmrl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAisDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38e mmdl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAipsDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38e mmdl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongPaisDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38e mmdl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDasDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38e mmdl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDaisDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38e mmdl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAdr16DadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38e mmdl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAdr32DadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38e mmdl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDpcDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38e mmdl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDpciDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38e mmdl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongImm32DadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2de rmdl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 2be rmdl2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_dt);
	    reg_alub = high16(reg_dt);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, high16(reg_dt), 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 2df rmdl3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dt;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 258 rmrl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDsDaidProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1ef rmxl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 105 rmxl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // rmxl2
	    // 12c rmxl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // rmxl3
	    // 1ec rmxl3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // rmdl2
	    // 2be rmdl2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_da[ry_index]);
	    reg_alub = high16(reg_da[ry_index]);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    // 2df rmdl3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    // 258 rmrl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAsDaidProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1ef rmxl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 105 rmxl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // rmxl2
	    // 12c rmxl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // rmxl3
	    // 1ec rmxl3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // rmdl2
	    // 2be rmdl2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_da[ry_index]);
	    reg_alub = high16(reg_da[ry_index]);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    // 2df rmdl3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    // 258 rmrl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAisDaidProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29c mmxl0
	    runALU(AluExt, reg_aluo);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 10d mmxl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // mmxl2
	    // 2c mmxl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // mmxl3
	    // ec mmxl3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // mawl2
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAipsDaidProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29c mmxl0
	    runALU(AluExt, reg_aluo);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 10d mmxl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // mmxl2
	    // 2c mmxl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // mmxl3
	    // ec mmxl3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // mawl2
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongPaisDaidProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29c mmxl0
	    runALU(AluExt, reg_aluo);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    // 10d mmxl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // mmxl2
	    // 2c mmxl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // mmxl3
	    // ec mmxl3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // mawl2
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDasDaidProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29c mmxl0
	    runALU(AluExt, reg_aluo);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 10d mmxl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // mmxl2
	    // 2c mmxl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // mmxl3
	    // ec mmxl3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // mawl2
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDaisDaidProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29c mmxl0
	    runALU(AluExt, reg_aluo);
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    // 10d mmxl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    jumpCond2(5, 4);
	}
	break;
	case getCycle(4, 0):
	{
	    // mmxl2
	    // 2c mmxl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(4, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(6);
	}
	break;
	case getCycle(5, 0):
	{
	    // mmxl3
	    // ec mmxl3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(5, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(6);
	}
	break;
	case getCycle(6, 0):
	{
	    // mawl2
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(6, 1):
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(6, 2):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(6, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAdr16DaidProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29c mmxl0
	    runALU(AluExt, reg_aluo);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 10d mmxl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // mmxl2
	    // 2c mmxl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // mmxl3
	    // ec mmxl3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // mawl2
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAdr32DaidProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29c mmxl0
	    runALU(AluExt, reg_aluo);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    // 10d mmxl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // mmxl2
	    // 2c mmxl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // mmxl3
	    // ec mmxl3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // mawl2
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDpcDaidProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29c mmxl0
	    runALU(AluExt, reg_aluo);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 10d mmxl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // mmxl2
	    // 2c mmxl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // mmxl3
	    // ec mmxl3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // mawl2
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDpciDaidProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29c mmxl0
	    runALU(AluExt, reg_aluo);
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    // 10d mmxl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    jumpCond2(5, 4);
	}
	break;
	case getCycle(4, 0):
	{
	    // mmxl2
	    // 2c mmxl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(4, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(6);
	}
	break;
	case getCycle(5, 0):
	{
	    // mmxl3
	    // ec mmxl3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(5, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(6);
	}
	break;
	case getCycle(6, 0):
	{
	    // mawl2
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(6, 1):
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(6, 2):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(6, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongImm32DaidProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1ef rmxl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 105 rmxl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // rmxl2
	    // 12c rmxl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // rmxl3
	    // 1ec rmxl3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // rmdl2
	    // 2be rmdl2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_dt);
	    reg_alub = high16(reg_dt);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, high16(reg_dt), 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    // 2df rmdl3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dt;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    // 258 rmrl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDsAdr16Program()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2dd rawl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_da[ry_index]);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 2ba rall3
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_da[ry_index]);
	    reg_alub = high16(reg_da[ry_index]);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAsAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2dd rawl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_da[ry_index]);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 2ba rall3
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_da[ry_index]);
	    reg_alub = high16(reg_da[ry_index]);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAisAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38c mawl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAipsAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38c mawl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongPaisAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38c mawl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDasAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38c mawl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDaisAdr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38c mawl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAdr16Adr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38c mawl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAdr32Adr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38c mawl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDpcAdr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38c mawl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDpciAdr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38c mawl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongImm32Adr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2dd rawl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dt);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAnd, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 2ba rall3
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_dt);
	    reg_alub = high16(reg_dt);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, high16(reg_dt), 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDsAdr32Program()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1ee rall1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bf rall2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_da[ry_index]);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 2ba rall3
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_da[ry_index]);
	    reg_alub = high16(reg_da[ry_index]);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAsAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1ee rall1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bf rall2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_da[ry_index]);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 2ba rall3
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_da[ry_index]);
	    reg_alub = high16(reg_da[ry_index]);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAisAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 30f mall1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dbin);
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 329 mall2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_dbout = reg_aluo;
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    runALU(AluAnd, reg_at, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 32a mall3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAipsAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 30f mall1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dbin);
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 329 mall2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_dbout = reg_aluo;
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    runALU(AluAnd, reg_at, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 32a mall3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongPaisAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 30f mall1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dbin);
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 329 mall2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_dbout = reg_aluo;
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    runALU(AluAnd, reg_at, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 32a mall3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 9):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDasAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 30f mall1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dbin);
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 329 mall2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_dbout = reg_aluo;
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    runALU(AluAnd, reg_at, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 32a mall3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDaisAdr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 30f mall1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dbin);
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 329 mall2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_dbout = reg_aluo;
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    runALU(AluAnd, reg_at, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    // 32a mall3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    checkExcept();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAdr16Adr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 30f mall1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dbin);
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 329 mall2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_dbout = reg_aluo;
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    runALU(AluAnd, reg_at, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 32a mall3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAdr32Adr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 30f mall1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dbin);
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 329 mall2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_dbout = reg_aluo;
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    runALU(AluAnd, reg_at, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 32a mall3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 9):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDpcAdr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 30f mall1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dbin);
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 329 mall2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_dbout = reg_aluo;
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    runALU(AluAnd, reg_at, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 32a mall3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDpciAdr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 30f mall1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dbin);
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 329 mall2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_dbout = reg_aluo;
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    runALU(AluAnd, reg_at, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    // 32a mall3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    checkExcept();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongImm32Adr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1ee rall1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bf rall2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dt);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAnd, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 2ba rall3
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_dt);
	    reg_alub = high16(reg_dt);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, high16(reg_dt), 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 121 rrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 121 rrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordImm16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 121 rrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_dt;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaWordDsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 279 rrgm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    reg_au = reg_au + 2;
	    // 278 rrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_at;
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaWordAsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 279 rrgm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    reg_au = reg_au + 2;
	    // 278 rrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    reg_da[rx_index] = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaWordAisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 158 mrgm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_da[rx_index] = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaWordAipsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 158 mrgm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_da[rx_index] = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaWordPaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 158 mrgm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_da[rx_index] = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaWordDasAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 158 mrgm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_da[rx_index] = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaWordDaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 158 mrgm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_da[rx_index] = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaWordAdr16AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 158 mrgm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_da[rx_index] = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaWordAdr32AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 158 mrgm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_da[rx_index] = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaWordDpcAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 158 mrgm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_da[rx_index] = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaWordDpciAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 158 mrgm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_da[rx_index] = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaWordImm16AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 279 rrgm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    reg_au = reg_au + 2;
	    // 278 rrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_at;
	    runALU(AluAnd, high16(reg_dt), 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDsAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2fa rmrw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAsAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2fa rmrw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAisAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAipsAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordPaisAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDasAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDaisAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAdr16AidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAdr32AidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDpcAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDpciAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordImm16AidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2fa rmrw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dt;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDsAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2fe rmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAsAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2fe rmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAisAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAipsAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordPaisAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDasAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDaisAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAdr16AipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAdr32AipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDpcAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDpciAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordImm16AipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2fe rmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dt;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDsPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2f8 rmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAsPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2f8 rmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAipsPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordPaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDasPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAdr16PaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAdr32PaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDpcPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDpciPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordImm16PaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2f8 rmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDsDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2da rmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 2db rmdw2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAsDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2da rmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 2db rmdw2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAisDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAipsDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordPaisDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDasDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDaisDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAdr16DadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAdr32DadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDpcDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDpciDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordImm16DadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2da rmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 2db rmdw2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dt;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDsDaidProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1eb rmxw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 109 rmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // rmxw2
	    // 128 rmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // rmxw3
	    // 1e8 rmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // rmdw2
	    // 2db rmdw2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAsDaidProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1eb rmxw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 109 rmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // rmxw2
	    // 128 rmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // rmxw3
	    // 1e8 rmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // rmdw2
	    // 2db rmdw2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAisDaidProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    runALU(AluExt, reg_aluo);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // mmxw2
	    // 28 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // mmxw3
	    // e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // maww2
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAipsDaidProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    runALU(AluExt, reg_aluo);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // mmxw2
	    // 28 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // mmxw3
	    // e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // maww2
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordPaisDaidProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    runALU(AluExt, reg_aluo);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // mmxw2
	    // 28 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // mmxw3
	    // e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // maww2
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDasDaidProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    runALU(AluExt, reg_aluo);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // mmxw2
	    // 28 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // mmxw3
	    // e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // maww2
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDaisDaidProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    runALU(AluExt, reg_aluo);
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    jumpCond2(5, 4);
	}
	break;
	case getCycle(4, 0):
	{
	    // mmxw2
	    // 28 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(4, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(6);
	}
	break;
	case getCycle(5, 0):
	{
	    // mmxw3
	    // e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(5, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(6);
	}
	break;
	case getCycle(6, 0):
	{
	    // maww2
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(6, 1):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(6, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAdr16DaidProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    runALU(AluExt, reg_aluo);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // mmxw2
	    // 28 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // mmxw3
	    // e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // maww2
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAdr32DaidProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    runALU(AluExt, reg_aluo);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // mmxw2
	    // 28 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // mmxw3
	    // e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // maww2
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDpcDaidProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    runALU(AluExt, reg_aluo);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // mmxw2
	    // 28 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // mmxw3
	    // e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // maww2
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDpciDaidProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    runALU(AluExt, reg_aluo);
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    jumpCond2(5, 4);
	}
	break;
	case getCycle(4, 0):
	{
	    // mmxw2
	    // 28 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(4, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(6);
	}
	break;
	case getCycle(5, 0):
	{
	    // mmxw3
	    // e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(5, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jump(6);
	}
	break;
	case getCycle(6, 0):
	{
	    // maww2
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(6, 1):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(6, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordImm16DaidProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1eb rmxw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 109 rmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // rmxw2
	    // 128 rmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // rmxw3
	    // 1e8 rmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // rmdw2
	    // 2db rmdw2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dt;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDsAdr16Program()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2d9 raww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_da[ry_index]);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAsAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2d9 raww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_da[ry_index]);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAisAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAipsAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordPaisAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDasAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDaisAdr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAdr16Adr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAdr32Adr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDpcAdr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDpciAdr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordImm16Adr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2d9 raww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dt);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAnd, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDsAdr32Program()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1ea ralw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bb ralw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_da[ry_index]);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAsAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1ea ralw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bb ralw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_da[ry_index]);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAisAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAipsAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordPaisAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDasAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDaisAdr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAdr16Adr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAdr32Adr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDpcAdr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDpciAdr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordImm16Adr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1ea ralw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bb ralw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dt);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAnd, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxByteDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 133 nnrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSubxByte, reg_da[ry_index], 0x0000);
	    updateCCR(CcrXNZVCU);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxByteAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubxByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxByteAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubxByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxBytePaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubxByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxByteDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubxByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxByteDaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubxByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxByteAdr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubxByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxByteAdr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubxByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxWordDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 133 nnrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSubx, reg_da[ry_index], 0x0000);
	    updateCCR(CcrXNZVCU);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxWordAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubx, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxWordAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubx, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxWordPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubx, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxWordDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubx, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxWordDaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubx, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxWordAdr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubx, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxWordAdr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubx, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxLongDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 137 nnrl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSubx, reg_da[ry_index], 0x0000);
	    updateCCR(CcrXNZVCU);
	    // 15e nnrl2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    runALU(AluSubc, high16(reg_da[ry_index]), 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxLongAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubx, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluSubc, reg_alub, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxLongAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubx, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluSubc, reg_alub, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxLongPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubx, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluSubc, reg_alub, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxLongDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubx, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluSubc, reg_alub, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxLongDaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubx, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluSubc, reg_alub, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxLongAdr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubx, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluSubc, reg_alub, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxLongAdr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubx, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluSubc, reg_alub, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveSrDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3a5 strw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_ftu = reg_sr;
	    // 340 strw2
	    setReg16Low(reg_da[ry_index], reg_ftu);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveSrAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3a1 stmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_ftu = reg_sr;
	    // 324 sftm2
	    reg_au = reg_at;
	    runALU(AluAnd, reg_ftu, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveSrAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3a1 stmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_ftu = reg_sr;
	    // 324 sftm2
	    reg_au = reg_at;
	    runALU(AluAnd, reg_ftu, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveSrPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3a1 stmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_ftu = reg_sr;
	    // 324 sftm2
	    reg_au = reg_at;
	    runALU(AluAnd, reg_ftu, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveSrDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3a1 stmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_ftu = reg_sr;
	    // 324 sftm2
	    reg_au = reg_at;
	    runALU(AluAnd, reg_ftu, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveSrDaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3a1 stmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_ftu = reg_sr;
	    // 324 sftm2
	    reg_au = reg_at;
	    runALU(AluAnd, reg_ftu, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveSrAdr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3a1 stmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_ftu = reg_sr;
	    // 324 sftm2
	    reg_au = reg_at;
	    runALU(AluAnd, reg_ftu, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveSrAdr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3a1 stmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_ftu = reg_sr;
	    // 324 sftm2
	    reg_au = reg_at;
	    runALU(AluAnd, reg_ftu, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kChkWordDsDdProgram()
{
    unknownInstr();
}

void m68kChkWordAisDdProgram()
{
    unknownInstr();
}

void m68kChkWordAipsDdProgram()
{
    unknownInstr();
}

void m68kChkWordPaisDdProgram()
{
    unknownInstr();
}

void m68kChkWordDasDdProgram()
{
    unknownInstr();
}

void m68kChkWordDaisDdProgram()
{
    unknownInstr();
}

void m68kChkWordAdr16DdProgram()
{
    unknownInstr();
}

void m68kChkWordAdr32DdProgram()
{
    unknownInstr();
}

void m68kChkWordDpcDdProgram()
{
    unknownInstr();
}

void m68kChkWordDpciDdProgram()
{
    unknownInstr();
}

void m68kChkWordImm16DdProgram()
{
    unknownInstr();
}

void m68kLeaAisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2f1 leaa1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_ftu = reg_dbin;
	    // 66 leaa2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLeaDasAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2f2 lead1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    // 309 lead2
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLeaDaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1fb leax0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3ea leax1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // leax2
	    // 130 leax2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // leax3
	    // 1f0 leax3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // leax4
	    // 30a leax4
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 4;
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLeaAdr16AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 275 laaw1
	    reg_aob = reg_au;
	    reg_da[rx_index] = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLeaAdr32AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e4 laal1
	    reg_aob = reg_au;
	    setReg16High(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bd laal2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLeaDpcAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2f2 lead1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    // 309 lead2
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLeaDpciAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1fb leax0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3ea leax1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // leax2
	    // 130 leax2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // leax3
	    // 1f0 leax3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // leax4
	    // 30a leax4
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 4;
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrByteDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 133 nnrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_da[ry_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrByteAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrByteAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_da[reg_movems], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrBytePaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_da[reg_movems], reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrByteDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrByteDaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrByteAdr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAndByte, reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrByteAdr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAndByte, reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrWordDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 133 nnrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_da[ry_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrWordAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrWordAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_da[reg_movems], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrWordPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - 2;
	    runALU(AluAnd, reg_da[reg_movems], reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrWordDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrWordDaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrWordAdr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAnd, reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrWordAdr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAnd, reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrLongDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 137 nnrl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_da[ry_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 15e nnrl2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0x0000);
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrLongAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluAnd, reg_alub, 0x0000);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrLongAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluAnd, reg_alub, 0x0000);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrLongPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluAnd, reg_alub, 0x0000);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrLongDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluAnd, reg_alub, 0x0000);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrLongDaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluAnd, reg_alub, 0x0000);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrLongAdr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAnd, reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluAnd, reg_alub, 0x0000);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrLongAdr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAnd, reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluAnd, reg_alub, 0x0000);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegByteDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 133 nnrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSubByte, reg_da[ry_index], 0x0000);
	    updateCCR(CcrXNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegByteAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegByteAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegBytePaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegByteDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegByteDaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegByteAdr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegByteAdr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegWordDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 133 nnrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSub, reg_da[ry_index], 0x0000);
	    updateCCR(CcrXNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegWordAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegWordAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegWordPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegWordDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegWordDaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegWordAdr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegWordAdr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegLongDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 137 nnrl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSub, reg_da[ry_index], 0x0000);
	    updateCCR(CcrXNZVC);
	    // 15e nnrl2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    runALU(AluSubc, high16(reg_da[ry_index]), 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegLongAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluSubc, reg_alub, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegLongAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluSubc, reg_alub, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegLongPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluSubc, reg_alub, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegLongDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluSubc, reg_alub, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegLongDaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluSubc, reg_alub, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegLongAdr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluSubc, reg_alub, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegLongAdr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluSubc, reg_alub, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveDsCcrProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 301 rstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_da[ry_index];
	    reg_au = reg_au - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveAisCcrProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveAipsCcrProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMovePaisCcrProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 9):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveDasCcrProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveDaisCcrProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveAdr16CcrProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveAdr32CcrProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 9):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveDpcCcrProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveDpciCcrProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveImm8CcrProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 301 rstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dt;
	    reg_au = reg_au - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotByteDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 133 nnrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluNotByte, reg_da[ry_index]);
	    updateCCR(CcrNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotByteAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndBytex, reg_dbin, 0xFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNotByte, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotByteAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndBytex, reg_alub, 0xFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNotByte, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotBytePaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndBytex, reg_alub, 0xFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNotByte, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotByteDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndBytex, reg_dbin, 0xFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNotByte, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotByteDaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndBytex, reg_dbin, 0xFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNotByte, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotByteAdr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndBytex, reg_dbin, 0xFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNotByte, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotByteAdr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndBytex, reg_dbin, 0xFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNotByte, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotWordDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 133 nnrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluNot, reg_da[ry_index]);
	    updateCCR(CcrNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotWordAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNot, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotWordAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndx, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNot, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotWordPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndx, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNot, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotWordDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNot, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotWordDaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNot, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotWordAdr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNot, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotWordAdr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNot, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotLongDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 137 nnrl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluNot, reg_da[ry_index]);
	    updateCCR(CcrNZVC);
	    // 15e nnrl2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    runALU(AluNot, high16(reg_da[ry_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotLongAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNot, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluNot, reg_alub);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotLongAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNot, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluNot, reg_alub);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotLongPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNot, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluNot, reg_alub);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotLongDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNot, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluNot, reg_alub);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotLongDaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNot, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluNot, reg_alub);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotLongAdr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNot, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluNot, reg_alub);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotLongAdr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNot, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluNot, reg_alub);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveDsSrProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    if (!checkPriv())
	    {
		setPriv();
		return;
	    }

	    // 301 rstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_da[ry_index];
	    reg_au = reg_au - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
	    updateSupervisor();
	    updateInterrupts();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveAisSrProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    if (!checkPriv())
	    {
		setPriv();
		return;
	    }

	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
	    updateSupervisor();
	    updateInterrupts();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveAipsSrProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    if (!checkPriv())
	    {
		setPriv();
		return;
	    }

	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndx, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
	    updateSupervisor();
	    updateInterrupts();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMovePaisSrProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    if (!checkPriv())
	    {
		setPriv();
		return;
	    }

	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndx, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
	    updateSupervisor();
	    updateInterrupts();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 9):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveDasSrProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    if (!checkPriv())
	    {
		setPriv();
		return;
	    }

	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
	    updateSupervisor();
	    updateInterrupts();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveDaisSrProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    if (!checkPriv())
	    {
		setPriv();
		return;
	    }

	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
	    updateSupervisor();
	    updateInterrupts();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveAdr16SrProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    if (!checkPriv())
	    {
		setPriv();
		return;
	    }

	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
	    updateSupervisor();
	    updateInterrupts();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveAdr32SrProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    if (!checkPriv())
	    {
		setPriv();
		return;
	    }

	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
	    updateSupervisor();
	    updateInterrupts();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 9):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveDpcSrProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    if (!checkPriv())
	    {
		setPriv();
		return;
	    }

	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
	    updateSupervisor();
	    updateInterrupts();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveDpciSrProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    if (!checkPriv())
	    {
		setPriv();
		return;
	    }

	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
	    updateSupervisor();
	    updateInterrupts();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveI16uSrProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    if (!checkPriv())
	    {
		setPriv();
		return;
	    }

	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 301 rstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dt;
	    reg_au = reg_au - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
	    updateSupervisor();
	    updateInterrupts();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNbcdByteDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 13b nbcr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSbcdByte, reg_da[ry_index], 0x0000);
	    updateCCR(CcrXNZVCU);
	    // 117 nbcr2
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNbcdByteAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 15c nbcm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluSbcdByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    // 113 asbb6
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNbcdByteAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 15c nbcm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluSbcdByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    // 113 asbb6
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNbcdBytePaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 15c nbcm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluSbcdByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    // 113 asbb6
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNbcdByteDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 15c nbcm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluSbcdByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    // 113 asbb6
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNbcdByteDaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 15c nbcm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluSbcdByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    // 113 asbb6
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNbcdByteAdr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 15c nbcm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluSbcdByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    // 113 asbb6
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNbcdByteAdr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 15c nbcm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluSbcdByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    // 113 asbb6
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSwapDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 341 swap1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[ry_index];
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_da[ry_index]);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 342 swap2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[ry_index] = merge32(high16(reg_at), reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kPeaAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 17c peaa1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = merge32(high16(reg_da[rx_index]), 0) - 4;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 106 peax6
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_at);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kPeaDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 17d pead1
	    reg_aob = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 17e pead2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_at;
	    // 17f pead3
	    reg_at = reg_au;
	    runALU(AluAnd, reg_au, 0xFFFF);
	    reg_au = merge32(high16(reg_da[rx_index]), 0) - 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 106 peax6
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_at);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kPeaDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1ff peax0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3ee peax1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // peax2
	    // 134 peax2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // peax3
	    // 1f4 peax3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // peax4
	    // 218 peax4
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_at = reg_au;
	    runALU(AluAnd, reg_au, 0xFFFF);
	    reg_au = reg_pc + 4;
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    // 219 peax5
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = merge32(high16(reg_da[rx_index]), 0) - 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 106 peax6
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_at);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kPeaAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 178 paaw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    reg_au = merge32(high16(reg_da[rx_index]), 0) - 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 10a paaw2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_at);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kPeaAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1fa paal1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 15f paal2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_da[rx_index]), 0) - 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 10a paaw2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_at);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kPeaDpcProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 17d pead1
	    reg_aob = reg_au;
	    reg_at = reg_pc;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 17e pead2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_at;
	    // 17f pead3
	    reg_at = reg_au;
	    runALU(AluAnd, reg_au, 0xFFFF);
	    reg_au = merge32(high16(reg_da[rx_index]), 0) - 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 106 peax6
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_at);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kPeaDpciProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1ff peax0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3ee peax1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // peax2
	    // 134 peax2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // peax3
	    // 1f4 peax3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // peax4
	    // 218 peax4
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_at = reg_au;
	    runALU(AluAnd, reg_au, 0xFFFF);
	    reg_au = reg_pc + 4;
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    // 219 peax5
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = merge32(high16(reg_da[rx_index]), 0) - 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 106 peax6
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_at);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kExtWordDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 133 nnrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluExt, reg_da[ry_index]);
	    updateCCR(CcrNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMovemWordListAisProgram()
{
    unknownInstr();
}

void m68kMovemWordListpPaisProgram()
{
    unknownInstr();
}

void m68kMovemWordListDasProgram()
{
    unknownInstr();
}

void m68kMovemWordListDaisProgram()
{
    unknownInstr();
}

void m68kMovemWordListAdr16Program()
{
    unknownInstr();
}

void m68kMovemWordListAdr32Program()
{
    unknownInstr();
}

void m68kExtLongDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 232 extr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 233 extr2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[ry_index] = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMovemLongListAisProgram()
{
    unknownInstr();
}

void m68kMovemLongListpPaisProgram()
{
    unknownInstr();
}

void m68kMovemLongListDasProgram()
{
    unknownInstr();
}

void m68kMovemLongListDaisProgram()
{
    unknownInstr();
}

void m68kMovemLongListAdr16Program()
{
    unknownInstr();
}

void m68kMovemLongListAdr32Program()
{
    unknownInstr();
}

void m68kTstByteDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 12d tsrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstByteAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstByteAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_da[reg_movems], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstBytePaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_da[reg_movems], reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstByteDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstByteDaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstByteAdr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluOrByte, reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstByteAdr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluOrByte, reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstWordDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 12d tsrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstWordAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstWordAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluOr, reg_da[reg_movems], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstWordPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - 2;
	    runALU(AluOr, reg_da[reg_movems], reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstWordDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstWordDaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstWordAdr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluOr, reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstWordAdr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluOr, reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstLongDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 125 tsrl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 362 tsrl2
	    reg_ird = reg_ir;
	    setIntState();
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstLongAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3cb tsml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 361 tsml2
	    reg_ird = reg_ir;
	    setIntState();
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstLongAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3cb tsml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 361 tsml2
	    reg_ird = reg_ir;
	    setIntState();
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstLongPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3cb tsml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 361 tsml2
	    reg_ird = reg_ir;
	    setIntState();
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstLongDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3cb tsml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 361 tsml2
	    reg_ird = reg_ir;
	    setIntState();
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstLongDaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3cb tsml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 361 tsml2
	    reg_ird = reg_ir;
	    setIntState();
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstLongAdr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluOr, reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3cb tsml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 361 tsml2
	    reg_ird = reg_ir;
	    setIntState();
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstLongAdr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluOr, reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3cb tsml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 361 tsml2
	    reg_ird = reg_ir;
	    setIntState();
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTasDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 345 tasr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[ry_index];
	    reg_pc = reg_au;
	    runALU(AluOrByte, reg_ftu, reg_da[ry_index]);
	    // 346 tasr2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTasAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readRMC();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 343 tasm1
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_ftu, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 344 tasm2
	    reg_aob = reg_au;
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeRMC();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTasAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_da[reg_movems], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readRMC();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 343 tasm1
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_ftu, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 344 tasm2
	    reg_aob = reg_au;
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeRMC();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTasPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_da[reg_movems], reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readRMC();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 343 tasm1
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_ftu, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 344 tasm2
	    reg_aob = reg_au;
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeRMC();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTasDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readRMC();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 343 tasm1
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_ftu, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 344 tasm2
	    reg_aob = reg_au;
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeRMC();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTasDaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readRMC();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 343 tasm1
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_ftu, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    // 344 tasm2
	    reg_aob = reg_au;
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeRMC();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTasAdr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluOrByte, reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readRMC();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 343 tasm1
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_ftu, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 344 tasm2
	    reg_aob = reg_au;
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeRMC();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTasAdr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluOrByte, reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readRMC();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 343 tasm1
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_ftu, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 344 tasm2
	    reg_aob = reg_au;
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeRMC();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMovemWordAisListProgram()
{
    unknownInstr();
}

void m68kMovemWordAipsListProgram()
{
    unknownInstr();
}

void m68kMovemWordDasListProgram()
{
    unknownInstr();
}

void m68kMovemWordDaisListProgram()
{
    unknownInstr();
}

void m68kMovemWordAdr16ListProgram()
{
    unknownInstr();
}

void m68kMovemWordAdr32ListProgram()
{
    unknownInstr();
}

void m68kMovemWordDpcListProgram()
{
    unknownInstr();
}

void m68kMovemWordDpciListProgram()
{
    unknownInstr();
}

void m68kMovemLongAisListProgram()
{
    unknownInstr();
}

void m68kMovemLongAipsListProgram()
{
    unknownInstr();
}

void m68kMovemLongDasListProgram()
{
    unknownInstr();
}

void m68kMovemLongDaisListProgram()
{
    unknownInstr();
}

void m68kMovemLongAdr16ListProgram()
{
    unknownInstr();
}

void m68kMovemLongAdr32ListProgram()
{
    unknownInstr();
}

void m68kMovemLongDpcListProgram()
{
    unknownInstr();
}

void m68kMovemLongDpciListProgram()
{
    unknownInstr();
}

void m68kTrapImm4Program()
{
    unknownInstr();
}

void m68kLinkAsImm16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 30b link1
	    reg_aob = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    // 2b5 link2
	    reg_pc = reg_au;
	    reg_au = reg_da[reg_sp] - 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 30c link3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = high16(reg_at);
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    // 30d link4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[reg_sp] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kUnlkAsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 119 unlk1
	    reg_aob = reg_da[ry_index];
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    stepMovem();
	    // 1fe unlk2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 27c unlk3
	    reg_aob = reg_pc;
	    reg_da[reg_sp] = reg_au;
	    reg_au = reg_pc + 2;
	    // 27d unlk4
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[ry_index] = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveAsUspProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    if (!checkPriv())
	    {
		setPriv();
		return;
	    }

	    // 2f5 lusp1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_ftu = reg_dbin;
	    // 66 leaa2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[15] = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveUspAsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    if (!checkPriv())
	    {
		setPriv();
		return;
	    }

	    // 230 susp1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dcr = reg_da[15];
	    reg_at = reg_da[15];
	    reg_au = reg_da[ry_index];
	    // 233 extr2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[ry_index] = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kResetProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    if (!checkPriv())
	    {
		setPriv();
		return;
	    }

	    // 3a6 rset1
	    reg_ird = reg_ir;
	    setIntState();
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0x0000);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 27b rset2
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = ext32(reg_aluo) - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    jump(1);
	}
	break;
	case getCycle(1, 0):
	{
	    // rset3
	    // e4 rset3
	    reg_au = reg_au - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    // 114 rset4
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 4):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // rset5
	    // 64 rset5
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNopProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kStopI16uProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    if (!checkPriv())
	    {
		setPriv();
		return;
	    }

	    // 3a2 stop1
	    reg_ird = reg_ir;
	    setIntState();
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0x0000);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 327 aaa01
	    reg_ird = reg_ir;
	    setIntState();
	    reg_pc = reg_au;
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
	    updateSupervisor();
	    updateInterrupts();
	    reg_au = reg_au - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    nextInst();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRteProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    if (!checkPriv())
	    {
		setPriv();
		return;
	    }

	    // 12a rtr1
	    reg_aob = reg_da[reg_sp];
	    reg_au = reg_da[reg_sp] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 12b rtr2
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 3c5 rtr3
	    reg_aob = reg_au;
	    reg_at = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    // 302 rtr4
	    setReg16High(reg_at, reg_dbin);
	    reg_da[reg_sp] = reg_au;
	    reg_new_sr = reg_isr = (reg_ftu & 0xA71F);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    updateSR();
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b3 jmal2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRtsProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 126 rts1
	    reg_aob = reg_da[reg_sp];
	    reg_au = reg_da[reg_sp] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 116 rts2
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 303 rts3
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_da[reg_sp] = reg_au;
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTrapvProgram()
{
    unknownInstr();
}

void m68kRtrProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 12a rtr1
	    reg_aob = reg_da[reg_sp];
	    reg_au = reg_da[reg_sp] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 12b rtr2
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 3c5 rtr3
	    reg_aob = reg_au;
	    reg_at = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    // 302 rtr4
	    setReg16High(reg_at, reg_dbin);
	    reg_da[reg_sp] = reg_au;
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b3 jmal2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kJsrAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 273 jsra1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[reg_sp] - 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 271 jsaw2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_pc);
	    reg_da[reg_sp] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    // 272 jsaw3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_pc;
	    reg_au = reg_at + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kJsrDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b0 jsrd1
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 274 jsrd2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    // 2b1 jsrd3
	    reg_pc = reg_au;
	    reg_au = reg_da[reg_sp] - 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 271 jsaw2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_pc);
	    reg_da[reg_sp] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 272 jsaw3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_pc;
	    reg_au = reg_at + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kJsrDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1f3 jsrx0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 2b2 jsrx1
	    reg_t = testbit(reg_irc, 11);
	    reg_au = ext32(reg_aluo) + reg_da[ry_index];
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // jsrx2
	    // 29 jsrx2
	    reg_au = reg_au + ext32(reg_da[mapSP(reg_irc >> 12)]);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // jsrx3
	    // e9 jsrx3
	    reg_au = reg_au + reg_da[mapSP(reg_irc >> 12)];
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // jsrd2
	    // 274 jsrd2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    // 2b1 jsrd3
	    reg_pc = reg_au;
	    reg_au = reg_da[reg_sp] - 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 271 jsaw2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_pc);
	    reg_da[reg_sp] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    // 272 jsaw3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_pc;
	    reg_au = reg_at + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kJsrAdr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 293 jsaw0
	    reg_at = ext32(reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 270 jsaw1
	    reg_aob = reg_at;
	    reg_pc = reg_au;
	    reg_au = reg_da[reg_sp] - 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 271 jsaw2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_pc);
	    reg_da[reg_sp] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 272 jsaw3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_pc;
	    reg_au = reg_at + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kJsrAdr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1f2 jsal1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 256 jsal2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = reg_da[reg_sp] - 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 271 jsaw2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_pc);
	    reg_da[reg_sp] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    // 272 jsaw3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_pc;
	    reg_au = reg_at + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kJsrDpcProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b0 jsrd1
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 274 jsrd2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    // 2b1 jsrd3
	    reg_pc = reg_au;
	    reg_au = reg_da[reg_sp] - 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 271 jsaw2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_pc);
	    reg_da[reg_sp] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 272 jsaw3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_pc;
	    reg_au = reg_at + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kJsrDpciProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1f3 jsrx0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 2b2 jsrx1
	    reg_t = testbit(reg_irc, 11);
	    reg_au = ext32(reg_aluo) + reg_pc;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // jsrx2
	    // 29 jsrx2
	    reg_au = reg_au + ext32(reg_da[mapSP(reg_irc >> 12)]);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // jsrx3
	    // e9 jsrx3
	    reg_au = reg_au + reg_da[mapSP(reg_irc >> 12)];
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // jsrd2
	    // 274 jsrd2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    // 2b1 jsrd3
	    reg_pc = reg_au;
	    reg_au = reg_da[reg_sp] - 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 271 jsaw2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_pc);
	    reg_da[reg_sp] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    // 272 jsaw3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_pc;
	    reg_au = reg_at + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kJmpAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 255 jmpa1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kJmpDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b4 jmpd1
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kJmpDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1f7 jmpx0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 2b6 jmpx1
	    reg_t = testbit(reg_irc, 11);
	    reg_au = ext32(reg_aluo) + reg_da[ry_index];
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // jmpx2
	    // 2d jmpx2
	    reg_au = reg_au + ext32(reg_da[mapSP(reg_irc >> 12)]);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // jmpx3
	    // ed jmpx3
	    reg_au = reg_au + reg_da[mapSP(reg_irc >> 12)];
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // bbci3
	    // c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kJmpAdr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 297 jmaw1
	    reg_at = ext32(reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 2b3 jmal2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kJmpAdr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1f6 jmal1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b3 jmal2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kJmpDpcProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2b4 jmpd1
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kJmpDpciProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1f7 jmpx0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 2b6 jmpx1
	    reg_t = testbit(reg_irc, 11);
	    reg_au = ext32(reg_aluo) + reg_pc;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // jmpx2
	    // 2d jmpx2
	    reg_au = reg_au + ext32(reg_da[mapSP(reg_irc >> 12)]);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // jmpx3
	    // ed jmpx3
	    reg_au = reg_au + reg_da[mapSP(reg_irc >> 12)];
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // bbci3
	    // c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqByteImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2d8 raqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    runALU(AluAddByte, reg_ftu, reg_da[ry_index]);
	    updateCCR(CcrXNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqByteImm3AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqByteImm3AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqByteImm3PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqByteImm3DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqByteImm3DaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqByteImm3Adr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqByteImm3Adr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqWordImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2d8 raqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    runALU(AluAdd, reg_ftu, reg_da[ry_index]);
	    updateCCR(CcrXNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqWordImm3AsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2dc raql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    runALU(AluAdd, reg_ftu, reg_da[ry_index]);
	    // 259 roal2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25a roal3
	    runALU(AluAddc, high16(reg_dt), high16(reg_da[ry_index]));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqWordImm3AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAdd, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqWordImm3AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAdd, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqWordImm3PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAdd, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqWordImm3DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAdd, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqWordImm3DaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAdd, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqWordImm3Adr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAdd, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqWordImm3Adr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAdd, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqLongImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2dc raql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    runALU(AluAdd, reg_ftu, reg_da[ry_index]);
	    updateCCR(CcrXNZVC);
	    // 259 roal2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25a roal3
	    runALU(AluAddc, high16(reg_dt), high16(reg_da[ry_index]));
	    updateCCR(CcrXNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqLongImm3AsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2dc raql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    runALU(AluAdd, reg_ftu, reg_da[ry_index]);
	    // 259 roal2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25a roal3
	    runALU(AluAddc, high16(reg_dt), high16(reg_da[ry_index]));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqLongImm3AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAdd, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqLongImm3AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAdd, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqLongImm3PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAdd, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqLongImm3DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAdd, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqLongImm3DaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAdd, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqLongImm3Adr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAdd, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqLongImm3Adr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAdd, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kStDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 384 sccr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 1;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // roaw2
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	case getCycle(2, 0):
	{
	    // sccr2
	    // cb sccr2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 3):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kDbtDsRel16Program()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6c dbcc1
	    reg_t = 1;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // dbcc2
	    // 46 dbcc2
	    reg_aob = reg_au;
	    reg_alub = reg_da[ry_index];
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    // 175 dbcc3
	    reg_t = testbit(reg_isr, 2);
	    reg_pc = reg_au;
	    reg_au = reg_at + 2;
	    runALU(AluAdd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jumpCond2(4, 3);
	}
	break;
	case getCycle(2, 0):
	{
	    // dbcc6
	    // c6 dbcc6
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    setTrace();
	    // c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	case getCycle(3, 0):
	{
	    // dbcc4
	    // c7 dbcc4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	case getCycle(4, 0):
	{
	    // dbcc5
	    // 7 dbcc5
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(4, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    setTrace();
	    jump(3);
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kStAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 1;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // sccb3
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // sccb2
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // morw2
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kStAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 1;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // sccb3
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // sccb2
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // morw2
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kStPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 1;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // sccb3
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // sccb2
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // morw2
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kStDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 1;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // sccb3
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // sccb2
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // morw2
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kStDaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 1;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    jumpCond2(5, 4);
	}
	break;
	case getCycle(4, 0):
	{
	    // sccb3
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(4, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(6);
	}
	break;
	case getCycle(5, 0):
	{
	    // sccb2
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(5, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jump(6);
	}
	break;
	case getCycle(6, 0):
	{
	    // morw2
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(6, 1):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kStAdr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 1;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // sccb3
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // sccb2
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // morw2
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kStAdr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 1;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // sccb3
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // sccb2
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // morw2
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqByteImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2d8 raqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    runALU(AluSubByte, reg_ftu, reg_da[ry_index]);
	    updateCCR(CcrXNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqByteImm3AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqByteImm3AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqByteImm3PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqByteImm3DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqByteImm3DaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqByteImm3Adr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqByteImm3Adr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqWordImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2d8 raqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    runALU(AluSub, reg_ftu, reg_da[ry_index]);
	    updateCCR(CcrXNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqWordImm3AsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2dc raql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    runALU(AluSub, reg_ftu, reg_da[ry_index]);
	    // 259 roal2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25a roal3
	    runALU(AluSubc, high16(reg_dt), high16(reg_da[ry_index]));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqWordImm3AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSub, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqWordImm3AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSub, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqWordImm3PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSub, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqWordImm3DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSub, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqWordImm3DaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSub, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqWordImm3Adr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSub, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqWordImm3Adr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSub, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqLongImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2dc raql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    runALU(AluSub, reg_ftu, reg_da[ry_index]);
	    updateCCR(CcrXNZVC);
	    // 259 roal2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25a roal3
	    runALU(AluSubc, high16(reg_dt), high16(reg_da[ry_index]));
	    updateCCR(CcrXNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqLongImm3AsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 2dc raql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    runALU(AluSub, reg_ftu, reg_da[ry_index]);
	    // 259 roal2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25a roal3
	    runALU(AluSubc, high16(reg_dt), high16(reg_da[ry_index]));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqLongImm3AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSub, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqLongImm3AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSub, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqLongImm3PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSub, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqLongImm3DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSub, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqLongImm3DaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSub, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqLongImm3Adr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSub, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqLongImm3Adr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSub, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSfDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 384 sccr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 0;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // roaw2
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	case getCycle(2, 0):
	{
	    // sccr2
	    // cb sccr2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 3):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kDbraDsRel16Program()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6c dbcc1
	    reg_t = 0;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // dbcc2
	    // 46 dbcc2
	    reg_aob = reg_au;
	    reg_alub = reg_da[ry_index];
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    // 175 dbcc3
	    reg_t = testbit(reg_isr, 2);
	    reg_pc = reg_au;
	    reg_au = reg_at + 2;
	    runALU(AluAdd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jumpCond2(4, 3);
	}
	break;
	case getCycle(2, 0):
	{
	    // dbcc6
	    // c6 dbcc6
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    setTrace();
	    // c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	case getCycle(3, 0):
	{
	    // dbcc4
	    // c7 dbcc4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	case getCycle(4, 0):
	{
	    // dbcc5
	    // 7 dbcc5
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(4, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    setTrace();
	    jump(3);
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSfAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 0;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // sccb3
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // sccb2
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // morw2
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSfAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 0;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // sccb3
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // sccb2
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // morw2
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSfPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 0;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // sccb3
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // sccb2
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // morw2
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSfDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 0;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // sccb3
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // sccb2
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // morw2
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSfDaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 0;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    jumpCond2(5, 4);
	}
	break;
	case getCycle(4, 0):
	{
	    // sccb3
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(4, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(6);
	}
	break;
	case getCycle(5, 0):
	{
	    // sccb2
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(5, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jump(6);
	}
	break;
	case getCycle(6, 0):
	{
	    // morw2
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(6, 1):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSfAdr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 0;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // sccb3
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // sccb2
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // morw2
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSfAdr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 0;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // sccb3
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // sccb2
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // morw2
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kShiDsProgram()
{
    unknownInstr();
}

void m68kDbhiDsRel16Program()
{
    unknownInstr();
}

void m68kShiAisProgram()
{
    unknownInstr();
}

void m68kShiAipsProgram()
{
    unknownInstr();
}

void m68kShiPaisProgram()
{
    unknownInstr();
}

void m68kShiDasProgram()
{
    unknownInstr();
}

void m68kShiDaisProgram()
{
    unknownInstr();
}

void m68kShiAdr16Program()
{
    unknownInstr();
}

void m68kShiAdr32Program()
{
    unknownInstr();
}

void m68kSlsDsProgram()
{
    unknownInstr();
}

void m68kDblsDsRel16Program()
{
    unknownInstr();
}

void m68kSlsAisProgram()
{
    unknownInstr();
}

void m68kSlsAipsProgram()
{
    unknownInstr();
}

void m68kSlsPaisProgram()
{
    unknownInstr();
}

void m68kSlsDasProgram()
{
    unknownInstr();
}

void m68kSlsDaisProgram()
{
    unknownInstr();
}

void m68kSlsAdr16Program()
{
    unknownInstr();
}

void m68kSlsAdr32Program()
{
    unknownInstr();
}

void m68kSccDsProgram()
{
    unknownInstr();
}

void m68kDbccDsRel16Program()
{
    unknownInstr();
}

void m68kSccAisProgram()
{
    unknownInstr();
}

void m68kSccAipsProgram()
{
    unknownInstr();
}

void m68kSccPaisProgram()
{
    unknownInstr();
}

void m68kSccDasProgram()
{
    unknownInstr();
}

void m68kSccDaisProgram()
{
    unknownInstr();
}

void m68kSccAdr16Program()
{
    unknownInstr();
}

void m68kSccAdr32Program()
{
    unknownInstr();
}

void m68kScsDsProgram()
{
    unknownInstr();
}

void m68kDbcsDsRel16Program()
{
    unknownInstr();
}

void m68kScsAisProgram()
{
    unknownInstr();
}

void m68kScsAipsProgram()
{
    unknownInstr();
}

void m68kScsPaisProgram()
{
    unknownInstr();
}

void m68kScsDasProgram()
{
    unknownInstr();
}

void m68kScsDaisProgram()
{
    unknownInstr();
}

void m68kScsAdr16Program()
{
    unknownInstr();
}

void m68kScsAdr32Program()
{
    unknownInstr();
}

void m68kSneDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 384 sccr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = testbit(reg_sr, 2) ? 0 : 1;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // roaw2
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	case getCycle(2, 0):
	{
	    // sccr2
	    // cb sccr2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 3):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kDbneDsRel16Program()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6c dbcc1
	    reg_t = testbit(reg_sr, 2) ? 0 : 1;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // dbcc2
	    // 46 dbcc2
	    reg_aob = reg_au;
	    reg_alub = reg_da[ry_index];
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    // 175 dbcc3
	    reg_t = testbit(reg_isr, 2);
	    reg_pc = reg_au;
	    reg_au = reg_at + 2;
	    runALU(AluAdd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jumpCond2(4, 3);
	}
	break;
	case getCycle(2, 0):
	{
	    // dbcc6
	    // c6 dbcc6
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    setTrace();
	    // c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	case getCycle(3, 0):
	{
	    // dbcc4
	    // c7 dbcc4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	case getCycle(4, 0):
	{
	    // dbcc5
	    // 7 dbcc5
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(4, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    setTrace();
	    jump(3);
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSneAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = testbit(reg_sr, 2) ? 0 : 1;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // sccb3
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // sccb2
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // morw2
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSneAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = testbit(reg_sr, 2) ? 0 : 1;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // sccb3
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // sccb2
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // morw2
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSnePaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = testbit(reg_sr, 2) ? 0 : 1;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // sccb3
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // sccb2
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // morw2
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSneDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = testbit(reg_sr, 2) ? 0 : 1;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // sccb3
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // sccb2
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // morw2
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSneDaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = testbit(reg_sr, 2) ? 0 : 1;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    jumpCond2(5, 4);
	}
	break;
	case getCycle(4, 0):
	{
	    // sccb3
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(4, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(6);
	}
	break;
	case getCycle(5, 0):
	{
	    // sccb2
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(5, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jump(6);
	}
	break;
	case getCycle(6, 0):
	{
	    // morw2
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(6, 1):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSneAdr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = testbit(reg_sr, 2) ? 0 : 1;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // sccb3
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // sccb2
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // morw2
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSneAdr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = testbit(reg_sr, 2) ? 0 : 1;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // sccb3
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // sccb2
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // morw2
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSeqDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 384 sccr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = testbit(reg_sr, 2) ? 1 : 0;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // roaw2
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	case getCycle(2, 0):
	{
	    // sccr2
	    // cb sccr2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 3):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kDbeqDsRel16Program()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6c dbcc1
	    reg_t = testbit(reg_sr, 2) ? 1 : 0;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // dbcc2
	    // 46 dbcc2
	    reg_aob = reg_au;
	    reg_alub = reg_da[ry_index];
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    // 175 dbcc3
	    reg_t = testbit(reg_isr, 2);
	    reg_pc = reg_au;
	    reg_au = reg_at + 2;
	    runALU(AluAdd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    jumpCond2(4, 3);
	}
	break;
	case getCycle(2, 0):
	{
	    // dbcc6
	    // c6 dbcc6
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    setTrace();
	    // c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	case getCycle(3, 0):
	{
	    // dbcc4
	    // c7 dbcc4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	case getCycle(4, 0):
	{
	    // dbcc5
	    // 7 dbcc5
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(4, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    setTrace();
	    jump(3);
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSeqAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = testbit(reg_sr, 2) ? 1 : 0;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // sccb3
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // sccb2
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // morw2
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSeqAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = testbit(reg_sr, 2) ? 1 : 0;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // sccb3
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // sccb2
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // morw2
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSeqPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = testbit(reg_sr, 2) ? 1 : 0;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // sccb3
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // sccb2
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // morw2
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSeqDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = testbit(reg_sr, 2) ? 1 : 0;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // sccb3
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // sccb2
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // morw2
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSeqDaisProgram()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = testbit(reg_sr, 2) ? 1 : 0;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    jumpCond2(5, 4);
	}
	break;
	case getCycle(4, 0):
	{
	    // sccb3
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(4, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(6);
	}
	break;
	case getCycle(5, 0):
	{
	    // sccb2
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(5, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jump(6);
	}
	break;
	case getCycle(6, 0):
	{
	    // morw2
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(6, 1):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSeqAdr16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = testbit(reg_sr, 2) ? 1 : 0;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // sccb3
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // sccb2
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // morw2
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSeqAdr32Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = testbit(reg_sr, 2) ? 1 : 0;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // sccb3
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // sccb2
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // morw2
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSvcDsProgram()
{
    unknownInstr();
}

void m68kDbvcDsRel16Program()
{
    unknownInstr();
}

void m68kSvcAisProgram()
{
    unknownInstr();
}

void m68kSvcAipsProgram()
{
    unknownInstr();
}

void m68kSvcPaisProgram()
{
    unknownInstr();
}

void m68kSvcDasProgram()
{
    unknownInstr();
}

void m68kSvcDaisProgram()
{
    unknownInstr();
}

void m68kSvcAdr16Program()
{
    unknownInstr();
}

void m68kSvcAdr32Program()
{
    unknownInstr();
}

void m68kSvsDsProgram()
{
    unknownInstr();
}

void m68kDbvsDsRel16Program()
{
    unknownInstr();
}

void m68kSvsAisProgram()
{
    unknownInstr();
}

void m68kSvsAipsProgram()
{
    unknownInstr();
}

void m68kSvsPaisProgram()
{
    unknownInstr();
}

void m68kSvsDasProgram()
{
    unknownInstr();
}

void m68kSvsDaisProgram()
{
    unknownInstr();
}

void m68kSvsAdr16Program()
{
    unknownInstr();
}

void m68kSvsAdr32Program()
{
    unknownInstr();
}

void m68kSplDsProgram()
{
    unknownInstr();
}

void m68kDbplDsRel16Program()
{
    unknownInstr();
}

void m68kSplAisProgram()
{
    unknownInstr();
}

void m68kSplAipsProgram()
{
    unknownInstr();
}

void m68kSplPaisProgram()
{
    unknownInstr();
}

void m68kSplDasProgram()
{
    unknownInstr();
}

void m68kSplDaisProgram()
{
    unknownInstr();
}

void m68kSplAdr16Program()
{
    unknownInstr();
}

void m68kSplAdr32Program()
{
    unknownInstr();
}

void m68kSmiDsProgram()
{
    unknownInstr();
}

void m68kDbmiDsRel16Program()
{
    unknownInstr();
}

void m68kSmiAisProgram()
{
    unknownInstr();
}

void m68kSmiAipsProgram()
{
    unknownInstr();
}

void m68kSmiPaisProgram()
{
    unknownInstr();
}

void m68kSmiDasProgram()
{
    unknownInstr();
}

void m68kSmiDaisProgram()
{
    unknownInstr();
}

void m68kSmiAdr16Program()
{
    unknownInstr();
}

void m68kSmiAdr32Program()
{
    unknownInstr();
}

void m68kSgeDsProgram()
{
    unknownInstr();
}

void m68kDbgeDsRel16Program()
{
    unknownInstr();
}

void m68kSgeAisProgram()
{
    unknownInstr();
}

void m68kSgeAipsProgram()
{
    unknownInstr();
}

void m68kSgePaisProgram()
{
    unknownInstr();
}

void m68kSgeDasProgram()
{
    unknownInstr();
}

void m68kSgeDaisProgram()
{
    unknownInstr();
}

void m68kSgeAdr16Program()
{
    unknownInstr();
}

void m68kSgeAdr32Program()
{
    unknownInstr();
}

void m68kSltDsProgram()
{
    unknownInstr();
}

void m68kDbltDsRel16Program()
{
    unknownInstr();
}

void m68kSltAisProgram()
{
    unknownInstr();
}

void m68kSltAipsProgram()
{
    unknownInstr();
}

void m68kSltPaisProgram()
{
    unknownInstr();
}

void m68kSltDasProgram()
{
    unknownInstr();
}

void m68kSltDaisProgram()
{
    unknownInstr();
}

void m68kSltAdr16Program()
{
    unknownInstr();
}

void m68kSltAdr32Program()
{
    unknownInstr();
}

void m68kSgtDsProgram()
{
    unknownInstr();
}

void m68kDbgtDsRel16Program()
{
    unknownInstr();
}

void m68kSgtAisProgram()
{
    unknownInstr();
}

void m68kSgtAipsProgram()
{
    unknownInstr();
}

void m68kSgtPaisProgram()
{
    unknownInstr();
}

void m68kSgtDasProgram()
{
    unknownInstr();
}

void m68kSgtDaisProgram()
{
    unknownInstr();
}

void m68kSgtAdr16Program()
{
    unknownInstr();
}

void m68kSgtAdr32Program()
{
    unknownInstr();
}

void m68kSleDsProgram()
{
    unknownInstr();
}

void m68kDbleDsRel16Program()
{
    unknownInstr();
}

void m68kSleAisProgram()
{
    unknownInstr();
}

void m68kSleAipsProgram()
{
    unknownInstr();
}

void m68kSlePaisProgram()
{
    unknownInstr();
}

void m68kSleDasProgram()
{
    unknownInstr();
}

void m68kSleDaisProgram()
{
    unknownInstr();
}

void m68kSleAdr16Program()
{
    unknownInstr();
}

void m68kSleAdr32Program()
{
    unknownInstr();
}

void m68kBraRel16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 68 bbcw1
	    reg_t = 1;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // bbcw3
	    // 85 bbcw3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    setTrace();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // bbci3
	    // c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // b
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBraRel8Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 308 bbci1
	    reg_t = 1;
	    reg_au = reg_pc + ext32(reg_ftu);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // bbci2
	    // 45 bbci2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    setTrace();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // bbci3
	    // c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // b
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBsrRel16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a9 bsrw1
	    reg_at = reg_au;
	    runALU(AluAnd, reg_au, 0xFFFF);
	    reg_au = reg_da[reg_sp] - 4;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 10e bsrw2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_at);
	    reg_da[reg_sp] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    // aa bsrw3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBsrRel8Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 89 bsri1
	    reg_at = reg_pc;
	    reg_au = reg_da[reg_sp] - 4;
	    runALU(AluAnd, reg_pc, 0xFFFF);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 102 bsri2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_at);
	    reg_da[reg_sp] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    // a8 bsri3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = ext32(reg_ftu) + reg_pc;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBhiRel16Program()
{
    unknownInstr();
}

void m68kBhiRel8Program()
{
    unknownInstr();
}

void m68kBlsRel16Program()
{
    unknownInstr();
}

void m68kBlsRel8Program()
{
    unknownInstr();
}

void m68kBccRel16Program()
{
    unknownInstr();
}

void m68kBccRel8Program()
{
    unknownInstr();
}

void m68kBcsRel16Program()
{
    unknownInstr();
}

void m68kBcsRel8Program()
{
    unknownInstr();
}

void m68kBneRel16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 68 bbcw1
	    reg_t = testbit(reg_sr, 2) ? 0 : 1;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // bbcw3
	    // 85 bbcw3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    setTrace();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // bbci3
	    // c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // b
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBneRel8Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 308 bbci1
	    reg_t = testbit(reg_sr, 2) ? 0 : 1;
	    reg_au = reg_pc + ext32(reg_ftu);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // bbci2
	    // 45 bbci2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    setTrace();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // bbci3
	    // c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // b
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBeqRel16Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 68 bbcw1
	    reg_t = testbit(reg_sr, 2) ? 1 : 0;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // bbcw3
	    // 85 bbcw3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    setTrace();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // bbci3
	    // c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // b
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBeqRel8Program()
{
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 308 bbci1
	    reg_t = testbit(reg_sr, 2) ? 1 : 0;
	    reg_au = reg_pc + ext32(reg_ftu);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // bbci2
	    // 45 bbci2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    setTrace();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // bbci3
	    // c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // b
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBvcRel16Program()
{
    unknownInstr();
}

void m68kBvcRel8Program()
{
    unknownInstr();
}

void m68kBvsRel16Program()
{
    unknownInstr();
}

void m68kBvsRel8Program()
{
    unknownInstr();
}

void m68kBplRel16Program()
{
    unknownInstr();
}

void m68kBplRel8Program()
{
    unknownInstr();
}

void m68kBmiRel16Program()
{
    unknownInstr();
}

void m68kBmiRel8Program()
{
    unknownInstr();
}

void m68kBgeRel16Program()
{
    unknownInstr();
}

void m68kBgeRel8Program()
{
    unknownInstr();
}

void m68kBltRel16Program()
{
    unknownInstr();
}

void m68kBltRel8Program()
{
    unknownInstr();
}

void m68kBgtRel16Program()
{
    unknownInstr();
}

void m68kBgtRel8Program()
{
    unknownInstr();
}

void m68kBleRel16Program()
{
    unknownInstr();
}

void m68kBleRel8Program()
{
    unknownInstr();
}

void m68kMoveqImm8oDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 23b rlql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_da[rx_index] = ext32(reg_ftu);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_ftu, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrByteDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluOrByte, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrByteAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOrByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrByteAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOrByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrBytePaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOrByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrByteDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOrByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrByteDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOrByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrByteAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOrByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrByteAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOrByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrByteDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOrByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrByteDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOrByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrByteImm8DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluOrByte, reg_dt, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrWordDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluOr, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrWordAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOr, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrWordAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOr, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrWordPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOr, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrWordDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOr, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrWordDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOr, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrWordAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOr, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrWordAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOr, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrWordDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOr, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrWordDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOr, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrWordImm16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluOr, reg_dt, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrLongDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluOr, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    runALU(AluOr, high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrLongAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOr, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluOr, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrLongAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOr, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluOr, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrLongPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOr, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluOr, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrLongDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOr, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluOr, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrLongDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOr, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluOr, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrLongAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOr, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluOr, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrLongAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOr, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluOr, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrLongDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOr, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluOr, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrLongDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOr, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluOr, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrLongImm32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluOr, reg_dt, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    runALU(AluOr, high16(reg_dt), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kDivuWordDsDdProgram()
{
    unknownInstr();
}

void m68kDivuWordAisDdProgram()
{
    unknownInstr();
}

void m68kDivuWordAipsDdProgram()
{
    unknownInstr();
}

void m68kDivuWordPaisDdProgram()
{
    unknownInstr();
}

void m68kDivuWordDasDdProgram()
{
    unknownInstr();
}

void m68kDivuWordDaisDdProgram()
{
    unknownInstr();
}

void m68kDivuWordAdr16DdProgram()
{
    unknownInstr();
}

void m68kDivuWordAdr32DdProgram()
{
    unknownInstr();
}

void m68kDivuWordDpcDdProgram()
{
    unknownInstr();
}

void m68kDivuWordDpciDdProgram()
{
    unknownInstr();
}

void m68kDivuWordImm16DdProgram()
{
    unknownInstr();
}

void m68kSbcdDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1cd rbrb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluSbcdByte, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrXNZVCU);
	    // 11b rbrb2
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 238 rbrb3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSbcdPaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 107 asbb1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 135 asbb2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 136 asbb3
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 4e asbb4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_at = reg_au;
	    reg_da[rx_index] = reg_au;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    reg_dbin = reg_edb;
	    // 40 asbb5
	    reg_aob = reg_pc;
	    runALU(AluSbcdByte, reg_alub, reg_dbin);
	    updateCCR(CcrXNZVCU);
	    // 113 asbb6
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrByteDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrByteDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrByteDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrByteDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrByteDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrByteDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrByteDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrWordDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrWordDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrWordDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrWordDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrWordDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrWordDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrWordDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrLongDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluOr, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrLongDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluOr, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrLongDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluOr, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrLongDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluOr, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrLongDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluOr, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrLongDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluOr, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrLongDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluOr, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kDivsWordDsDdProgram()
{
    unknownInstr();
}

void m68kDivsWordAisDdProgram()
{
    unknownInstr();
}

void m68kDivsWordAipsDdProgram()
{
    unknownInstr();
}

void m68kDivsWordPaisDdProgram()
{
    unknownInstr();
}

void m68kDivsWordDasDdProgram()
{
    unknownInstr();
}

void m68kDivsWordDaisDdProgram()
{
    unknownInstr();
}

void m68kDivsWordAdr16DdProgram()
{
    unknownInstr();
}

void m68kDivsWordAdr32DdProgram()
{
    unknownInstr();
}

void m68kDivsWordDpcDdProgram()
{
    unknownInstr();
}

void m68kDivsWordDpciDdProgram()
{
    unknownInstr();
}

void m68kDivsWordImm16DdProgram()
{
    unknownInstr();
}

void m68kSubByteDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluSubByte, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubByteAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSubByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubByteAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSubByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubBytePaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSubByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubByteDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSubByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubByteDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSubByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubByteAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSubByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubByteAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSubByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubByteDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSubByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubByteDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSubByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubByteImm8DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluSubByte, reg_dt, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubWordDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluSub, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubWordAsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluSub, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubWordAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubWordAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubWordPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubWordDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubWordDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubWordAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubWordAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubWordDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubWordDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubWordImm16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluSub, reg_dt, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubLongDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluSub, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    runALU(AluSubc, high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubLongAsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluSub, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    runALU(AluSubc, high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubLongAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluSubc, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubLongAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluSubc, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubLongPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluSubc, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubLongDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluSubc, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubLongDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluSubc, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubLongAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluSubc, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubLongAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluSubc, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubLongDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluSubc, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubLongDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluSubc, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubLongImm32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluSub, reg_dt, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    runALU(AluSubc, high16(reg_dt), high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaWordDsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c9 rorm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluSub, reg_da[ry_index], reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluSubc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaWordAsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c9 rorm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluSub, reg_da[ry_index], reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluSubc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaWordAisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluSubc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaWordAipsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluSubc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaWordPaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluSubc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaWordDasAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluSubc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaWordDaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluSubc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 6):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaWordAdr16AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluSubc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaWordAdr32AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluSubc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaWordDpcAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluSubc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaWordDpciAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluSubc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 6):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaWordImm16AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c9 rorm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluSub, reg_dt, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluSubc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubxByteDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluSubxByte, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrXNZVCU);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubxBytePaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 10f asxw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 131 asxw2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 132 asxw3
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 4a asxw4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_at = reg_au;
	    reg_da[rx_index] = reg_au;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    reg_dbin = reg_edb;
	    // 65 asxw5
	    reg_aob = reg_pc;
	    reg_au = reg_at;
	    runALU(AluSubxByte, reg_alub, reg_dbin);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubByteDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubByteDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubByteDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubByteDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubByteDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubByteDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubByteDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubxWordDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluSubx, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrXNZVCU);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubxWordPaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 10f asxw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 131 asxw2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 132 asxw3
	    reg_au = reg_da[rx_index] - 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 4a asxw4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_at = reg_au;
	    reg_da[rx_index] = reg_au;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 65 asxw5
	    reg_aob = reg_pc;
	    reg_au = reg_at;
	    runALU(AluSubx, reg_alub, reg_dbin);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubWordDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubWordDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubWordDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubWordDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubWordDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubWordDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubWordDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubxLongDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluSubx, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrXNZVCU);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    runALU(AluSubc, high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubxLongPaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 10b asxl1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 48 asxl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_au = reg_au - 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 139 asxl3
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 13a asxl4
	    reg_au = reg_da[rx_index] - 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 4c asxl5
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_au = reg_au - 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 47 asxl6
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSubx, reg_aluo, reg_dbin);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 61 asxl7
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = ext32(reg_dbin);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    // 62 asxl8
	    reg_aob = reg_pc;
	    reg_au = reg_at;
	    runALU(AluSubc, reg_alub, reg_dbin);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 9):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubLongDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubLongDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubLongDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubLongDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubLongDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubLongDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubLongDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaLongDsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluSub, reg_da[ry_index], reg_da[rx_index]);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    runALU(AluSubc, high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaLongAsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluSub, reg_da[ry_index], reg_da[rx_index]);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    runALU(AluSubc, high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaLongAisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluSubc, reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaLongAipsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluSubc, reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaLongPaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluSubc, reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaLongDasAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluSubc, reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaLongDaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluSubc, reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaLongAdr16AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluSubc, reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaLongAdr32AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluSubc, reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaLongDpcAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluSubc, reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaLongDpciAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluSubc, reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaLongImm32AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluSub, reg_dt, reg_da[rx_index]);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    runALU(AluSubc, high16(reg_dt), high16(reg_da[rx_index]));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpByteDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1d1 cprw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAndByte, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpByteAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAndByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpByteAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAndByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpBytePaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAndByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpByteDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAndByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpByteDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAndByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpByteAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAndByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpByteAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAndByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpByteDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAndByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpByteDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAndByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpByteImm8DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1d1 cprw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluAndByte, reg_dt, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpWordDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1d1 cprw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAnd, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpWordAsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1d1 cprw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAnd, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpWordAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpWordAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpWordPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpWordDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpWordDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpWordAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpWordAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpWordDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpWordDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpWordImm16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1d1 cprw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluAnd, reg_dt, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpLongDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1d5 cprl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAnd, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 173 cprl2
	    runALU(AluAnd, high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpLongAsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1d5 cprl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAnd, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 173 cprl2
	    runALU(AluAnd, high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpLongAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 172 cpml2
	    runALU(AluAnd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpLongAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 172 cpml2
	    runALU(AluAnd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpLongPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 172 cpml2
	    runALU(AluAnd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpLongDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 172 cpml2
	    runALU(AluAnd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpLongDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 172 cpml2
	    runALU(AluAnd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpLongAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 172 cpml2
	    runALU(AluAnd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpLongAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 172 cpml2
	    runALU(AluAnd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpLongDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 172 cpml2
	    runALU(AluAnd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpLongDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 172 cpml2
	    runALU(AluAnd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpLongImm32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1d5 cprl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluAnd, reg_dt, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 173 cprl2
	    runALU(AluAnd, high16(reg_dt), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaWordDsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1d9 cprm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluSub, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 174 cprm2
	    runALU(AluAdd, high16(reg_at), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaWordAsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1d9 cprm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluSub, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 174 cprm2
	    runALU(AluAdd, high16(reg_at), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaWordAisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cf cpmm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 174 cprm2
	    runALU(AluAdd, high16(reg_at), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaWordAipsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cf cpmm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 174 cprm2
	    runALU(AluAdd, high16(reg_at), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaWordPaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cf cpmm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 174 cprm2
	    runALU(AluAdd, high16(reg_at), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaWordDasAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cf cpmm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 174 cprm2
	    runALU(AluAdd, high16(reg_at), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaWordDaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cf cpmm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 174 cprm2
	    runALU(AluAdd, high16(reg_at), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaWordAdr16AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cf cpmm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 174 cprm2
	    runALU(AluAdd, high16(reg_at), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaWordAdr32AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cf cpmm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 174 cprm2
	    runALU(AluAdd, high16(reg_at), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaWordDpcAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cf cpmm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 174 cprm2
	    runALU(AluAdd, high16(reg_at), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaWordDpciAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cf cpmm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 174 cprm2
	    runALU(AluAdd, high16(reg_at), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaWordImm16AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1d9 cprm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluSub, reg_dt, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 174 cprm2
	    runALU(AluAdd, high16(reg_at), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorByteDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 100 roaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluAbcdByte, reg_da[rx_index], reg_da[ry_index]);
	    updateCCR(CcrXNZVCU);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpmByteAipsAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6b cmmw1
	    reg_aob = reg_da[ry_index];
	    reg_pc = reg_au;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 86 cmmw2
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 122 cmmw3
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 170 cmmw4
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAbcdByte, reg_aluo, reg_dbin);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorByteDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorByteDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorByteDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorByteDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorByteDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorByteDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorByteDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorWordDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 100 roaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluAbcd, reg_da[rx_index], reg_da[ry_index]);
	    updateCCR(CcrXNZVCU);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpmWordAipsAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6b cmmw1
	    reg_aob = reg_da[ry_index];
	    reg_pc = reg_au;
	    reg_au = reg_da[ry_index] + 2;
	    // 86 cmmw2
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 122 cmmw3
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 170 cmmw4
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAbcd, reg_aluo, reg_dbin);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorWordDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorWordDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorWordDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorWordDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorWordDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorWordDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorWordDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorLongDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 10c roal1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluAbcd, reg_da[rx_index], reg_da[ry_index]);
	    updateCCR(CcrXNZVCU);
	    // 259 roal2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25a roal3
	    runALU(AluAdd, high16(reg_da[rx_index]), high16(reg_da[ry_index]));
	    updateCCR(CcrXNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpmLongAipsAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6f cmml1
	    reg_aob = reg_da[ry_index];
	    reg_pc = reg_au;
	    reg_au = reg_da[ry_index] + 2;
	    // 8e cmml2
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 154 cmml3
	    reg_aob = reg_at;
	    reg_alub = reg_dbin;
	    reg_da[ry_index] = reg_au;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 12e cmml4
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 155 cmml5
	    reg_aob = reg_au;
	    reg_alue = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 156 cmml6
	    reg_aob = reg_pc;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAbcd, reg_aluo, reg_dbin);
	    updateCCR(CcrXNZVCU);
	    // 157 cmml7
	    reg_ird = reg_ir;
	    setIntState();
	    runALU(AluAdd, reg_alub, reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorLongDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorLongDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorLongDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorLongDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorLongDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorLongDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorLongDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaLongDsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1d5 cprl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluSub, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 173 cprl2
	    runALU(AluAdd, high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaLongAsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1d5 cprl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluSub, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 173 cprl2
	    runALU(AluAdd, high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaLongAisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 172 cpml2
	    runALU(AluAdd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaLongAipsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 172 cpml2
	    runALU(AluAdd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaLongPaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 172 cpml2
	    runALU(AluAdd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaLongDasAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 172 cpml2
	    runALU(AluAdd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaLongDaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 172 cpml2
	    runALU(AluAdd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaLongAdr16AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 172 cpml2
	    runALU(AluAdd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaLongAdr32AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 172 cpml2
	    runALU(AluAdd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaLongDpcAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 172 cpml2
	    runALU(AluAdd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaLongDpciAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 172 cpml2
	    runALU(AluAdd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaLongImm32AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1d5 cprl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluSub, reg_dt, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 173 cprl2
	    runALU(AluAdd, high16(reg_dt), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndByteDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAndByte, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndByteAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAndByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndByteAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAndByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndBytePaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAndByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndByteDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAndByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndByteDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAndByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndByteAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAndByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndByteAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAndByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndByteDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAndByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndByteDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAndByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndByteImm8DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluAndByte, reg_dt, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndWordDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAnd, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndWordAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndWordAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndWordPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndWordDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndWordDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndWordAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndWordAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndWordDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndWordDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndWordImm16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluAnd, reg_dt, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndLongDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAnd, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    runALU(AluAnd, high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndLongAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAnd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndLongAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAnd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndLongPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAnd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndLongDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAnd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndLongDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAnd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndLongAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAnd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndLongAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAnd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndLongDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAnd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndLongDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAnd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndLongImm32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluAnd, reg_dt, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    runALU(AluAnd, high16(reg_dt), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMuluWordDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 15b mulr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_da[ry_index];
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // mulm4
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : testbit(reg_alue, 1) ? 1 : 2;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMu, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond3(1, 2, 3);
	}
	break;
	case getCycle(2, 0):
	{
	    // mulm3
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    jump(1);
	}
	break;
	case getCycle(3, 0):
	{
	    // mulm6
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMuluWordAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // mulm4
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : testbit(reg_alue, 1) ? 1 : 2;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMu, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond3(1, 2, 3);
	}
	break;
	case getCycle(2, 0):
	{
	    // mulm3
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    jump(1);
	}
	break;
	case getCycle(3, 0):
	{
	    // mulm6
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMuluWordAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // mulm4
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : testbit(reg_alue, 1) ? 1 : 2;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMu, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond3(1, 2, 3);
	}
	break;
	case getCycle(2, 0):
	{
	    // mulm3
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    jump(1);
	}
	break;
	case getCycle(3, 0):
	{
	    // mulm6
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMuluWordPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // mulm4
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : testbit(reg_alue, 1) ? 1 : 2;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMu, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond3(1, 2, 3);
	}
	break;
	case getCycle(2, 0):
	{
	    // mulm3
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    jump(1);
	}
	break;
	case getCycle(3, 0):
	{
	    // mulm6
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMuluWordDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // mulm4
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : testbit(reg_alue, 1) ? 1 : 2;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMu, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond3(1, 2, 3);
	}
	break;
	case getCycle(2, 0):
	{
	    // mulm3
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    jump(1);
	}
	break;
	case getCycle(3, 0):
	{
	    // mulm6
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMuluWordDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(5, 4);
	}
	break;
	case getCycle(4, 0):
	{
	    // mulm4
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : testbit(reg_alue, 1) ? 1 : 2;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMu, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(4, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(4, 2):
	{
	    jumpCond3(4, 5, 6);
	}
	break;
	case getCycle(5, 0):
	{
	    // mulm3
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(5, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(5, 2):
	{
	    jump(4);
	}
	break;
	case getCycle(6, 0):
	{
	    // mulm6
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(6, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(6, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMuluWordAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // mulm4
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : testbit(reg_alue, 1) ? 1 : 2;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMu, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond3(1, 2, 3);
	}
	break;
	case getCycle(2, 0):
	{
	    // mulm3
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    jump(1);
	}
	break;
	case getCycle(3, 0):
	{
	    // mulm6
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMuluWordAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // mulm4
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : testbit(reg_alue, 1) ? 1 : 2;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMu, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond3(1, 2, 3);
	}
	break;
	case getCycle(2, 0):
	{
	    // mulm3
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    jump(1);
	}
	break;
	case getCycle(3, 0):
	{
	    // mulm6
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMuluWordDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // mulm4
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : testbit(reg_alue, 1) ? 1 : 2;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMu, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond3(1, 2, 3);
	}
	break;
	case getCycle(2, 0):
	{
	    // mulm3
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    jump(1);
	}
	break;
	case getCycle(3, 0):
	{
	    // mulm6
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMuluWordDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(5, 4);
	}
	break;
	case getCycle(4, 0):
	{
	    // mulm4
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : testbit(reg_alue, 1) ? 1 : 2;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMu, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(4, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(4, 2):
	{
	    jumpCond3(4, 5, 6);
	}
	break;
	case getCycle(5, 0):
	{
	    // mulm3
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(5, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(5, 2):
	{
	    jump(4);
	}
	break;
	case getCycle(6, 0):
	{
	    // mulm6
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(6, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(6, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMuluWordImm16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15b mulr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dt;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // mulm4
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : testbit(reg_alue, 1) ? 1 : 2;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMu, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond3(1, 2, 3);
	}
	break;
	case getCycle(2, 0):
	{
	    // mulm3
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    jump(1);
	}
	break;
	case getCycle(3, 0):
	{
	    // mulm6
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAbcdDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1cd rbrb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAbcdByte, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrXNZVCU);
	    // 11b rbrb2
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 238 rbrb3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAbcdPaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 107 asbb1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 135 asbb2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 136 asbb3
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 4e asbb4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_at = reg_au;
	    reg_da[rx_index] = reg_au;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    reg_dbin = reg_edb;
	    // 40 asbb5
	    reg_aob = reg_pc;
	    runALU(AluAbcdByte, reg_alub, reg_dbin);
	    updateCCR(CcrXNZVCU);
	    // 113 asbb6
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndByteDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndByteDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndByteDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndByteDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndByteDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndByteDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndByteDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kExgDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e3 exge1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[rx_index];
	    reg_au = reg_da[ry_index];
	    // 231 exge2
	    reg_da[rx_index] = reg_au;
	    reg_da[ry_index] = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kExgAdAsProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e3 exge1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[rx_index];
	    reg_au = reg_da[ry_index];
	    // 231 exge2
	    reg_da[rx_index] = reg_au;
	    reg_da[ry_index] = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndWordDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndWordDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndWordDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndWordDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndWordDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndWordDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndWordDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kExgDdAsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 3e3 exge1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[rx_index];
	    reg_au = reg_da[ry_index];
	    // 231 exge2
	    reg_da[rx_index] = reg_au;
	    reg_da[ry_index] = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndLongDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndLongDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndLongDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndLongDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndLongDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndLongDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndLongDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMulsWordDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 15b mulr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_da[ry_index];
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // mulm4
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : ((reg_alue & 0x3) == 1) ? 1 : ((reg_alue & 0x3) == 2) ? 2 : 3;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMs, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond4(1, 2, 4, 3);
	}
	break;
	case getCycle(2, 0):
	{
	    // mulm5
	    // a0 mulm5
	    runALU(AluSub, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    jump(1);
	}
	break;
	case getCycle(3, 0):
	{
	    // mulm6
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    nextTrace();
	}
	break;
	case getCycle(4, 0):
	{
	    // mulm3
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(4, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(4, 2):
	{
	    jump(1);
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMulsWordAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // mulm4
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : ((reg_alue & 0x3) == 1) ? 1 : ((reg_alue & 0x3) == 2) ? 2 : 3;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMs, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond4(1, 2, 4, 3);
	}
	break;
	case getCycle(2, 0):
	{
	    // mulm5
	    // a0 mulm5
	    runALU(AluSub, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    jump(1);
	}
	break;
	case getCycle(3, 0):
	{
	    // mulm6
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    nextTrace();
	}
	break;
	case getCycle(4, 0):
	{
	    // mulm3
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(4, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(4, 2):
	{
	    jump(1);
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMulsWordAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // mulm4
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : ((reg_alue & 0x3) == 1) ? 1 : ((reg_alue & 0x3) == 2) ? 2 : 3;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMs, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond4(1, 2, 4, 3);
	}
	break;
	case getCycle(2, 0):
	{
	    // mulm5
	    // a0 mulm5
	    runALU(AluSub, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    jump(1);
	}
	break;
	case getCycle(3, 0):
	{
	    // mulm6
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    nextTrace();
	}
	break;
	case getCycle(4, 0):
	{
	    // mulm3
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(4, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(4, 2):
	{
	    jump(1);
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMulsWordPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // mulm4
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : ((reg_alue & 0x3) == 1) ? 1 : ((reg_alue & 0x3) == 2) ? 2 : 3;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMs, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond4(1, 2, 4, 3);
	}
	break;
	case getCycle(2, 0):
	{
	    // mulm5
	    // a0 mulm5
	    runALU(AluSub, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    jump(1);
	}
	break;
	case getCycle(3, 0):
	{
	    // mulm6
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    nextTrace();
	}
	break;
	case getCycle(4, 0):
	{
	    // mulm3
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(4, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(4, 2):
	{
	    jump(1);
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMulsWordDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // mulm4
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : ((reg_alue & 0x3) == 1) ? 1 : ((reg_alue & 0x3) == 2) ? 2 : 3;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMs, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond4(1, 2, 4, 3);
	}
	break;
	case getCycle(2, 0):
	{
	    // mulm5
	    // a0 mulm5
	    runALU(AluSub, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    jump(1);
	}
	break;
	case getCycle(3, 0):
	{
	    // mulm6
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    nextTrace();
	}
	break;
	case getCycle(4, 0):
	{
	    // mulm3
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(4, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(4, 2):
	{
	    jump(1);
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMulsWordDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(5, 4);
	}
	break;
	case getCycle(4, 0):
	{
	    // mulm4
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : ((reg_alue & 0x3) == 1) ? 1 : ((reg_alue & 0x3) == 2) ? 2 : 3;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMs, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(4, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(4, 2):
	{
	    jumpCond4(4, 5, 7, 6);
	}
	break;
	case getCycle(5, 0):
	{
	    // mulm5
	    // a0 mulm5
	    runALU(AluSub, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(5, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(5, 2):
	{
	    jump(4);
	}
	break;
	case getCycle(6, 0):
	{
	    // mulm6
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(6, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(6, 2):
	{
	    nextTrace();
	}
	break;
	case getCycle(7, 0):
	{
	    // mulm3
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(7, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(7, 2):
	{
	    jump(4);
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMulsWordAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // mulm4
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : ((reg_alue & 0x3) == 1) ? 1 : ((reg_alue & 0x3) == 2) ? 2 : 3;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMs, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond4(1, 2, 4, 3);
	}
	break;
	case getCycle(2, 0):
	{
	    // mulm5
	    // a0 mulm5
	    runALU(AluSub, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    jump(1);
	}
	break;
	case getCycle(3, 0):
	{
	    // mulm6
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    nextTrace();
	}
	break;
	case getCycle(4, 0):
	{
	    // mulm3
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(4, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(4, 2):
	{
	    jump(1);
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMulsWordAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // mulm4
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : ((reg_alue & 0x3) == 1) ? 1 : ((reg_alue & 0x3) == 2) ? 2 : 3;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMs, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond4(1, 2, 4, 3);
	}
	break;
	case getCycle(2, 0):
	{
	    // mulm5
	    // a0 mulm5
	    runALU(AluSub, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    jump(1);
	}
	break;
	case getCycle(3, 0):
	{
	    // mulm6
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    nextTrace();
	}
	break;
	case getCycle(4, 0):
	{
	    // mulm3
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(4, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(4, 2):
	{
	    jump(1);
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMulsWordDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // mulm4
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : ((reg_alue & 0x3) == 1) ? 1 : ((reg_alue & 0x3) == 2) ? 2 : 3;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMs, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond4(1, 2, 4, 3);
	}
	break;
	case getCycle(2, 0):
	{
	    // mulm5
	    // a0 mulm5
	    runALU(AluSub, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    jump(1);
	}
	break;
	case getCycle(3, 0):
	{
	    // mulm6
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    nextTrace();
	}
	break;
	case getCycle(4, 0):
	{
	    // mulm3
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(4, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(4, 2):
	{
	    jump(1);
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMulsWordDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(5, 4);
	}
	break;
	case getCycle(4, 0):
	{
	    // mulm4
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : ((reg_alue & 0x3) == 1) ? 1 : ((reg_alue & 0x3) == 2) ? 2 : 3;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMs, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(4, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(4, 2):
	{
	    jumpCond4(4, 5, 7, 6);
	}
	break;
	case getCycle(5, 0):
	{
	    // mulm5
	    // a0 mulm5
	    runALU(AluSub, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(5, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(5, 2):
	{
	    jump(4);
	}
	break;
	case getCycle(6, 0):
	{
	    // mulm6
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(6, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(6, 2):
	{
	    nextTrace();
	}
	break;
	case getCycle(7, 0):
	{
	    // mulm3
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(7, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(7, 2):
	{
	    jump(4);
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMulsWordImm16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15b mulr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dt;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // mulm4
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : ((reg_alue & 0x3) == 1) ? 1 : ((reg_alue & 0x3) == 2) ? 2 : 3;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMs, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond4(1, 2, 4, 3);
	}
	break;
	case getCycle(2, 0):
	{
	    // mulm5
	    // a0 mulm5
	    runALU(AluSub, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    jump(1);
	}
	break;
	case getCycle(3, 0):
	{
	    // mulm6
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    nextTrace();
	}
	break;
	case getCycle(4, 0):
	{
	    // mulm3
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(4, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(4, 2):
	{
	    jump(1);
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddByteDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAddByte, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddByteAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAddByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddByteAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAddByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddBytePaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAddByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddByteDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAddByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddByteDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAddByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddByteAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAddByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddByteAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAddByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddByteDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAddByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddByteDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAddByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddByteImm8DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluAddByte, reg_dt, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddWordDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAdd, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddWordAsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAdd, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddWordAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddWordAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddWordPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddWordDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddWordDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddWordAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddWordAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddWordDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddWordDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddWordImm16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluAdd, reg_dt, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddLongDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAdd, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    runALU(AluAddc, high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddLongAsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAdd, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    runALU(AluAddc, high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddLongAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAddc, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddLongAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAddc, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddLongPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAddc, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddLongDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAddc, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddLongDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAddc, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddLongAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAddc, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddLongAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAddc, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddLongDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAddc, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddLongDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAddc, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddLongImm32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluAdd, reg_dt, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    runALU(AluAddc, high16(reg_dt), high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaWordDsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c9 rorm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAdd, reg_da[ry_index], reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluAddc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaWordAsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c9 rorm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAdd, reg_da[ry_index], reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluAddc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaWordAisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluAddc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaWordAipsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluAddc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaWordPaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluAddc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaWordDasAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluAddc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaWordDaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluAddc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 6):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaWordAdr16AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluAddc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaWordAdr32AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluAddc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaWordDpcAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluAddc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaWordDpciAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluAddc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 6):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaWordImm16AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c9 rorm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluAdd, reg_dt, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluAddc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddxByteDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAddxByte, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrXNZVCU);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddxBytePaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 10f asxw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 131 asxw2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 132 asxw3
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 4a asxw4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_at = reg_au;
	    reg_da[rx_index] = reg_au;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    reg_dbin = reg_edb;
	    // 65 asxw5
	    reg_aob = reg_pc;
	    reg_au = reg_at;
	    runALU(AluAddxByte, reg_alub, reg_dbin);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddByteDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddByteDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddByteDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddByteDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddByteDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddByteDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddByteDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddxWordDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAddx, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrXNZVCU);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddxWordPaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 10f asxw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 131 asxw2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 132 asxw3
	    reg_au = reg_da[rx_index] - 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 4a asxw4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_at = reg_au;
	    reg_da[rx_index] = reg_au;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 65 asxw5
	    reg_aob = reg_pc;
	    reg_au = reg_at;
	    runALU(AluAddx, reg_alub, reg_dbin);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddWordDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddWordDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddWordDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddWordDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddWordDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddWordDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddWordDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddxLongDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAddx, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrXNZVCU);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    runALU(AluAddx, high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddxLongPaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 10b asxl1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 48 asxl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_au = reg_au - 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 139 asxl3
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 13a asxl4
	    reg_au = reg_da[rx_index] - 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 4c asxl5
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_au = reg_au - 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 47 asxl6
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAddx, reg_aluo, reg_dbin);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 61 asxl7
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = ext32(reg_dbin);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    // 62 asxl8
	    reg_aob = reg_pc;
	    reg_au = reg_at;
	    runALU(AluAddx, reg_alub, reg_dbin);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 8):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 9):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddLongDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddLongDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddLongDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddLongDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddLongDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddLongDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddLongDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaLongDsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAdd, reg_da[ry_index], reg_da[rx_index]);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    runALU(AluAddc, high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaLongAsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAdd, reg_da[ry_index], reg_da[rx_index]);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    runALU(AluAddc, high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaLongAisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAddc, reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaLongAipsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAddc, reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaLongPaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAddc, reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaLongDasAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAddc, reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaLongDaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAddc, reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaLongAdr16AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAddc, reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaLongAdr32AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAddc, reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaLongDpcAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAddc, reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaLongDpciAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixw2
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixw4
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsl2
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAddc, reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 5):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaLongImm32AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluAdd, reg_dt, reg_da[rx_index]);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    runALU(AluAddc, high16(reg_dt), high16(reg_da[rx_index]));
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 6):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 7):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAsrByteImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAndByte, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrw3
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluAsrByte, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // nbcr3
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLsrByteImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAndByte, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrw3
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluLsrByte, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // nbcr3
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxrByteImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAndBytex, high16(reg_da[ry_index]), 0xFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndBytex, reg_da[ry_index], 0xFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrw3
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // nbcr3
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRorByteImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAndByte, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrw3
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRorByte, reg_aluo);
	    updateCCR(CcrNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // nbcr3
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAsrByteDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAndByte, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrw3
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluAsrByte, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // nbcr3
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLsrByteDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAndByte, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrw3
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluLsrByte, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // nbcr3
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxrByteDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAndBytex, high16(reg_da[ry_index]), 0xFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndBytex, reg_da[ry_index], 0xFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrw3
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // nbcr3
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRorByteDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAndByte, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrw3
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRorByte, reg_aluo);
	    updateCCR(CcrNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // nbcr3
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAsrWordImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrw3
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluAsr, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // nbcr3
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLsrWordImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrw3
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluLsr, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // nbcr3
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxrWordImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAndx, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndx, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrw3
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // nbcr3
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRorWordImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrw3
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRor, reg_aluo);
	    updateCCR(CcrNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // nbcr3
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAsrWordDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrw3
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluAsr, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // nbcr3
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLsrWordDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrw3
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluLsr, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // nbcr3
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxrWordDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAndx, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndx, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrw3
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // nbcr3
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRorWordDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrw3
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRor, reg_aluo);
	    updateCCR(CcrNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // nbcr3
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAsrLongImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 385 srrl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrl3
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluAsrLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // srrl4
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 4):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLsrLongImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 385 srrl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrl3
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluLsrLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // srrl4
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 4):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxrLongImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 385 srrl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAndx, high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndx, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrl3
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // srrl4
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    runALU(AluAndx, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 4):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRorLongImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 385 srrl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrl3
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRorLong, reg_aluo);
	    updateCCR(CcrNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // srrl4
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 4):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAsrLongDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 386 sril1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrl3
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluAsrLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // srrl4
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 4):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLsrLongDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 386 sril1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrl3
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluLsrLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // srrl4
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 4):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxrLongDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 386 sril1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAndx, high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndx, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrl3
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // srrl4
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    runALU(AluAndx, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 4):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRorLongDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 386 sril1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrl3
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRorLong, reg_aluo);
	    updateCCR(CcrNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // srrl4
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 4):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAsrAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluAsr, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAsrAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluAsr, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAsrPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluAsr, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAsrDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluAsr, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAsrDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluAsr, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAsrAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluAsr, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAsrAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluAsr, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAslByteImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAndByte, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrw3
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluAslByte, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // nbcr3
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLslByteImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAndByte, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrw3
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluLslByte, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // nbcr3
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxlByteImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAndBytex, high16(reg_da[ry_index]), 0xFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndBytex, reg_da[ry_index], 0xFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrw3
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRoxlByte, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // nbcr3
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRolByteImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAndByte, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrw3
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRolByte, reg_aluo);
	    updateCCR(CcrNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // nbcr3
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAslByteDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAndByte, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrw3
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluAslByte, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // nbcr3
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLslByteDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAndByte, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrw3
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluLslByte, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // nbcr3
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxlByteDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAndBytex, high16(reg_da[ry_index]), 0xFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndBytex, reg_da[ry_index], 0xFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrw3
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRoxlByte, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // nbcr3
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRolByteDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAndByte, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrw3
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRolByte, reg_aluo);
	    updateCCR(CcrNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // nbcr3
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAslWordImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrw3
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluAsl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // nbcr3
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLslWordImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrw3
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluLsl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // nbcr3
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxlWordImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAndx, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndx, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrw3
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRoxl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // nbcr3
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRolWordImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrw3
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRol, reg_aluo);
	    updateCCR(CcrNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // nbcr3
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAslWordDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrw3
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluAsl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // nbcr3
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLslWordDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrw3
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluLsl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // nbcr3
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxlWordDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAndx, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndx, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrw3
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRoxl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // nbcr3
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRolWordDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrw3
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRol, reg_aluo);
	    updateCCR(CcrNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // nbcr3
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAslLongImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 385 srrl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrl3
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluAslLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // srrl4
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 4):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLslLongImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 385 srrl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrl3
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluLslLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // srrl4
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    runALU(AluAnd, reg_aluo, reg_alue);
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 4):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxlLongImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 385 srrl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAndx, high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndx, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrl3
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRoxlLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // srrl4
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    runALU(AluAndx, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 4):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRolLongImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 385 srrl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrl3
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRolLong, reg_aluo);
	    updateCCR(CcrNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // srrl4
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 4):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAslLongDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 386 sril1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrl3
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluAslLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // srrl4
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 4):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLslLongDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 386 sril1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrl3
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluLslLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // srrl4
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    runALU(AluAnd, reg_aluo, reg_alue);
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 4):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxlLongDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 386 sril1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAndx, high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndx, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrl3
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRoxlLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // srrl4
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    runALU(AluAndx, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 4):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRolLongDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 386 sril1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // srrl3
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRolLong, reg_aluo);
	    updateCCR(CcrNZVC);
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 2):
	{
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(2, 0):
	{
	    // srrl4
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 2):
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFTUConst();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 3):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 4):
	{
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAslAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluAsl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAslAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluAsl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAslPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluAsl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAslDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluAsl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAslDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluAsl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAslAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluAsl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAslAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluAsl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLsrAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluLsr, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLsrAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluLsr, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLsrPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluLsr, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLsrDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluLsr, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLsrDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluLsr, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLsrAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluLsr, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLsrAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluLsr, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLslAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluLsl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLslAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluLsl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLslPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluLsl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLslDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluLsl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLslDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluLsl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLslAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluLsl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLslAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluLsl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxrAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRoxrLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxrAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndx, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRoxrLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxrPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndx, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRoxrLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxrDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRoxrLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxrDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRoxrLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxrAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRoxrLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxrAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRoxrLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxlAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRoxl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxlAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndx, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRoxl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxlPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndx, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRoxl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxlDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRoxl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxlDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRoxl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxlAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRoxl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxlAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRoxl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRorAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRor, reg_aluo);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRorAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRor, reg_aluo);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRorPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRor, reg_aluo);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRorDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRor, reg_aluo);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRorDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRor, reg_aluo);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRorAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRor, reg_aluo);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRorAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRor, reg_aluo);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRolAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRol, reg_aluo);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRolAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRol, reg_aluo);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRolPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRol, reg_aluo);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRolDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRol, reg_aluo);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRolDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    jumpCond2(2, 1);
	}
	break;
	case getCycle(1, 0):
	{
	    // aixl2
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(1, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(2, 0):
	{
	    // aixl5
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(2, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    jump(3);
	}
	break;
	case getCycle(3, 0):
	{
	    // adsw2
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRol, reg_aluo);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(3, 3):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRolAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRol, reg_aluo);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRolAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch ((inst_cycle << 6) | inst_state)
    {
	case getCycle(0, 0):
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 1):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 2):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 3):
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRol, reg_aluo);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 4):
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle += 1;
	}
	break;
	case getCycle(0, 5):
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

