void m68kResetDpProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2 rstp3
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 296 rstp4
	    reg_ird = reg_ir;
	    setIntState();
	    setFTUConst();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setTrace();
	    // 27e rstp5
	    trapExcept(0x00);
	    reg_ftu = 0x0000;
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 27f rstp6
	    initST();
	    reg_sr |= 0x700;
	    updateInterrupts();
	    reg_au = ext32(reg_ftu);
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    // 2fb rstp7
	    reg_aob = reg_au;
	    setReg16High(reg_da[16], reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, true);
	    setCritical();
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2ff rstp8
	    reg_aob = reg_au;
	    setReg16High(reg_da[16], reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, true);
	    setCritical();
	    readWord();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 300 rstp9
	    reg_aob = reg_au;
	    initST();
	    setReg16Low(reg_da[16], reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, true);
	    setCritical();
	    readWord();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    clearTrace();
	    // 11e rstpa
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, true);
	    setCritical();
	    readWord();
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, true);
	    setCritical();
	    readWord();
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 14;
	}
	break;
	case 14:
	{
	    inst_cycle = 15;
	}
	break;
	case 15:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, true);
	    readWord();
	    inst_cycle = 16;
	}
	break;
	case 16:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kDoubleFaultDpProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1 halt1
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kInterruptDpProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c4 itlx1
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 234 itlx2
	    initST();
	    reg_alub = reg_ftu;
	    reg_pc = reg_au;
	    reg_sr = ((reg_sr & ~0x700) | ((next_state >> 16) & 0x700));
	    updateInterrupts();
	    runALU(AluAnd, reg_au, 0xFFFF);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 235 itlx3
	    reg_ftu = (0xfff0 | ((next_state >> 23) & 0xE));
	    reg_au = reg_da[16] - 2;
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // eb itlx4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, false, true);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 236 itlx5
	    reg_aob = reg_at;
	    setFC(true, true, true, true);
	    startIRQVectorLookup();
	    readWordCPU();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    endIRQVectorLookup();
	    checkExcept();
	    reg_irc = reg_edb;
	    // 118 itlx6
	    reg_ir = reg_irc;
	    updateIPL();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    // 292 itlx7
	    reg_ird = reg_ir;
	    setIntState();
	    setFTUConst();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    setTrace();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(reg_int_vec);
	    reg_da[16] = reg_au;
	    reg_ftu = reg_int_vec;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, true);
	    writeWord();
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    checkExcept();
	    // ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, false, true);
	    writeWord();
	    inst_cycle = 14;
	}
	break;
	case 14:
	{
	    checkExcept();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, true);
	    readWord();
	    inst_cycle = 15;
	}
	break;
	case 15:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, true);
	    readWord();
	    inst_cycle = 16;
	}
	break;
	case 16:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, true);
	    readWord();
	    inst_cycle = 17;
	}
	break;
	case 17:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 18;
	}
	break;
	case 18:
	{
	    inst_cycle = 19;
	}
	break;
	case 19:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, true);
	    readWord();
	    inst_cycle = 20;
	}
	break;
	case 20:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriByteImm8DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 100 roaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluOrByte, reg_dt, reg_da[ry_index]);
	    updateCCR(CcrNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriByteImm8AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriByteImm8AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriByteImm8PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriByteImm8DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriByteImm8DaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriByteImm8Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriByteImm8Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriImm8CcrProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1cc stiw1
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 307 stiw2
	    runALU(AluOrByte, reg_ftu, reg_dt);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 320 stiw3
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_aluo;
	    reg_au = reg_au + 2;
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriWordImm16DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 100 roaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluOr, reg_dt, reg_da[ry_index]);
	    updateCCR(CcrNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriWordImm16AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriWordImm16AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluOr, reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriWordImm16PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - 2;
	    runALU(AluOr, reg_dt, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriWordImm16DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriWordImm16DaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriWordImm16Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluOr, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriWordImm16Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluOr, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriI16uSrProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	if (!testbit(reg_sr, 13))
	{
	    setPriv();
	    return;
	}
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1cc stiw1
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 307 stiw2
	    runALU(AluOr, reg_ftu, reg_dt);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 320 stiw3
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_aluo;
	    reg_au = reg_au + 2;
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
updateSupervisor();
updateInterrupts();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriLongImm32DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 10c roal1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluOr, reg_dt, reg_da[ry_index]);
	    updateCCR(CcrNZVC);
	    // 259 roal2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25a roal3
	    runALU(AluOr, high16(reg_dt), high16(reg_da[ry_index]));
	    updateCCR(CcrNZVCU);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriLongImm32AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluOr, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriLongImm32AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluOr, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriLongImm32PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluOr, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriLongImm32DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluOr, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriLongImm32DaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluOr, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriLongImm32Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluOr, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluOr, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOriLongImm32Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluOr, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluOr, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBtstDdDsProgram()
{
    unknownInstr();
}

void m68kMovepWordDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1d2 mpiw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 29a mpiw2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    setReg8High(reg_dbin, reg_edb);
	    // 368 mpiw3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setReg8(reg_dbin, reg_edb);
	    // 36a mpiw4
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBtstDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBtstDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluXorByte, reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBtstDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluXorByte, reg_da[rx_index], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBtstDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBtstDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBtstDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluXorByte, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBtstDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluXorByte, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBtstDdDpcProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBtstDdDpciProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBtstDdImmProgram()
{
    unknownInstr();
}

void m68kBchgDdDsProgram()
{
    unknownInstr();
}

void m68kMovepLongDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1d6 mpil1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 29e mpil2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    setReg8High(reg_dbin, reg_edb);
	    // 34e mpil3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setReg8(reg_dbin, reg_edb);
	    // 34f mpil4
	    reg_aob = reg_au;
	    setReg16High(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setReg8High(reg_dbin, reg_edb);
	    // 368 mpiw3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setReg8(reg_dbin, reg_edb);
	    // 36a mpiw4
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBchgDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBchgDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluXorByte, reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBchgDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluXorByte, reg_da[rx_index], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBchgDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBchgDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBchgDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluXorByte, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBchgDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluXorByte, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBclrDdDsProgram()
{
    unknownInstr();
}

void m68kMovepWordDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1ca mpow1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 36d mpow2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExHigh(reg_dbout, reg_da[rx_index]);
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 36e mpow3
	    reg_aob = reg_au;
	    setReg8ExLow(reg_dbout, reg_da[rx_index]);
	    reg_au = reg_pc + 4;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBclrDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 69 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    runALU(AluOrByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 67 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBclrDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 69 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    runALU(AluOrByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 67 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBclrDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 69 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    runALU(AluOrByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 67 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBclrDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 69 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    runALU(AluOrByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 67 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBclrDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 69 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    runALU(AluOrByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 67 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBclrDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 69 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    runALU(AluOrByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 67 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBclrDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 69 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    runALU(AluOrByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 67 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBsetDdDsProgram()
{
    unknownInstr();
}

void m68kMovepLongDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1ce mpol1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 36b mpol2
	    reg_aob = reg_au;
	    setReg8ExHigh(reg_dbout, high16(reg_da[rx_index]));
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 36c mpol3
	    reg_aob = reg_au;
	    setReg8ExLow(reg_dbout, high16(reg_da[rx_index]));
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 36d mpow2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExHigh(reg_dbout, reg_da[rx_index]);
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 36e mpow3
	    reg_aob = reg_au;
	    setReg8ExLow(reg_dbout, reg_da[rx_index]);
	    reg_au = reg_pc + 4;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBsetDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluOrByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBsetDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluOrByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBsetDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluOrByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBsetDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluOrByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBsetDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluOrByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBsetDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluOrByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBsetDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluOrByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiByteImm8DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 100 roaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluAndByte, reg_dt, reg_da[ry_index]);
	    updateCCR(CcrNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiByteImm8AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiByteImm8AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiByteImm8PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dt, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiByteImm8DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiByteImm8DaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiByteImm8Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAndByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiByteImm8Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAndByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiImm8CcrProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1cc stiw1
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 307 stiw2
	    runALU(AluAndByte, reg_ftu, reg_dt);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 320 stiw3
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_aluo;
	    reg_au = reg_au + 2;
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiWordImm16DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 100 roaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluAnd, reg_dt, reg_da[ry_index]);
	    updateCCR(CcrNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiWordImm16AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiWordImm16AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiWordImm16PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - 2;
	    runALU(AluAnd, reg_dt, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiWordImm16DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiWordImm16DaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiWordImm16Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAnd, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiWordImm16Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAnd, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiI16uSrProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	if (!testbit(reg_sr, 13))
	{
	    setPriv();
	    return;
	}
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1cc stiw1
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 307 stiw2
	    runALU(AluAnd, reg_ftu, reg_dt);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 320 stiw3
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_aluo;
	    reg_au = reg_au + 2;
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
updateSupervisor();
updateInterrupts();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiLongImm32DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 10c roal1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluAnd, reg_dt, reg_da[ry_index]);
	    updateCCR(CcrNZVC);
	    // 259 roal2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25a roal3
	    runALU(AluAnd, high16(reg_dt), high16(reg_da[ry_index]));
	    updateCCR(CcrNZVCU);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiLongImm32AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiLongImm32AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiLongImm32PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiLongImm32DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiLongImm32DaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiLongImm32Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAnd, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndiLongImm32Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAnd, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiByteImm8DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 100 roaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluSubByte, reg_dt, reg_da[ry_index]);
	    updateCCR(CcrXNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiByteImm8AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiByteImm8AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiByteImm8PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiByteImm8DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiByteImm8DaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiByteImm8Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiByteImm8Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiWordImm16DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 100 roaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluSub, reg_dt, reg_da[ry_index]);
	    updateCCR(CcrXNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiWordImm16AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiWordImm16AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiWordImm16PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiWordImm16DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiWordImm16DaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiWordImm16Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiWordImm16Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiLongImm32DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 10c roal1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluSub, reg_dt, reg_da[ry_index]);
	    updateCCR(CcrXNZVC);
	    // 259 roal2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25a roal3
	    runALU(AluSubc, high16(reg_dt), high16(reg_da[ry_index]));
	    updateCCR(CcrXNZVCU);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiLongImm32AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiLongImm32AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiLongImm32PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiLongImm32DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiLongImm32DaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiLongImm32Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubiLongImm32Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiByteImm8DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 100 roaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluAddByte, reg_dt, reg_da[ry_index]);
	    updateCCR(CcrXNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiByteImm8AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiByteImm8AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiByteImm8PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiByteImm8DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiByteImm8DaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiByteImm8Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiByteImm8Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiWordImm16DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 100 roaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluAdd, reg_dt, reg_da[ry_index]);
	    updateCCR(CcrXNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiWordImm16AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiWordImm16AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiWordImm16PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiWordImm16DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiWordImm16DaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiWordImm16Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiWordImm16Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiLongImm32DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 10c roal1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluAdd, reg_dt, reg_da[ry_index]);
	    updateCCR(CcrXNZVC);
	    // 259 roal2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25a roal3
	    runALU(AluAddc, high16(reg_dt), high16(reg_da[ry_index]));
	    updateCCR(CcrXNZVCU);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiLongImm32AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiLongImm32AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiLongImm32PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiLongImm32DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiLongImm32DaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiLongImm32Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddiLongImm32Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_dt, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBtstImm8DsProgram()
{
    unknownInstr();
}

void m68kBtstImm8AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBtstImm8AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBtstImm8PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBtstImm8DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBtstImm8DaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBtstImm8Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBtstImm8Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBtstImm8DpcProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBtstImm8DpciProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBchgImm8DsProgram()
{
    unknownInstr();
}

void m68kBchgImm8AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBchgImm8AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBchgImm8PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBchgImm8DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBchgImm8DaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBchgImm8Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBchgImm8Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBclrImm8DsProgram()
{
    unknownInstr();
}

void m68kBclrImm8AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 69 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 67 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBclrImm8AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 69 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 67 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBclrImm8PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 69 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 67 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBclrImm8DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 69 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 67 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBclrImm8DaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    reg_dbin = reg_edb;
	    // 69 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 67 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBclrImm8Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 69 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 67 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBclrImm8Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 69 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 67 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBsetImm8DsProgram()
{
    unknownInstr();
}

void m68kBsetImm8AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBsetImm8AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBsetImm8PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBsetImm8DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBsetImm8DaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBsetImm8Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBsetImm8Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 81 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluXorByte, reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 82 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    runALU(AluAndByte, reg_alub, (1 << (reg_dcr & 0x7)));
	    updateCCR(CcrZ);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriByteImm8DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 100 roaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluXorByte, reg_dt, reg_da[ry_index]);
	    updateCCR(CcrNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriByteImm8AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriByteImm8AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriByteImm8PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriByteImm8DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriByteImm8DaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriByteImm8Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriByteImm8Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXorByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriImm8CcrProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1cc stiw1
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 307 stiw2
	    runALU(AluXorByte, reg_ftu, reg_dt);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 320 stiw3
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_aluo;
	    reg_au = reg_au + 2;
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriWordImm16DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 100 roaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluXor, reg_dt, reg_da[ry_index]);
	    updateCCR(CcrNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriWordImm16AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXor, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriWordImm16AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluXor, reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXor, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriWordImm16PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - 2;
	    runALU(AluXor, reg_dt, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXor, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriWordImm16DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXor, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriWordImm16DaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXor, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriWordImm16Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluXor, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXor, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriWordImm16Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluXor, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXor, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriI16uSrProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	if (!testbit(reg_sr, 13))
	{
	    setPriv();
	    return;
	}
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1cc stiw1
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 307 stiw2
	    runALU(AluXor, reg_ftu, reg_dt);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 320 stiw3
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_aluo;
	    reg_au = reg_au + 2;
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
updateSupervisor();
updateInterrupts();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriLongImm32DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 10c roal1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluXor, reg_dt, reg_da[ry_index]);
	    updateCCR(CcrNZVC);
	    // 259 roal2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25a roal3
	    runALU(AluXor, high16(reg_dt), high16(reg_da[ry_index]));
	    updateCCR(CcrNZVCU);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriLongImm32AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXor, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluXor, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriLongImm32AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXor, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluXor, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriLongImm32PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXor, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluXor, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriLongImm32DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXor, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluXor, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriLongImm32DaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXor, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluXor, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriLongImm32Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluXor, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXor, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluXor, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEoriLongImm32Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluXor, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluXor, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluXor, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiByteImm8DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 108 rcaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluSubByte, reg_dt, reg_da[ry_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiByteImm8AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 87 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSubByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiByteImm8AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 87 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSubByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiByteImm8PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 87 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSubByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiByteImm8DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 87 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSubByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiByteImm8DaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    reg_dbin = reg_edb;
	    // 87 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSubByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiByteImm8Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 87 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSubByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiByteImm8Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 87 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSubByte, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiWordImm16DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 108 rcaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluSub, reg_dt, reg_da[ry_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiWordImm16AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 87 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiWordImm16AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 87 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiWordImm16PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 87 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiWordImm16DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 87 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiWordImm16DaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 87 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiWordImm16Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 87 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiWordImm16Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 87 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiLongImm32DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 104 rcal1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluSub, reg_dt, reg_da[ry_index]);
	    updateCCR(CcrNZVC);
	    // 239 rcal2
	    runALU(AluSubc, high16(reg_dt), high16(reg_da[ry_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiLongImm32AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 8f cpdl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 171 cpdl2
	    reg_ird = reg_ir;
	    setIntState();
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiLongImm32AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 8f cpdl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 171 cpdl2
	    reg_ird = reg_ir;
	    setIntState();
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiLongImm32PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 8f cpdl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 171 cpdl2
	    reg_ird = reg_ir;
	    setIntState();
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiLongImm32DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 8f cpdl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 171 cpdl2
	    reg_ird = reg_ir;
	    setIntState();
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiLongImm32DaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 8f cpdl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 171 cpdl2
	    reg_ird = reg_ir;
	    setIntState();
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiLongImm32Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 8f cpdl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 171 cpdl2
	    reg_ird = reg_ir;
	    setIntState();
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpiLongImm32Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 8f cpdl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSub, reg_dt, reg_dbin);
	    updateCCR(CcrNZVC);
	    // 171 cpdl2
	    reg_ird = reg_ir;
	    setIntState();
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 121 rrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg8(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg8(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveBytePaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg8(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg8(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg8(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg8(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg8(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg8(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg8(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteImm8DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 121 rrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_dt;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDsAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2fa rmrw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_da[ry_index]);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAisAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAipsAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveBytePaisAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDasAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDaisAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAdr16AidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAdr32AidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDpcAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDpciAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteImm8AidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2fa rmrw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_dt);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDsAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2fe rmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_da[ry_index]);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAisAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAipsAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveBytePaisAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDasAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDaisAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAdr16AipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAdr32AipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDpcAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDpciAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteImm8AipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2fe rmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_dt);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDsPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2f8 rmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAipsPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveBytePaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDasPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAdr16PaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAdr32PaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDpcPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDpciPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteImm8PaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2f8 rmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDsDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2da rmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 2db rmdw2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_da[ry_index]);
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAisDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAipsDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveBytePaisDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDasDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDaisDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAdr16DadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAdr32DadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDpcDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDpciDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteImm8DadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2da rmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 2db rmdw2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_dt);
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDsDaidProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1eb rmxw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 109 rmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto rmxw3;
	    }
	    else
	    {
		goto rmxw2;
	    }
	rmxw2:
	    // 128 rmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto rmdw2;
	rmxw3:
	    // 1e8 rmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto rmdw2;
	rmdw2:
	    // 2db rmdw2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_da[ry_index]);
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAisDaidProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    runALU(AluExt, reg_aluo);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxw3;
	    }
	    else
	    {
		goto mmxw2;
	    }
	mmxw2:
	    // 28 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto maww2;
	mmxw3:
	    // e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto maww2;
	maww2:
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAipsDaidProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    runALU(AluExt, reg_aluo);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxw3;
	    }
	    else
	    {
		goto mmxw2;
	    }
	mmxw2:
	    // 28 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto maww2;
	mmxw3:
	    // e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto maww2;
	maww2:
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveBytePaisDaidProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    runALU(AluExt, reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxw3;
	    }
	    else
	    {
		goto mmxw2;
	    }
	mmxw2:
	    // 28 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto maww2;
	mmxw3:
	    // e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto maww2;
	maww2:
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDasDaidProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    runALU(AluExt, reg_aluo);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxw3;
	    }
	    else
	    {
		goto mmxw2;
	    }
	mmxw2:
	    // 28 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto maww2;
	mmxw3:
	    // e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto maww2;
	maww2:
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDaisDaidProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    runALU(AluExt, reg_aluo);
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxw3;
	    }
	    else
	    {
		goto mmxw2;
	    }
	mmxw2:
	    // 28 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto maww2;
	mmxw3:
	    // e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto maww2;
	maww2:
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAdr16DaidProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    runALU(AluExt, reg_aluo);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxw3;
	    }
	    else
	    {
		goto mmxw2;
	    }
	mmxw2:
	    // 28 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto maww2;
	mmxw3:
	    // e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto maww2;
	maww2:
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAdr32DaidProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    runALU(AluExt, reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxw3;
	    }
	    else
	    {
		goto mmxw2;
	    }
	mmxw2:
	    // 28 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto maww2;
	mmxw3:
	    // e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto maww2;
	maww2:
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDpcDaidProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    runALU(AluExt, reg_aluo);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxw3;
	    }
	    else
	    {
		goto mmxw2;
	    }
	mmxw2:
	    // 28 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto maww2;
	mmxw3:
	    // e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto maww2;
	maww2:
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDpciDaidProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    runALU(AluExt, reg_aluo);
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxw3;
	    }
	    else
	    {
		goto mmxw2;
	    }
	mmxw2:
	    // 28 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto maww2;
	mmxw3:
	    // e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto maww2;
	maww2:
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteImm8DaidProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1eb rmxw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 109 rmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto rmxw3;
	    }
	    else
	    {
		goto rmxw2;
	    }
	rmxw2:
	    // 128 rmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto rmdw2;
	rmxw3:
	    // 1e8 rmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto rmdw2;
	rmdw2:
	    // 2db rmdw2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_dt);
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDsAdr16Program()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2d9 raww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_da[ry_index]);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAisAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAipsAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveBytePaisAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDasAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDaisAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAdr16Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAdr32Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDpcAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDpciAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteImm8Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2d9 raww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dt);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAndByte, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDsAdr32Program()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1ea ralw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bb ralw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_da[ry_index]);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAisAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAipsAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveBytePaisAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDasAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDaisAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAdr16Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteAdr32Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDpcAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteDpciAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveByteImm8Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1ea ralw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bb ralw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dt);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAndByte, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 129 rrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 278 rrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    updateCCR(CcrNZU);
	    reg_da[rx_index] = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 129 rrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 278 rrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_at;
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongImm32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 129 rrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_dt;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 278 rrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_at;
	    runALU(AluAnd, high16(reg_dt), 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaLongDsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 129 rrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    // 278 rrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_at;
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaLongAsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 129 rrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    // 278 rrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    reg_da[rx_index] = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaLongAisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaLongAipsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaLongPaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaLongDasAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaLongDaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaLongAdr16AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaLongAdr32AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaLongDpcAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaLongDpciAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaLongImm32AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 129 rrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_dt;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dt, 0xFFFF);
	    // 278 rrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_at;
	    runALU(AluAnd, high16(reg_dt), 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDsAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2f9 rmrl1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = high16(reg_da[ry_index]);
	    reg_alub = high16(reg_da[ry_index]);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    // 23f rmrl2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    // 258 rmrl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAsAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2f9 rmrl1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = high16(reg_da[ry_index]);
	    reg_alub = high16(reg_da[ry_index]);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    // 23f rmrl2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    // 258 rmrl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAisAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3a9 mmrl1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    // 3aa mmrl2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAipsAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3a9 mmrl1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    // 3aa mmrl2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongPaisAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3a9 mmrl1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 3aa mmrl2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDasAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3a9 mmrl1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 3aa mmrl2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDaisAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3a9 mmrl1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 3aa mmrl2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAdr16AidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3a9 mmrl1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 3aa mmrl2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAdr32AidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3a9 mmrl1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 3aa mmrl2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDpcAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3a9 mmrl1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 3aa mmrl2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDpciAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3a9 mmrl1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 3aa mmrl2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongImm32AidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2f9 rmrl1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = high16(reg_dt);
	    reg_alub = high16(reg_dt);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    // 23f rmrl2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dt;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 258 rmrl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDsAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2fd rmil1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = high16(reg_da[ry_index]);
	    reg_alub = high16(reg_da[ry_index]);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    // 23c rmil2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    // 23d rmil3
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAsAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2fd rmil1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = high16(reg_da[ry_index]);
	    reg_alub = high16(reg_da[ry_index]);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    // 23c rmil2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    // 23d rmil3
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAisAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3ad mmil1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    // 3ae mmil2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAipsAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3ad mmil1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    // 3ae mmil2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongPaisAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3ad mmil1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 3ae mmil2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDasAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3ad mmil1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 3ae mmil2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDaisAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3ad mmil1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 3ae mmil2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAdr16AipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3ad mmil1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 3ae mmil2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAdr32AipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3ad mmil1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 3ae mmil2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDpcAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3ad mmil1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 3ae mmil2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDpciAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3ad mmil1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 3ae mmil2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongImm32AipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2fd rmil1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = high16(reg_dt);
	    reg_alub = high16(reg_dt);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    // 23c rmil2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dt;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 23d rmil3
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDsPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2fc rmml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 23e rmml2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAsPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2fc rmml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 23e rmml2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38f mmml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34a mmml2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAipsPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38f mmml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34a mmml2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongPaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38f mmml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34a mmml2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDasPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38f mmml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34a mmml2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38f mmml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34a mmml2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAdr16PaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38f mmml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34a mmml2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAdr32PaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38f mmml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34a mmml2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDpcPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38f mmml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34a mmml2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDpciPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38f mmml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34a mmml2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongImm32PaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2fc rmml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 23e rmml2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_dt), 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDsDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2de rmdl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 2be rmdl2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_da[ry_index]);
	    reg_alub = high16(reg_da[ry_index]);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    // 2df rmdl3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    // 258 rmrl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAsDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2de rmdl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 2be rmdl2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_da[ry_index]);
	    reg_alub = high16(reg_da[ry_index]);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    // 2df rmdl3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    // 258 rmrl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAisDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38e mmdl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAipsDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38e mmdl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongPaisDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38e mmdl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDasDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38e mmdl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDaisDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38e mmdl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAdr16DadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38e mmdl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAdr32DadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38e mmdl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDpcDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38e mmdl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDpciDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38e mmdl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongImm32DadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2de rmdl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 2be rmdl2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_dt);
	    reg_alub = high16(reg_dt);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, high16(reg_dt), 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 2df rmdl3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dt;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 258 rmrl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDsDaidProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1ef rmxl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 105 rmxl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto rmxl3;
	    }
	    else
	    {
		goto rmxl2;
	    }
	rmxl2:
	    // 12c rmxl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto rmdl2;
	rmxl3:
	    // 1ec rmxl3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto rmdl2;
	rmdl2:
	    // 2be rmdl2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_da[ry_index]);
	    reg_alub = high16(reg_da[ry_index]);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 2df rmdl3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 258 rmrl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAsDaidProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1ef rmxl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 105 rmxl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto rmxl3;
	    }
	    else
	    {
		goto rmxl2;
	    }
	rmxl2:
	    // 12c rmxl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto rmdl2;
	rmxl3:
	    // 1ec rmxl3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto rmdl2;
	rmdl2:
	    // 2be rmdl2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_da[ry_index]);
	    reg_alub = high16(reg_da[ry_index]);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 2df rmdl3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 258 rmrl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAisDaidProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29c mmxl0
	    runALU(AluExt, reg_aluo);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 10d mmxl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxl3;
	    }
	    else
	    {
		goto mmxl2;
	    }
	mmxl2:
	    // 2c mmxl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto mawl2;
	mmxl3:
	    // ec mmxl3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto mawl2;
	mawl2:
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAipsDaidProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29c mmxl0
	    runALU(AluExt, reg_aluo);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 10d mmxl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxl3;
	    }
	    else
	    {
		goto mmxl2;
	    }
	mmxl2:
	    // 2c mmxl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto mawl2;
	mmxl3:
	    // ec mmxl3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto mawl2;
	mawl2:
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongPaisDaidProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29c mmxl0
	    runALU(AluExt, reg_aluo);
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 10d mmxl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxl3;
	    }
	    else
	    {
		goto mmxl2;
	    }
	mmxl2:
	    // 2c mmxl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto mawl2;
	mmxl3:
	    // ec mmxl3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto mawl2;
	mawl2:
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDasDaidProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29c mmxl0
	    runALU(AluExt, reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 10d mmxl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxl3;
	    }
	    else
	    {
		goto mmxl2;
	    }
	mmxl2:
	    // 2c mmxl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto mawl2;
	mmxl3:
	    // ec mmxl3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto mawl2;
	mawl2:
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDaisDaidProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29c mmxl0
	    runALU(AluExt, reg_aluo);
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    // 10d mmxl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxl3;
	    }
	    else
	    {
		goto mmxl2;
	    }
	mmxl2:
	    // 2c mmxl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto mawl2;
	mmxl3:
	    // ec mmxl3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto mawl2;
	mawl2:
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAdr16DaidProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29c mmxl0
	    runALU(AluExt, reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 10d mmxl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxl3;
	    }
	    else
	    {
		goto mmxl2;
	    }
	mmxl2:
	    // 2c mmxl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto mawl2;
	mmxl3:
	    // ec mmxl3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto mawl2;
	mawl2:
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAdr32DaidProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29c mmxl0
	    runALU(AluExt, reg_aluo);
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 10d mmxl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxl3;
	    }
	    else
	    {
		goto mmxl2;
	    }
	mmxl2:
	    // 2c mmxl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto mawl2;
	mmxl3:
	    // ec mmxl3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto mawl2;
	mawl2:
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDpcDaidProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29c mmxl0
	    runALU(AluExt, reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 10d mmxl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxl3;
	    }
	    else
	    {
		goto mmxl2;
	    }
	mmxl2:
	    // 2c mmxl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto mawl2;
	mmxl3:
	    // ec mmxl3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto mawl2;
	mawl2:
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDpciDaidProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29c mmxl0
	    runALU(AluExt, reg_aluo);
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    // 10d mmxl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxl3;
	    }
	    else
	    {
		goto mmxl2;
	    }
	mmxl2:
	    // 2c mmxl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto mawl2;
	mmxl3:
	    // ec mmxl3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto mawl2;
	mawl2:
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongImm32DaidProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1ef rmxl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 105 rmxl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto rmxl3;
	    }
	    else
	    {
		goto rmxl2;
	    }
	rmxl2:
	    // 12c rmxl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto rmdl2;
	rmxl3:
	    // 1ec rmxl3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto rmdl2;
	rmdl2:
	    // 2be rmdl2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_dt);
	    reg_alub = high16(reg_dt);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, high16(reg_dt), 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 2df rmdl3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dt;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 258 rmrl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDsAdr16Program()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2dd rawl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_da[ry_index]);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 2ba rall3
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_da[ry_index]);
	    reg_alub = high16(reg_da[ry_index]);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAsAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2dd rawl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_da[ry_index]);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 2ba rall3
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_da[ry_index]);
	    reg_alub = high16(reg_da[ry_index]);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAisAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38c mawl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAipsAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38c mawl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongPaisAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38c mawl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDasAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38c mawl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDaisAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38c mawl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAdr16Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38c mawl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAdr32Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38c mawl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDpcAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38c mawl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDpciAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38c mawl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongImm32Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2dd rawl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dt);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAnd, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 2ba rall3
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_dt);
	    reg_alub = high16(reg_dt);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, high16(reg_dt), 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDsAdr32Program()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1ee rall1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bf rall2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_da[ry_index]);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 2ba rall3
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_da[ry_index]);
	    reg_alub = high16(reg_da[ry_index]);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAsAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1ee rall1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bf rall2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_da[ry_index]);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 2ba rall3
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_da[ry_index]);
	    reg_alub = high16(reg_da[ry_index]);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAisAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 30f mall1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dbin);
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 329 mall2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_dbout = reg_aluo;
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    runALU(AluAnd, reg_at, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 32a mall3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAipsAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 30f mall1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dbin);
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 329 mall2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_dbout = reg_aluo;
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    runALU(AluAnd, reg_at, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 32a mall3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongPaisAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 30f mall1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dbin);
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 329 mall2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_dbout = reg_aluo;
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    runALU(AluAnd, reg_at, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 32a mall3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDasAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 30f mall1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dbin);
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 329 mall2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_dbout = reg_aluo;
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    runALU(AluAnd, reg_at, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 32a mall3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDaisAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 30f mall1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dbin);
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 329 mall2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_dbout = reg_aluo;
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    runALU(AluAnd, reg_at, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 32a mall3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAdr16Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 30f mall1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dbin);
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 329 mall2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_dbout = reg_aluo;
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    runALU(AluAnd, reg_at, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 32a mall3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongAdr32Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 30f mall1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dbin);
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 329 mall2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_dbout = reg_aluo;
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    runALU(AluAnd, reg_at, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 32a mall3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDpcAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 30f mall1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dbin);
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 329 mall2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_dbout = reg_aluo;
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    runALU(AluAnd, reg_at, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 32a mall3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongDpciAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 30f mall1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dbin);
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 329 mall2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_dbout = reg_aluo;
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    runALU(AluAnd, reg_at, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 32a mall3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveLongImm32Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1ee rall1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bf rall2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dt);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAnd, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 2ba rall3
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_dt);
	    reg_alub = high16(reg_dt);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, high16(reg_dt), 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 121 rrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 121 rrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordImm16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 121 rrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_dt;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaWordDsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 279 rrgm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    reg_au = reg_au + 2;
	    // 278 rrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_at;
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaWordAsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 279 rrgm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    reg_au = reg_au + 2;
	    // 278 rrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    reg_da[rx_index] = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaWordAisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 158 mrgm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_da[rx_index] = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaWordAipsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 158 mrgm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_da[rx_index] = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaWordPaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 158 mrgm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_da[rx_index] = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaWordDasAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 158 mrgm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_da[rx_index] = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaWordDaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 158 mrgm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_da[rx_index] = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaWordAdr16AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 158 mrgm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_da[rx_index] = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaWordAdr32AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 158 mrgm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_da[rx_index] = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaWordDpcAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 158 mrgm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_da[rx_index] = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaWordDpciAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 158 mrgm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_da[rx_index] = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveaWordImm16AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 279 rrgm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    reg_au = reg_au + 2;
	    // 278 rrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_at;
	    runALU(AluAnd, high16(reg_dt), 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDsAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2fa rmrw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAsAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2fa rmrw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAisAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAipsAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordPaisAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDasAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDaisAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAdr16AidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAdr32AidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDpcAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDpciAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordImm16AidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2fa rmrw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dt;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    // 25 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDsAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2fe rmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAsAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2fe rmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAisAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAipsAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordPaisAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDasAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDaisAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAdr16AipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAdr32AipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDpcAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDpciAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordImm16AipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2fe rmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dt;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDsPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2f8 rmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAsPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2f8 rmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAipsPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordPaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDasPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAdr16PaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAdr32PaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDpcPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDpciPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordImm16PaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2f8 rmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    runALU(AluAnd, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDsDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2da rmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 2db rmdw2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAsDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2da rmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 2db rmdw2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAisDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAipsDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordPaisDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDasDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDaisDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAdr16DadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAdr32DadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDpcDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDpciDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordImm16DadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2da rmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 2db rmdw2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dt;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDsDaidProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1eb rmxw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 109 rmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto rmxw3;
	    }
	    else
	    {
		goto rmxw2;
	    }
	rmxw2:
	    // 128 rmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto rmdw2;
	rmxw3:
	    // 1e8 rmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto rmdw2;
	rmdw2:
	    // 2db rmdw2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAsDaidProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1eb rmxw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 109 rmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto rmxw3;
	    }
	    else
	    {
		goto rmxw2;
	    }
	rmxw2:
	    // 128 rmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto rmdw2;
	rmxw3:
	    // 1e8 rmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto rmdw2;
	rmdw2:
	    // 2db rmdw2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAisDaidProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    runALU(AluExt, reg_aluo);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxw3;
	    }
	    else
	    {
		goto mmxw2;
	    }
	mmxw2:
	    // 28 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto maww2;
	mmxw3:
	    // e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto maww2;
	maww2:
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAipsDaidProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    runALU(AluExt, reg_aluo);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxw3;
	    }
	    else
	    {
		goto mmxw2;
	    }
	mmxw2:
	    // 28 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto maww2;
	mmxw3:
	    // e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto maww2;
	maww2:
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordPaisDaidProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    runALU(AluExt, reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxw3;
	    }
	    else
	    {
		goto mmxw2;
	    }
	mmxw2:
	    // 28 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto maww2;
	mmxw3:
	    // e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto maww2;
	maww2:
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDasDaidProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    runALU(AluExt, reg_aluo);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxw3;
	    }
	    else
	    {
		goto mmxw2;
	    }
	mmxw2:
	    // 28 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto maww2;
	mmxw3:
	    // e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto maww2;
	maww2:
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDaisDaidProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    runALU(AluExt, reg_aluo);
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxw3;
	    }
	    else
	    {
		goto mmxw2;
	    }
	mmxw2:
	    // 28 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto maww2;
	mmxw3:
	    // e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto maww2;
	maww2:
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAdr16DaidProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    runALU(AluExt, reg_aluo);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxw3;
	    }
	    else
	    {
		goto mmxw2;
	    }
	mmxw2:
	    // 28 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto maww2;
	mmxw3:
	    // e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto maww2;
	maww2:
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAdr32DaidProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    runALU(AluExt, reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxw3;
	    }
	    else
	    {
		goto mmxw2;
	    }
	mmxw2:
	    // 28 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto maww2;
	mmxw3:
	    // e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto maww2;
	maww2:
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDpcDaidProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    runALU(AluExt, reg_aluo);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxw3;
	    }
	    else
	    {
		goto mmxw2;
	    }
	mmxw2:
	    // 28 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto maww2;
	mmxw3:
	    // e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto maww2;
	maww2:
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDpciDaidProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    runALU(AluExt, reg_aluo);
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxw3;
	    }
	    else
	    {
		goto mmxw2;
	    }
	mmxw2:
	    // 28 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto maww2;
	mmxw3:
	    // e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	goto maww2;
	maww2:
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordImm16DaidProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1eb rmxw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 109 rmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto rmxw3;
	    }
	    else
	    {
		goto rmxw2;
	    }
	rmxw2:
	    // 128 rmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto rmdw2;
	rmxw3:
	    // 1e8 rmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto rmdw2;
	rmdw2:
	    // 2db rmdw2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dt;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDsAdr16Program()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2d9 raww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_da[ry_index]);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAsAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2d9 raww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_da[ry_index]);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAisAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAipsAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordPaisAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDasAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDaisAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAdr16Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAdr32Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDpcAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDpciAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordImm16Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2d9 raww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dt);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAnd, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDsAdr32Program()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1ea ralw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bb ralw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_da[ry_index]);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAsAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1ea ralw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bb ralw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_da[ry_index]);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAisAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAipsAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordPaisAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDasAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDaisAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAdr16Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordAdr32Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDpcAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordDpciAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveWordImm16Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1ea ralw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bb ralw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dt);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAnd, reg_dt, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxByteDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 133 nnrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSubxByte, reg_da[ry_index], 0x0000);
	    updateCCR(CcrXNZVCU);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxByteAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubxByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxByteAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubxByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxBytePaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubxByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxByteDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubxByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxByteDaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubxByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxByteAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubxByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxByteAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubxByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxWordDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 133 nnrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSubx, reg_da[ry_index], 0x0000);
	    updateCCR(CcrXNZVCU);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxWordAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubx, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxWordAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubx, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxWordPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubx, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxWordDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubx, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxWordDaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubx, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxWordAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubx, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxWordAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubx, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxLongDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 137 nnrl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSubx, reg_da[ry_index], 0x0000);
	    updateCCR(CcrXNZVCU);
	    // 15e nnrl2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    runALU(AluSubc, high16(reg_da[ry_index]), 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxLongAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubx, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluSubc, reg_alub, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxLongAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubx, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluSubc, reg_alub, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxLongPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubx, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluSubc, reg_alub, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxLongDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubx, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluSubc, reg_alub, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxLongDaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubx, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluSubc, reg_alub, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxLongAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubx, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluSubc, reg_alub, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegxLongAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubx, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluSubc, reg_alub, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveSrDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3a5 strw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_ftu = reg_sr;
	    // 340 strw2
	    setReg16Low(reg_da[ry_index], reg_ftu);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveSrAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3a1 stmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_ftu = reg_sr;
	    // 324 sftm2
	    reg_au = reg_at;
	    runALU(AluAnd, reg_ftu, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveSrAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3a1 stmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_ftu = reg_sr;
	    // 324 sftm2
	    reg_au = reg_at;
	    runALU(AluAnd, reg_ftu, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveSrPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3a1 stmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_ftu = reg_sr;
	    // 324 sftm2
	    reg_au = reg_at;
	    runALU(AluAnd, reg_ftu, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveSrDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3a1 stmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_ftu = reg_sr;
	    // 324 sftm2
	    reg_au = reg_at;
	    runALU(AluAnd, reg_ftu, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveSrDaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3a1 stmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_ftu = reg_sr;
	    // 324 sftm2
	    reg_au = reg_at;
	    runALU(AluAnd, reg_ftu, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveSrAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3a1 stmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_ftu = reg_sr;
	    // 324 sftm2
	    reg_au = reg_at;
	    runALU(AluAnd, reg_ftu, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveSrAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3a1 stmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_ftu = reg_sr;
	    // 324 sftm2
	    reg_au = reg_at;
	    runALU(AluAnd, reg_ftu, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kChkWordDsDdProgram()
{
    unknownInstr();
}

void m68kChkWordAisDdProgram()
{
    unknownInstr();
}

void m68kChkWordAipsDdProgram()
{
    unknownInstr();
}

void m68kChkWordPaisDdProgram()
{
    unknownInstr();
}

void m68kChkWordDasDdProgram()
{
    unknownInstr();
}

void m68kChkWordDaisDdProgram()
{
    unknownInstr();
}

void m68kChkWordAdr16DdProgram()
{
    unknownInstr();
}

void m68kChkWordAdr32DdProgram()
{
    unknownInstr();
}

void m68kChkWordDpcDdProgram()
{
    unknownInstr();
}

void m68kChkWordDpciDdProgram()
{
    unknownInstr();
}

void m68kChkWordImm16DdProgram()
{
    unknownInstr();
}

void m68kLeaAisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2f1 leaa1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_ftu = reg_dbin;
	    // 66 leaa2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLeaDasAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2f2 lead1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    // 309 lead2
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLeaDaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1fb leax0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3ea leax1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto leax3;
	    }
	    else
	    {
		goto leax2;
	    }
	leax2:
	    // 130 leax2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto leax4;
	leax3:
	    // 1f0 leax3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto leax4;
	leax4:
	    // 30a leax4
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 4;
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLeaAdr16AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 275 laaw1
	    reg_aob = reg_au;
	    reg_da[rx_index] = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLeaAdr32AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e4 laal1
	    reg_aob = reg_au;
	    setReg16High(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bd laal2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLeaDpcAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2f2 lead1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    // 309 lead2
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLeaDpciAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1fb leax0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3ea leax1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto leax3;
	    }
	    else
	    {
		goto leax2;
	    }
	leax2:
	    // 130 leax2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto leax4;
	leax3:
	    // 1f0 leax3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto leax4;
	leax4:
	    // 30a leax4
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 4;
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrByteDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 133 nnrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_da[ry_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrByteAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrByteAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_da[reg_movems], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrBytePaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_da[reg_movems], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrByteDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrByteDaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrByteAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAndByte, reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrByteAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAndByte, reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrWordDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 133 nnrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_da[ry_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrWordAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrWordAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_da[reg_movems], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrWordPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - 2;
	    runALU(AluAnd, reg_da[reg_movems], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrWordDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrWordDaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrWordAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAnd, reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrWordAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAnd, reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrLongDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 137 nnrl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_da[ry_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 15e nnrl2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0x0000);
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrLongAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluAnd, reg_alub, 0x0000);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrLongAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluAnd, reg_alub, 0x0000);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrLongPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluAnd, reg_alub, 0x0000);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrLongDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluAnd, reg_alub, 0x0000);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrLongDaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluAnd, reg_alub, 0x0000);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrLongAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAnd, reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluAnd, reg_alub, 0x0000);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kClrLongAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAnd, reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_dbin, 0x0000);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluAnd, reg_alub, 0x0000);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegByteDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 133 nnrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSubByte, reg_da[ry_index], 0x0000);
	    updateCCR(CcrXNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegByteAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegByteAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegBytePaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegByteDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegByteDaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegByteAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegByteAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegWordDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 133 nnrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSub, reg_da[ry_index], 0x0000);
	    updateCCR(CcrXNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegWordAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegWordAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegWordPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegWordDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegWordDaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegWordAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegWordAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegLongDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 137 nnrl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSub, reg_da[ry_index], 0x0000);
	    updateCCR(CcrXNZVC);
	    // 15e nnrl2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    runALU(AluSubc, high16(reg_da[ry_index]), 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegLongAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluSubc, reg_alub, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegLongAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluSubc, reg_alub, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegLongPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluSubc, reg_alub, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegLongDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluSubc, reg_alub, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegLongDaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluSubc, reg_alub, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegLongAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluSubc, reg_alub, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNegLongAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluSubc, reg_alub, 0x0000);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveDsCcrProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 301 rstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_da[ry_index];
	    reg_au = reg_au - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveAisCcrProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveAipsCcrProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMovePaisCcrProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveDasCcrProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveDaisCcrProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveAdr16CcrProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveAdr32CcrProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveDpcCcrProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveDpciCcrProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveImm8CcrProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 301 rstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dt;
	    reg_au = reg_au - 2;
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotByteDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 133 nnrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluNotByte, reg_da[ry_index]);
	    updateCCR(CcrNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotByteAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndBytex, reg_dbin, 0xFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNotByte, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotByteAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndBytex, reg_alub, 0xFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNotByte, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotBytePaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndBytex, reg_alub, 0xFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNotByte, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotByteDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndBytex, reg_dbin, 0xFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNotByte, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotByteDaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndBytex, reg_dbin, 0xFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNotByte, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotByteAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndBytex, reg_dbin, 0xFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNotByte, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotByteAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndBytex, reg_dbin, 0xFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNotByte, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotWordDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 133 nnrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluNot, reg_da[ry_index]);
	    updateCCR(CcrNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotWordAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNot, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotWordAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndx, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNot, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotWordPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndx, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNot, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotWordDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNot, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotWordDaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNot, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotWordAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNot, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotWordAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNot, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotLongDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 137 nnrl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluNot, reg_da[ry_index]);
	    updateCCR(CcrNZVC);
	    // 15e nnrl2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    runALU(AluNot, high16(reg_da[ry_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotLongAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNot, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluNot, reg_alub);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotLongAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNot, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluNot, reg_alub);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotLongPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNot, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluNot, reg_alub);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotLongDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNot, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluNot, reg_alub);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotLongDaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNot, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluNot, reg_alub);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotLongAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNot, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluNot, reg_alub);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNotLongAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluNot, reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    runALU(AluNot, reg_alub);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveDsSrProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	if (!testbit(reg_sr, 13))
	{
	    setPriv();
	    return;
	}
	    // 301 rstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_da[ry_index];
	    reg_au = reg_au - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
updateSupervisor();
updateInterrupts();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveAisSrProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	if (!testbit(reg_sr, 13))
	{
	    setPriv();
	    return;
	}
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
updateSupervisor();
updateInterrupts();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveAipsSrProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	if (!testbit(reg_sr, 13))
	{
	    setPriv();
	    return;
	}
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndx, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
updateSupervisor();
updateInterrupts();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMovePaisSrProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	if (!testbit(reg_sr, 13))
	{
	    setPriv();
	    return;
	}
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndx, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
updateSupervisor();
updateInterrupts();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveDasSrProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	if (!testbit(reg_sr, 13))
	{
	    setPriv();
	    return;
	}
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
updateSupervisor();
updateInterrupts();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveDaisSrProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	if (!testbit(reg_sr, 13))
	{
	    setPriv();
	    return;
	}
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
updateSupervisor();
updateInterrupts();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveAdr16SrProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	if (!testbit(reg_sr, 13))
	{
	    setPriv();
	    return;
	}
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
updateSupervisor();
updateInterrupts();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveAdr32SrProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	if (!testbit(reg_sr, 13))
	{
	    setPriv();
	    return;
	}
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
updateSupervisor();
updateInterrupts();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveDpcSrProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	if (!testbit(reg_sr, 13))
	{
	    setPriv();
	    return;
	}
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
updateSupervisor();
updateInterrupts();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveDpciSrProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	if (!testbit(reg_sr, 13))
	{
	    setPriv();
	    return;
	}
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
updateSupervisor();
updateInterrupts();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveI16uSrProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	if (!testbit(reg_sr, 13))
	{
	    setPriv();
	    return;
	}
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 301 rstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dt;
	    reg_au = reg_au - 2;
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
updateSupervisor();
updateInterrupts();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNbcdByteDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 13b nbcr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSbcdByte, reg_da[ry_index], 0x0000);
	    updateCCR(CcrXNZVCU);
	    // 117 nbcr2
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNbcdByteAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 15c nbcm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluSbcdByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    // 113 asbb6
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNbcdByteAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 15c nbcm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluSbcdByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    // 113 asbb6
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNbcdBytePaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 15c nbcm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluSbcdByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    // 113 asbb6
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNbcdByteDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 15c nbcm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluSbcdByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    // 113 asbb6
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNbcdByteDaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 15c nbcm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluSbcdByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    // 113 asbb6
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNbcdByteAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 15c nbcm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluSbcdByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    // 113 asbb6
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNbcdByteAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 15c nbcm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluSbcdByte, reg_dbin, 0x0000);
	    updateCCR(CcrXNZVCU);
	    // 113 asbb6
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSwapDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 341 swap1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[ry_index];
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_da[ry_index]);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 342 swap2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[ry_index] = merge32(high16(reg_at), reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kPeaAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 17c peaa1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = merge32(high16(reg_da[rx_index]), 0) - 4;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 106 peax6
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_at);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kPeaDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 17d pead1
	    reg_aob = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 17e pead2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_at;
	    // 17f pead3
	    reg_at = reg_au;
	    runALU(AluAnd, reg_au, 0xFFFF);
	    reg_au = merge32(high16(reg_da[rx_index]), 0) - 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 106 peax6
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_at);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kPeaDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1ff peax0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3ee peax1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto peax3;
	    }
	    else
	    {
		goto peax2;
	    }
	peax2:
	    // 134 peax2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto peax4;
	peax3:
	    // 1f4 peax3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto peax4;
	peax4:
	    // 218 peax4
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_at = reg_au;
	    runALU(AluAnd, reg_au, 0xFFFF);
	    reg_au = reg_pc + 4;
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 219 peax5
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = merge32(high16(reg_da[rx_index]), 0) - 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 106 peax6
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_at);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kPeaAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 178 paaw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    reg_au = merge32(high16(reg_da[rx_index]), 0) - 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 10a paaw2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_at);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kPeaAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1fa paal1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 15f paal2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_da[rx_index]), 0) - 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 10a paaw2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_at);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kPeaDpcProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 17d pead1
	    reg_aob = reg_au;
	    reg_at = reg_pc;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 17e pead2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_at;
	    // 17f pead3
	    reg_at = reg_au;
	    runALU(AluAnd, reg_au, 0xFFFF);
	    reg_au = merge32(high16(reg_da[rx_index]), 0) - 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 106 peax6
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_at);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kPeaDpciProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1ff peax0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3ee peax1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto peax3;
	    }
	    else
	    {
		goto peax2;
	    }
	peax2:
	    // 134 peax2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto peax4;
	peax3:
	    // 1f4 peax3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto peax4;
	peax4:
	    // 218 peax4
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_at = reg_au;
	    runALU(AluAnd, reg_au, 0xFFFF);
	    reg_au = reg_pc + 4;
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 219 peax5
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = merge32(high16(reg_da[rx_index]), 0) - 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 106 peax6
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_at);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kExtWordDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 133 nnrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluExt, reg_da[ry_index]);
	    updateCCR(CcrNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMovemWordListAisProgram()
{
    unknownInstr();
}

void m68kMovemWordListpPaisProgram()
{
    unknownInstr();
}

void m68kMovemWordListDasProgram()
{
    unknownInstr();
}

void m68kMovemWordListDaisProgram()
{
    unknownInstr();
}

void m68kMovemWordListAdr16Program()
{
    unknownInstr();
}

void m68kMovemWordListAdr32Program()
{
    unknownInstr();
}

void m68kExtLongDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 232 extr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 233 extr2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[ry_index] = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMovemLongListAisProgram()
{
    unknownInstr();
}

void m68kMovemLongListpPaisProgram()
{
    unknownInstr();
}

void m68kMovemLongListDasProgram()
{
    unknownInstr();
}

void m68kMovemLongListDaisProgram()
{
    unknownInstr();
}

void m68kMovemLongListAdr16Program()
{
    unknownInstr();
}

void m68kMovemLongListAdr32Program()
{
    unknownInstr();
}

void m68kTstByteDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 12d tsrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstByteAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstByteAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_da[reg_movems], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstBytePaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_da[reg_movems], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstByteDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstByteDaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstByteAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluOrByte, reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstByteAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluOrByte, reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstWordDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 12d tsrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstWordAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstWordAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluOr, reg_da[reg_movems], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstWordPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - 2;
	    runALU(AluOr, reg_da[reg_movems], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstWordDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstWordDaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstWordAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluOr, reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstWordAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluOr, reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstLongDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 125 tsrl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 362 tsrl2
	    reg_ird = reg_ir;
	    setIntState();
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstLongAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3cb tsml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 361 tsml2
	    reg_ird = reg_ir;
	    setIntState();
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstLongAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3cb tsml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 361 tsml2
	    reg_ird = reg_ir;
	    setIntState();
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstLongPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3cb tsml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 361 tsml2
	    reg_ird = reg_ir;
	    setIntState();
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstLongDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3cb tsml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 361 tsml2
	    reg_ird = reg_ir;
	    setIntState();
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstLongDaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3cb tsml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 361 tsml2
	    reg_ird = reg_ir;
	    setIntState();
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstLongAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluOr, reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3cb tsml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 361 tsml2
	    reg_ird = reg_ir;
	    setIntState();
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTstLongAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluOr, reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3cb tsml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 361 tsml2
	    reg_ird = reg_ir;
	    setIntState();
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTasDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 345 tasr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[ry_index];
	    reg_pc = reg_au;
	    runALU(AluOrByte, reg_ftu, reg_da[ry_index]);
	    // 346 tasr2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_au + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTasAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readRMC();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 343 tasm1
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_ftu, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 344 tasm2
	    reg_aob = reg_au;
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeRMC();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTasAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_da[reg_movems], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readRMC();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 343 tasm1
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_ftu, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 344 tasm2
	    reg_aob = reg_au;
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeRMC();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTasPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_da[reg_movems], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readRMC();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 343 tasm1
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_ftu, reg_dbin);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 344 tasm2
	    reg_aob = reg_au;
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeRMC();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTasDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readRMC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 343 tasm1
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_ftu, reg_dbin);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 344 tasm2
	    reg_aob = reg_au;
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeRMC();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTasDaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false);
	    readRMC();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 343 tasm1
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_ftu, reg_dbin);
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 344 tasm2
	    reg_aob = reg_au;
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeRMC();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTasAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluOrByte, reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readRMC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 343 tasm1
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_ftu, reg_dbin);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 344 tasm2
	    reg_aob = reg_au;
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeRMC();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTasAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluOrByte, reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readRMC();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 343 tasm1
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_ftu, reg_dbin);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 344 tasm2
	    reg_aob = reg_au;
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(true, false, false, false);
	    writeRMC();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMovemWordAisListProgram()
{
    unknownInstr();
}

void m68kMovemWordAipsListProgram()
{
    unknownInstr();
}

void m68kMovemWordDasListProgram()
{
    unknownInstr();
}

void m68kMovemWordDaisListProgram()
{
    unknownInstr();
}

void m68kMovemWordAdr16ListProgram()
{
    unknownInstr();
}

void m68kMovemWordAdr32ListProgram()
{
    unknownInstr();
}

void m68kMovemWordDpcListProgram()
{
    unknownInstr();
}

void m68kMovemWordDpciListProgram()
{
    unknownInstr();
}

void m68kMovemLongAisListProgram()
{
    unknownInstr();
}

void m68kMovemLongAipsListProgram()
{
    unknownInstr();
}

void m68kMovemLongDasListProgram()
{
    unknownInstr();
}

void m68kMovemLongDaisListProgram()
{
    unknownInstr();
}

void m68kMovemLongAdr16ListProgram()
{
    unknownInstr();
}

void m68kMovemLongAdr32ListProgram()
{
    unknownInstr();
}

void m68kMovemLongDpcListProgram()
{
    unknownInstr();
}

void m68kMovemLongDpciListProgram()
{
    unknownInstr();
}

void m68kTrapImm4Program()
{
    unknownInstr();
}

void m68kLinkAsImm16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 30b link1
	    reg_aob = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    // 2b5 link2
	    reg_pc = reg_au;
	    reg_au = reg_da[reg_sp] - 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 30c link3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = high16(reg_at);
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    // 30d link4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[reg_sp] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kUnlkAsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 119 unlk1
	    reg_aob = reg_da[ry_index];
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    stepMovem();
	    // 1fe unlk2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 27c unlk3
	    reg_aob = reg_pc;
	    reg_da[reg_sp] = reg_au;
	    reg_au = reg_pc + 2;
	    // 27d unlk4
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[ry_index] = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveAsUspProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	if (!testbit(reg_sr, 13))
	{
	    setPriv();
	    return;
	}
	    // 2f5 lusp1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_ftu = reg_dbin;
	    // 66 leaa2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[15] = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMoveUspAsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	if (!testbit(reg_sr, 13))
	{
	    setPriv();
	    return;
	}
	    // 230 susp1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dcr = reg_da[15];
	    reg_at = reg_da[15];
	    reg_au = reg_da[ry_index];
	    // 233 extr2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[ry_index] = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kResetProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	if (!testbit(reg_sr, 13))
	{
	    setPriv();
	    return;
	}
	    // 3a6 rset1
	    reg_ird = reg_ir;
	    setIntState();
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0x0000);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 27b rset2
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = ext32(reg_aluo) - 2;
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	goto rset3;
	rset3:
	    // e4 rset3
	    reg_au = reg_au - 2;
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 114 rset4
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (reg_t)
	    {
		goto rset5;
	    }
	    else
	    {
		goto rset3;
	    }
	rset5:
	    // 64 rset5
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kNopProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kStopI16uProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	if (!testbit(reg_sr, 13))
	{
	    setPriv();
	    return;
	}
	    // 3a2 stop1
	    reg_ird = reg_ir;
	    setIntState();
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0x0000);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 327 aaa01
	    reg_ird = reg_ir;
	    setIntState();
	    reg_pc = reg_au;
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
updateSupervisor();
updateInterrupts();
	    reg_au = reg_au - 2;
	    inst_cycle = 3;
}
break;
	case 3:
	{
	    nextInst();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRteProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	if (!testbit(reg_sr, 13))
	{
	    setPriv();
	    return;
	}
	    // 12a rtr1
	    reg_aob = reg_da[reg_sp];
	    reg_au = reg_da[reg_sp] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 12b rtr2
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 3c5 rtr3
	    reg_aob = reg_au;
	    reg_at = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    // 302 rtr4
	    setReg16High(reg_at, reg_dbin);
	    reg_da[reg_sp] = reg_au;
	    reg_new_sr = reg_isr = (reg_ftu & 0xA71F);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    updateSR();
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b3 jmal2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRtsProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 126 rts1
	    reg_aob = reg_da[reg_sp];
	    reg_au = reg_da[reg_sp] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 116 rts2
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 303 rts3
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_da[reg_sp] = reg_au;
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTrapvProgram()
{
    unknownInstr();
}

void m68kRtrProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 12a rtr1
	    reg_aob = reg_da[reg_sp];
	    reg_au = reg_da[reg_sp] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 12b rtr2
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 3c5 rtr3
	    reg_aob = reg_au;
	    reg_at = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    // 302 rtr4
	    setReg16High(reg_at, reg_dbin);
	    reg_da[reg_sp] = reg_au;
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b3 jmal2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kJsrAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 273 jsra1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[reg_sp] - 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 271 jsaw2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_pc);
	    reg_da[reg_sp] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    // 272 jsaw3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_pc;
	    reg_au = reg_at + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kJsrDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b0 jsrd1
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 274 jsrd2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    // 2b1 jsrd3
	    reg_pc = reg_au;
	    reg_au = reg_da[reg_sp] - 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 271 jsaw2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_pc);
	    reg_da[reg_sp] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 272 jsaw3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_pc;
	    reg_au = reg_at + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kJsrDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1f3 jsrx0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 2b2 jsrx1
	    reg_t = testbit(reg_irc, 11);
	    reg_au = ext32(reg_aluo) + reg_da[ry_index];
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (reg_t)
	    {
		goto jsrx3;
	    }
	    else
	    {
		goto jsrx2;
	    }
	jsrx2:
	    // 29 jsrx2
	    reg_au = reg_au + ext32(reg_da[mapSP(reg_irc >> 12)]);
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	goto jsrd2;
	jsrx3:
	    // e9 jsrx3
	    reg_au = reg_au + reg_da[mapSP(reg_irc >> 12)];
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	goto jsrd2;
	jsrd2:
	    // 274 jsrd2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    // 2b1 jsrd3
	    reg_pc = reg_au;
	    reg_au = reg_da[reg_sp] - 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 271 jsaw2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_pc);
	    reg_da[reg_sp] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    // 272 jsaw3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_pc;
	    reg_au = reg_at + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kJsrAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 293 jsaw0
	    reg_at = ext32(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 270 jsaw1
	    reg_aob = reg_at;
	    reg_pc = reg_au;
	    reg_au = reg_da[reg_sp] - 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 271 jsaw2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_pc);
	    reg_da[reg_sp] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 272 jsaw3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_pc;
	    reg_au = reg_at + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kJsrAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1f2 jsal1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 256 jsal2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = reg_da[reg_sp] - 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 271 jsaw2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_pc);
	    reg_da[reg_sp] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    // 272 jsaw3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_pc;
	    reg_au = reg_at + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kJsrDpcProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b0 jsrd1
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 274 jsrd2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    // 2b1 jsrd3
	    reg_pc = reg_au;
	    reg_au = reg_da[reg_sp] - 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 271 jsaw2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_pc);
	    reg_da[reg_sp] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 272 jsaw3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_pc;
	    reg_au = reg_at + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kJsrDpciProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1f3 jsrx0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 2b2 jsrx1
	    reg_t = testbit(reg_irc, 11);
	    reg_au = ext32(reg_aluo) + reg_pc;
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (reg_t)
	    {
		goto jsrx3;
	    }
	    else
	    {
		goto jsrx2;
	    }
	jsrx2:
	    // 29 jsrx2
	    reg_au = reg_au + ext32(reg_da[mapSP(reg_irc >> 12)]);
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	goto jsrd2;
	jsrx3:
	    // e9 jsrx3
	    reg_au = reg_au + reg_da[mapSP(reg_irc >> 12)];
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	goto jsrd2;
	jsrd2:
	    // 274 jsrd2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    // 2b1 jsrd3
	    reg_pc = reg_au;
	    reg_au = reg_da[reg_sp] - 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 271 jsaw2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_pc);
	    reg_da[reg_sp] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    // 272 jsaw3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_pc;
	    reg_au = reg_at + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kJmpAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 255 jmpa1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kJmpDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b4 jmpd1
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kJmpDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1f7 jmpx0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 2b6 jmpx1
	    reg_t = testbit(reg_irc, 11);
	    reg_au = ext32(reg_aluo) + reg_da[ry_index];
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (reg_t)
	    {
		goto jmpx3;
	    }
	    else
	    {
		goto jmpx2;
	    }
	jmpx2:
	    // 2d jmpx2
	    reg_au = reg_au + ext32(reg_da[mapSP(reg_irc >> 12)]);
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	goto bbci3;
	jmpx3:
	    // ed jmpx3
	    reg_au = reg_au + reg_da[mapSP(reg_irc >> 12)];
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	goto bbci3;
	bbci3:
	    // c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kJmpAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 297 jmaw1
	    reg_at = ext32(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 2b3 jmal2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kJmpAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1f6 jmal1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2b3 jmal2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kJmpDpcProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b4 jmpd1
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kJmpDpciProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1f7 jmpx0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 2b6 jmpx1
	    reg_t = testbit(reg_irc, 11);
	    reg_au = ext32(reg_aluo) + reg_pc;
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (reg_t)
	    {
		goto jmpx3;
	    }
	    else
	    {
		goto jmpx2;
	    }
	jmpx2:
	    // 2d jmpx2
	    reg_au = reg_au + ext32(reg_da[mapSP(reg_irc >> 12)]);
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	goto bbci3;
	jmpx3:
	    // ed jmpx3
	    reg_au = reg_au + reg_da[mapSP(reg_irc >> 12)];
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	goto bbci3;
	bbci3:
	    // c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqByteImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2d8 raqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    runALU(AluAddByte, reg_ftu, reg_da[ry_index]);
	    updateCCR(CcrXNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqByteImm3AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqByteImm3AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqByteImm3PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqByteImm3DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqByteImm3DaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqByteImm3Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqByteImm3Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqWordImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2d8 raqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    runALU(AluAdd, reg_ftu, reg_da[ry_index]);
	    updateCCR(CcrXNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqWordImm3AsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2dc raql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    runALU(AluAdd, reg_ftu, reg_da[ry_index]);
	    // 259 roal2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25a roal3
	    runALU(AluAddc, high16(reg_dt), high16(reg_da[ry_index]));
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqWordImm3AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAdd, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqWordImm3AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAdd, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqWordImm3PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAdd, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqWordImm3DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAdd, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqWordImm3DaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAdd, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqWordImm3Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAdd, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqWordImm3Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAdd, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqLongImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2dc raql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    runALU(AluAdd, reg_ftu, reg_da[ry_index]);
	    updateCCR(CcrXNZVC);
	    // 259 roal2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25a roal3
	    runALU(AluAddc, high16(reg_dt), high16(reg_da[ry_index]));
	    updateCCR(CcrXNZVCU);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqLongImm3AsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2dc raql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    runALU(AluAdd, reg_ftu, reg_da[ry_index]);
	    // 259 roal2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25a roal3
	    runALU(AluAddc, high16(reg_dt), high16(reg_da[ry_index]));
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqLongImm3AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAdd, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqLongImm3AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAdd, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqLongImm3PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAdd, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqLongImm3DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAdd, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqLongImm3DaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAdd, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqLongImm3Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAdd, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddqLongImm3Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluAdd, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kStDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 384 sccr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 1;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccr2;
	    }
	    else
	    {
		goto roaw2;
	    }
	roaw2:
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	sccr2:
	    // cb sccr2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kDbtDsRel16Program()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6c dbcc1
	    reg_t = 1;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (reg_t)
	    {
		goto dbcc6;
	    }
	    else
	    {
		goto dbcc2;
	    }
	dbcc2:
	    // 46 dbcc2
	    reg_aob = reg_au;
	    reg_alub = reg_da[ry_index];
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    // 175 dbcc3
	    reg_t = testbit(reg_isr, 2);
	    reg_pc = reg_au;
	    reg_au = reg_at + 2;
	    runALU(AluAdd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    if (reg_t)
	    {
		goto dbcc5;
	    }
	    else
	    {
		goto dbcc4;
	    }
	dbcc6:
	    // c6 dbcc6
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    setTrace();
	    // c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dbcc4:
	    // c7 dbcc4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dbcc5:
	    // 7 dbcc5
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    setTrace();
	goto dbcc4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kStAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 1;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto morw2;
	sccb2:
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kStAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 1;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto morw2;
	sccb2:
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kStPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 1;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto morw2;
	sccb2:
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kStDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 1;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto morw2;
	sccb2:
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kStDaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 1;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto morw2;
	sccb2:
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kStAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 1;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto morw2;
	sccb2:
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kStAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 1;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto morw2;
	sccb2:
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqByteImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2d8 raqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    runALU(AluSubByte, reg_ftu, reg_da[ry_index]);
	    updateCCR(CcrXNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqByteImm3AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqByteImm3AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqByteImm3PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqByteImm3DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqByteImm3DaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqByteImm3Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqByteImm3Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqWordImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2d8 raqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    runALU(AluSub, reg_ftu, reg_da[ry_index]);
	    updateCCR(CcrXNZVC);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqWordImm3AsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2dc raql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    runALU(AluSub, reg_ftu, reg_da[ry_index]);
	    // 259 roal2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25a roal3
	    runALU(AluSubc, high16(reg_dt), high16(reg_da[ry_index]));
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqWordImm3AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSub, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqWordImm3AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSub, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqWordImm3PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSub, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqWordImm3DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSub, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqWordImm3DaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSub, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqWordImm3Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSub, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqWordImm3Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSub, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqLongImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2dc raql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    runALU(AluSub, reg_ftu, reg_da[ry_index]);
	    updateCCR(CcrXNZVC);
	    // 259 roal2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25a roal3
	    runALU(AluSubc, high16(reg_dt), high16(reg_da[ry_index]));
	    updateCCR(CcrXNZVCU);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqLongImm3AsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2dc raql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    runALU(AluSub, reg_ftu, reg_da[ry_index]);
	    // 259 roal2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25a roal3
	    runALU(AluSubc, high16(reg_dt), high16(reg_da[ry_index]));
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqLongImm3AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSub, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqLongImm3AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSub, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqLongImm3PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSub, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqLongImm3DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSub, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqLongImm3DaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSub, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqLongImm3Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSub, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubqLongImm3Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    runALU(AluSub, reg_ftu, reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_dt), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSfDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 384 sccr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 0;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccr2;
	    }
	    else
	    {
		goto roaw2;
	    }
	roaw2:
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	sccr2:
	    // cb sccr2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kDbraDsRel16Program()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6c dbcc1
	    reg_t = 0;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (reg_t)
	    {
		goto dbcc6;
	    }
	    else
	    {
		goto dbcc2;
	    }
	dbcc2:
	    // 46 dbcc2
	    reg_aob = reg_au;
	    reg_alub = reg_da[ry_index];
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    // 175 dbcc3
	    reg_t = testbit(reg_isr, 2);
	    reg_pc = reg_au;
	    reg_au = reg_at + 2;
	    runALU(AluAdd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    if (reg_t)
	    {
		goto dbcc5;
	    }
	    else
	    {
		goto dbcc4;
	    }
	dbcc6:
	    // c6 dbcc6
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    setTrace();
	    // c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dbcc4:
	    // c7 dbcc4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dbcc5:
	    // 7 dbcc5
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    setTrace();
	goto dbcc4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSfAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 0;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto morw2;
	sccb2:
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSfAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 0;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto morw2;
	sccb2:
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSfPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 0;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto morw2;
	sccb2:
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSfDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 0;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto morw2;
	sccb2:
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSfDaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 0;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto morw2;
	sccb2:
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSfAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 0;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto morw2;
	sccb2:
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSfAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 0;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto morw2;
	sccb2:
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kShiDsProgram()
{
    unknownInstr();
}

void m68kDbhiDsRel16Program()
{
    unknownInstr();
}

void m68kShiAisProgram()
{
    unknownInstr();
}

void m68kShiAipsProgram()
{
    unknownInstr();
}

void m68kShiPaisProgram()
{
    unknownInstr();
}

void m68kShiDasProgram()
{
    unknownInstr();
}

void m68kShiDaisProgram()
{
    unknownInstr();
}

void m68kShiAdr16Program()
{
    unknownInstr();
}

void m68kShiAdr32Program()
{
    unknownInstr();
}

void m68kSlsDsProgram()
{
    unknownInstr();
}

void m68kDblsDsRel16Program()
{
    unknownInstr();
}

void m68kSlsAisProgram()
{
    unknownInstr();
}

void m68kSlsAipsProgram()
{
    unknownInstr();
}

void m68kSlsPaisProgram()
{
    unknownInstr();
}

void m68kSlsDasProgram()
{
    unknownInstr();
}

void m68kSlsDaisProgram()
{
    unknownInstr();
}

void m68kSlsAdr16Program()
{
    unknownInstr();
}

void m68kSlsAdr32Program()
{
    unknownInstr();
}

void m68kSccDsProgram()
{
    unknownInstr();
}

void m68kDbccDsRel16Program()
{
    unknownInstr();
}

void m68kSccAisProgram()
{
    unknownInstr();
}

void m68kSccAipsProgram()
{
    unknownInstr();
}

void m68kSccPaisProgram()
{
    unknownInstr();
}

void m68kSccDasProgram()
{
    unknownInstr();
}

void m68kSccDaisProgram()
{
    unknownInstr();
}

void m68kSccAdr16Program()
{
    unknownInstr();
}

void m68kSccAdr32Program()
{
    unknownInstr();
}

void m68kScsDsProgram()
{
    unknownInstr();
}

void m68kDbcsDsRel16Program()
{
    unknownInstr();
}

void m68kScsAisProgram()
{
    unknownInstr();
}

void m68kScsAipsProgram()
{
    unknownInstr();
}

void m68kScsPaisProgram()
{
    unknownInstr();
}

void m68kScsDasProgram()
{
    unknownInstr();
}

void m68kScsDaisProgram()
{
    unknownInstr();
}

void m68kScsAdr16Program()
{
    unknownInstr();
}

void m68kScsAdr32Program()
{
    unknownInstr();
}

void m68kSneDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 384 sccr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = testbit(reg_sr, 2) ? 0 : 1;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccr2;
	    }
	    else
	    {
		goto roaw2;
	    }
	roaw2:
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	sccr2:
	    // cb sccr2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kDbneDsRel16Program()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6c dbcc1
	    reg_t = testbit(reg_sr, 2) ? 0 : 1;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (reg_t)
	    {
		goto dbcc6;
	    }
	    else
	    {
		goto dbcc2;
	    }
	dbcc2:
	    // 46 dbcc2
	    reg_aob = reg_au;
	    reg_alub = reg_da[ry_index];
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    // 175 dbcc3
	    reg_t = testbit(reg_isr, 2);
	    reg_pc = reg_au;
	    reg_au = reg_at + 2;
	    runALU(AluAdd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    if (reg_t)
	    {
		goto dbcc5;
	    }
	    else
	    {
		goto dbcc4;
	    }
	dbcc6:
	    // c6 dbcc6
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    setTrace();
	    // c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dbcc4:
	    // c7 dbcc4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dbcc5:
	    // 7 dbcc5
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    setTrace();
	goto dbcc4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSneAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = testbit(reg_sr, 2) ? 0 : 1;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto morw2;
	sccb2:
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSneAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = testbit(reg_sr, 2) ? 0 : 1;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto morw2;
	sccb2:
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSnePaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = testbit(reg_sr, 2) ? 0 : 1;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto morw2;
	sccb2:
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSneDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = testbit(reg_sr, 2) ? 0 : 1;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto morw2;
	sccb2:
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSneDaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = testbit(reg_sr, 2) ? 0 : 1;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto morw2;
	sccb2:
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSneAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = testbit(reg_sr, 2) ? 0 : 1;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto morw2;
	sccb2:
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSneAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = testbit(reg_sr, 2) ? 0 : 1;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto morw2;
	sccb2:
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSeqDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 384 sccr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = testbit(reg_sr, 2) ? 1 : 0;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccr2;
	    }
	    else
	    {
		goto roaw2;
	    }
	roaw2:
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	sccr2:
	    // cb sccr2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kDbeqDsRel16Program()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6c dbcc1
	    reg_t = testbit(reg_sr, 2) ? 1 : 0;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (reg_t)
	    {
		goto dbcc6;
	    }
	    else
	    {
		goto dbcc2;
	    }
	dbcc2:
	    // 46 dbcc2
	    reg_aob = reg_au;
	    reg_alub = reg_da[ry_index];
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    // 175 dbcc3
	    reg_t = testbit(reg_isr, 2);
	    reg_pc = reg_au;
	    reg_au = reg_at + 2;
	    runALU(AluAdd, reg_alub, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    if (reg_t)
	    {
		goto dbcc5;
	    }
	    else
	    {
		goto dbcc4;
	    }
	dbcc6:
	    // c6 dbcc6
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    setTrace();
	    // c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dbcc4:
	    // c7 dbcc4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dbcc5:
	    // 7 dbcc5
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    setTrace();
	goto dbcc4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSeqAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = testbit(reg_sr, 2) ? 1 : 0;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto morw2;
	sccb2:
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSeqAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = testbit(reg_sr, 2) ? 1 : 0;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto morw2;
	sccb2:
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSeqPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = testbit(reg_sr, 2) ? 1 : 0;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto morw2;
	sccb2:
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSeqDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = testbit(reg_sr, 2) ? 1 : 0;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto morw2;
	sccb2:
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSeqDaisProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = testbit(reg_sr, 2) ? 1 : 0;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto morw2;
	sccb2:
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSeqAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = testbit(reg_sr, 2) ? 1 : 0;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto morw2;
	sccb2:
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSeqAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluOrByte, reg_dt, reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = testbit(reg_sr, 2) ? 1 : 0;
	    reg_pc = reg_au;
	    runALU(AluAndByte, 0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 4f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto morw2;
	sccb2:
	    // cf sccb2
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_aluo, 0xFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSvcDsProgram()
{
    unknownInstr();
}

void m68kDbvcDsRel16Program()
{
    unknownInstr();
}

void m68kSvcAisProgram()
{
    unknownInstr();
}

void m68kSvcAipsProgram()
{
    unknownInstr();
}

void m68kSvcPaisProgram()
{
    unknownInstr();
}

void m68kSvcDasProgram()
{
    unknownInstr();
}

void m68kSvcDaisProgram()
{
    unknownInstr();
}

void m68kSvcAdr16Program()
{
    unknownInstr();
}

void m68kSvcAdr32Program()
{
    unknownInstr();
}

void m68kSvsDsProgram()
{
    unknownInstr();
}

void m68kDbvsDsRel16Program()
{
    unknownInstr();
}

void m68kSvsAisProgram()
{
    unknownInstr();
}

void m68kSvsAipsProgram()
{
    unknownInstr();
}

void m68kSvsPaisProgram()
{
    unknownInstr();
}

void m68kSvsDasProgram()
{
    unknownInstr();
}

void m68kSvsDaisProgram()
{
    unknownInstr();
}

void m68kSvsAdr16Program()
{
    unknownInstr();
}

void m68kSvsAdr32Program()
{
    unknownInstr();
}

void m68kSplDsProgram()
{
    unknownInstr();
}

void m68kDbplDsRel16Program()
{
    unknownInstr();
}

void m68kSplAisProgram()
{
    unknownInstr();
}

void m68kSplAipsProgram()
{
    unknownInstr();
}

void m68kSplPaisProgram()
{
    unknownInstr();
}

void m68kSplDasProgram()
{
    unknownInstr();
}

void m68kSplDaisProgram()
{
    unknownInstr();
}

void m68kSplAdr16Program()
{
    unknownInstr();
}

void m68kSplAdr32Program()
{
    unknownInstr();
}

void m68kSmiDsProgram()
{
    unknownInstr();
}

void m68kDbmiDsRel16Program()
{
    unknownInstr();
}

void m68kSmiAisProgram()
{
    unknownInstr();
}

void m68kSmiAipsProgram()
{
    unknownInstr();
}

void m68kSmiPaisProgram()
{
    unknownInstr();
}

void m68kSmiDasProgram()
{
    unknownInstr();
}

void m68kSmiDaisProgram()
{
    unknownInstr();
}

void m68kSmiAdr16Program()
{
    unknownInstr();
}

void m68kSmiAdr32Program()
{
    unknownInstr();
}

void m68kSgeDsProgram()
{
    unknownInstr();
}

void m68kDbgeDsRel16Program()
{
    unknownInstr();
}

void m68kSgeAisProgram()
{
    unknownInstr();
}

void m68kSgeAipsProgram()
{
    unknownInstr();
}

void m68kSgePaisProgram()
{
    unknownInstr();
}

void m68kSgeDasProgram()
{
    unknownInstr();
}

void m68kSgeDaisProgram()
{
    unknownInstr();
}

void m68kSgeAdr16Program()
{
    unknownInstr();
}

void m68kSgeAdr32Program()
{
    unknownInstr();
}

void m68kSltDsProgram()
{
    unknownInstr();
}

void m68kDbltDsRel16Program()
{
    unknownInstr();
}

void m68kSltAisProgram()
{
    unknownInstr();
}

void m68kSltAipsProgram()
{
    unknownInstr();
}

void m68kSltPaisProgram()
{
    unknownInstr();
}

void m68kSltDasProgram()
{
    unknownInstr();
}

void m68kSltDaisProgram()
{
    unknownInstr();
}

void m68kSltAdr16Program()
{
    unknownInstr();
}

void m68kSltAdr32Program()
{
    unknownInstr();
}

void m68kSgtDsProgram()
{
    unknownInstr();
}

void m68kDbgtDsRel16Program()
{
    unknownInstr();
}

void m68kSgtAisProgram()
{
    unknownInstr();
}

void m68kSgtAipsProgram()
{
    unknownInstr();
}

void m68kSgtPaisProgram()
{
    unknownInstr();
}

void m68kSgtDasProgram()
{
    unknownInstr();
}

void m68kSgtDaisProgram()
{
    unknownInstr();
}

void m68kSgtAdr16Program()
{
    unknownInstr();
}

void m68kSgtAdr32Program()
{
    unknownInstr();
}

void m68kSleDsProgram()
{
    unknownInstr();
}

void m68kDbleDsRel16Program()
{
    unknownInstr();
}

void m68kSleAisProgram()
{
    unknownInstr();
}

void m68kSleAipsProgram()
{
    unknownInstr();
}

void m68kSlePaisProgram()
{
    unknownInstr();
}

void m68kSleDasProgram()
{
    unknownInstr();
}

void m68kSleDaisProgram()
{
    unknownInstr();
}

void m68kSleAdr16Program()
{
    unknownInstr();
}

void m68kSleAdr32Program()
{
    unknownInstr();
}

void m68kBraRel16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 68 bbcw1
	    reg_t = 1;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (reg_t)
	    {
		goto bbci3;
	    }
	    else
	    {
		goto bbcw3;
	    }
	bbcw3:
	    // 85 bbcw3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setTrace();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	goto b;
	bbci3:
	    // c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	goto b;
	b:
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBraRel8Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 308 bbci1
	    reg_t = 1;
	    reg_au = reg_pc + ext32(reg_ftu);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (reg_t)
	    {
		goto bbci3;
	    }
	    else
	    {
		goto bbci2;
	    }
	bbci2:
	    // 45 bbci2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setTrace();
	goto b;
	bbci3:
	    // c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	goto b;
	b:
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBsrRel16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // a9 bsrw1
	    reg_at = reg_au;
	    runALU(AluAnd, reg_au, 0xFFFF);
	    reg_au = reg_da[reg_sp] - 4;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 10e bsrw2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_at);
	    reg_da[reg_sp] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    // aa bsrw3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBsrRel8Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 89 bsri1
	    reg_at = reg_pc;
	    reg_au = reg_da[reg_sp] - 4;
	    runALU(AluAnd, reg_pc, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 102 bsri2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_at);
	    reg_da[reg_sp] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    // a8 bsri3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = ext32(reg_ftu) + reg_pc;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBhiRel16Program()
{
    unknownInstr();
}

void m68kBhiRel8Program()
{
    unknownInstr();
}

void m68kBlsRel16Program()
{
    unknownInstr();
}

void m68kBlsRel8Program()
{
    unknownInstr();
}

void m68kBccRel16Program()
{
    unknownInstr();
}

void m68kBccRel8Program()
{
    unknownInstr();
}

void m68kBcsRel16Program()
{
    unknownInstr();
}

void m68kBcsRel8Program()
{
    unknownInstr();
}

void m68kBneRel16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 68 bbcw1
	    reg_t = testbit(reg_sr, 2) ? 0 : 1;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (reg_t)
	    {
		goto bbci3;
	    }
	    else
	    {
		goto bbcw3;
	    }
	bbcw3:
	    // 85 bbcw3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setTrace();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	goto b;
	bbci3:
	    // c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	goto b;
	b:
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBneRel8Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 308 bbci1
	    reg_t = testbit(reg_sr, 2) ? 0 : 1;
	    reg_au = reg_pc + ext32(reg_ftu);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (reg_t)
	    {
		goto bbci3;
	    }
	    else
	    {
		goto bbci2;
	    }
	bbci2:
	    // 45 bbci2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setTrace();
	goto b;
	bbci3:
	    // c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	goto b;
	b:
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBeqRel16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 68 bbcw1
	    reg_t = testbit(reg_sr, 2) ? 1 : 0;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (reg_t)
	    {
		goto bbci3;
	    }
	    else
	    {
		goto bbcw3;
	    }
	bbcw3:
	    // 85 bbcw3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setTrace();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	goto b;
	bbci3:
	    // c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	goto b;
	b:
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBeqRel8Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 308 bbci1
	    reg_t = testbit(reg_sr, 2) ? 1 : 0;
	    reg_au = reg_pc + ext32(reg_ftu);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (reg_t)
	    {
		goto bbci3;
	    }
	    else
	    {
		goto bbci2;
	    }
	bbci2:
	    // 45 bbci2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setTrace();
	goto b;
	bbci3:
	    // c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	goto b;
	b:
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBvcRel16Program()
{
    unknownInstr();
}

void m68kBvcRel8Program()
{
    unknownInstr();
}

void m68kBvsRel16Program()
{
    unknownInstr();
}

void m68kBvsRel8Program()
{
    unknownInstr();
}

void m68kBplRel16Program()
{
    unknownInstr();
}

void m68kBplRel8Program()
{
    unknownInstr();
}

void m68kBmiRel16Program()
{
    unknownInstr();
}

void m68kBmiRel8Program()
{
    unknownInstr();
}

void m68kBgeRel16Program()
{
    unknownInstr();
}

void m68kBgeRel8Program()
{
    unknownInstr();
}

void m68kBltRel16Program()
{
    unknownInstr();
}

void m68kBltRel8Program()
{
    unknownInstr();
}

void m68kBgtRel16Program()
{
    unknownInstr();
}

void m68kBgtRel8Program()
{
    unknownInstr();
}

void m68kBleRel16Program()
{
    unknownInstr();
}

void m68kBleRel8Program()
{
    unknownInstr();
}

void m68kMoveqImm8oDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 23b rlql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_da[rx_index] = ext32(reg_ftu);
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_ftu, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrByteDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluOrByte, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrByteAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOrByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrByteAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOrByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrBytePaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOrByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrByteDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOrByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrByteDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOrByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrByteAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOrByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrByteAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOrByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrByteDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOrByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrByteDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOrByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrByteImm8DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluOrByte, reg_dt, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrWordDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluOr, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrWordAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOr, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrWordAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOr, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrWordPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOr, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrWordDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOr, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrWordDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOr, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrWordAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOr, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrWordAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOr, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrWordDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOr, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrWordDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOr, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrWordImm16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluOr, reg_dt, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrLongDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluOr, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    runALU(AluOr, high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrLongAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOr, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluOr, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrLongAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOr, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluOr, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrLongPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOr, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluOr, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrLongDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOr, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluOr, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrLongDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOr, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluOr, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrLongAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOr, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluOr, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrLongAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOr, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluOr, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrLongDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOr, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluOr, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrLongDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluOr, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluOr, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrLongImm32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluOr, reg_dt, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    runALU(AluOr, high16(reg_dt), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kDivuWordDsDdProgram()
{
    unknownInstr();
}

void m68kDivuWordAisDdProgram()
{
    unknownInstr();
}

void m68kDivuWordAipsDdProgram()
{
    unknownInstr();
}

void m68kDivuWordPaisDdProgram()
{
    unknownInstr();
}

void m68kDivuWordDasDdProgram()
{
    unknownInstr();
}

void m68kDivuWordDaisDdProgram()
{
    unknownInstr();
}

void m68kDivuWordAdr16DdProgram()
{
    unknownInstr();
}

void m68kDivuWordAdr32DdProgram()
{
    unknownInstr();
}

void m68kDivuWordDpcDdProgram()
{
    unknownInstr();
}

void m68kDivuWordDpciDdProgram()
{
    unknownInstr();
}

void m68kDivuWordImm16DdProgram()
{
    unknownInstr();
}

void m68kSbcdDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1cd rbrb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluSbcdByte, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrXNZVCU);
	    // 11b rbrb2
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 238 rbrb3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSbcdPaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 107 asbb1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 135 asbb2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 136 asbb3
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 4e asbb4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_at = reg_au;
	    reg_da[rx_index] = reg_au;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 40 asbb5
	    reg_aob = reg_pc;
	    runALU(AluSbcdByte, reg_alub, reg_dbin);
	    updateCCR(CcrXNZVCU);
	    // 113 asbb6
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrByteDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrByteDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrByteDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrByteDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrByteDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrByteDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrByteDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOrByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrWordDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrWordDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrWordDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrWordDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrWordDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrWordDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrWordDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrLongDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluOr, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrLongDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluOr, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrLongDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluOr, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrLongDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluOr, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrLongDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluOr, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrLongDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluOr, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kOrLongDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluOr, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluOr, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kDivsWordDsDdProgram()
{
    unknownInstr();
}

void m68kDivsWordAisDdProgram()
{
    unknownInstr();
}

void m68kDivsWordAipsDdProgram()
{
    unknownInstr();
}

void m68kDivsWordPaisDdProgram()
{
    unknownInstr();
}

void m68kDivsWordDasDdProgram()
{
    unknownInstr();
}

void m68kDivsWordDaisDdProgram()
{
    unknownInstr();
}

void m68kDivsWordAdr16DdProgram()
{
    unknownInstr();
}

void m68kDivsWordAdr32DdProgram()
{
    unknownInstr();
}

void m68kDivsWordDpcDdProgram()
{
    unknownInstr();
}

void m68kDivsWordDpciDdProgram()
{
    unknownInstr();
}

void m68kDivsWordImm16DdProgram()
{
    unknownInstr();
}

void m68kSubByteDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluSubByte, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubByteAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSubByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubByteAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSubByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubBytePaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSubByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubByteDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSubByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubByteDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSubByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubByteAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSubByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubByteAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSubByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubByteDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSubByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubByteDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSubByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubByteImm8DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluSubByte, reg_dt, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubWordDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluSub, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubWordAsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluSub, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubWordAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubWordAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubWordPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubWordDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubWordDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubWordAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubWordAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubWordDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubWordDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubWordImm16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluSub, reg_dt, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubLongDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluSub, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    runALU(AluSubc, high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubLongAsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluSub, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    runALU(AluSubc, high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubLongAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluSubc, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubLongAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluSubc, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubLongPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluSubc, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubLongDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluSubc, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubLongDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluSubc, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubLongAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluSubc, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubLongAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluSubc, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubLongDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluSubc, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubLongDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluSubc, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubLongImm32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluSub, reg_dt, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    runALU(AluSubc, high16(reg_dt), high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaWordDsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c9 rorm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluSub, reg_da[ry_index], reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluSubc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaWordAsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c9 rorm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluSub, reg_da[ry_index], reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluSubc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaWordAisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluSubc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaWordAipsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluSubc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaWordPaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluSubc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaWordDasAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluSubc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaWordDaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluSubc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaWordAdr16AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluSubc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaWordAdr32AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluSubc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaWordDpcAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluSubc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaWordDpciAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluSubc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaWordImm16AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c9 rorm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluSub, reg_dt, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluSubc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubxByteDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluSubxByte, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrXNZVCU);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubxBytePaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 10f asxw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 131 asxw2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 132 asxw3
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 4a asxw4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_at = reg_au;
	    reg_da[rx_index] = reg_au;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 65 asxw5
	    reg_aob = reg_pc;
	    reg_au = reg_at;
	    runALU(AluSubxByte, reg_alub, reg_dbin);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubByteDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubByteDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubByteDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubByteDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubByteDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubByteDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubByteDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSubByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubxWordDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluSubx, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrXNZVCU);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubxWordPaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 10f asxw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 131 asxw2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 132 asxw3
	    reg_au = reg_da[rx_index] - 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 4a asxw4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_at = reg_au;
	    reg_da[rx_index] = reg_au;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 65 asxw5
	    reg_aob = reg_pc;
	    reg_au = reg_at;
	    runALU(AluSubx, reg_alub, reg_dbin);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubWordDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubWordDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubWordDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubWordDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubWordDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubWordDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubWordDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubxLongDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluSubx, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrXNZVCU);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    runALU(AluSubc, high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubxLongPaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 10b asxl1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 48 asxl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_au = reg_au - 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 139 asxl3
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 13a asxl4
	    reg_au = reg_da[rx_index] - 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 4c asxl5
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_au = reg_au - 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 47 asxl6
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluSubx, reg_aluo, reg_dbin);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 61 asxl7
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = ext32(reg_dbin);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 62 asxl8
	    reg_aob = reg_pc;
	    reg_au = reg_at;
	    runALU(AluSubc, reg_alub, reg_dbin);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubLongDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubLongDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubLongDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubLongDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubLongDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubLongDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubLongDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluSub, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluSubc, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaLongDsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluSub, reg_da[ry_index], reg_da[rx_index]);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    runALU(AluSubc, high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaLongAsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluSub, reg_da[ry_index], reg_da[rx_index]);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    runALU(AluSubc, high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaLongAisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluSubc, reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaLongAipsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluSubc, reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaLongPaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluSubc, reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaLongDasAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluSubc, reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaLongDaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluSubc, reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaLongAdr16AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluSubc, reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaLongAdr32AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluSubc, reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaLongDpcAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluSubc, reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaLongDpciAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluSubc, reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kSubaLongImm32AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluSub, reg_dt, reg_da[rx_index]);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    runALU(AluSubc, high16(reg_dt), high16(reg_da[rx_index]));
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpByteDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1d1 cprw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAndByte, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpByteAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAndByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpByteAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAndByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpBytePaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAndByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpByteDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAndByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpByteDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAndByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpByteAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAndByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpByteAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAndByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpByteDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAndByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpByteDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAndByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpByteImm8DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1d1 cprw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluAndByte, reg_dt, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpWordDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1d1 cprw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAnd, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpWordAsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1d1 cprw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAnd, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpWordAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpWordAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpWordPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpWordDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpWordDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpWordAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpWordAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpWordDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpWordDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpWordImm16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1d1 cprw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluAnd, reg_dt, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpLongDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1d5 cprl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAnd, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 173 cprl2
	    runALU(AluAnd, high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpLongAsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1d5 cprl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAnd, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 173 cprl2
	    runALU(AluAnd, high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpLongAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 172 cpml2
	    runALU(AluAnd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpLongAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 172 cpml2
	    runALU(AluAnd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpLongPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 172 cpml2
	    runALU(AluAnd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpLongDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 172 cpml2
	    runALU(AluAnd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpLongDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 172 cpml2
	    runALU(AluAnd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpLongAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 172 cpml2
	    runALU(AluAnd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpLongAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 172 cpml2
	    runALU(AluAnd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpLongDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 172 cpml2
	    runALU(AluAnd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpLongDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 172 cpml2
	    runALU(AluAnd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpLongImm32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1d5 cprl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluAnd, reg_dt, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 173 cprl2
	    runALU(AluAnd, high16(reg_dt), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaWordDsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1d9 cprm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluSub, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 174 cprm2
	    runALU(AluAdd, high16(reg_at), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaWordAsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1d9 cprm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluSub, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 174 cprm2
	    runALU(AluAdd, high16(reg_at), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaWordAisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cf cpmm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 174 cprm2
	    runALU(AluAdd, high16(reg_at), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaWordAipsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cf cpmm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 174 cprm2
	    runALU(AluAdd, high16(reg_at), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaWordPaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cf cpmm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 174 cprm2
	    runALU(AluAdd, high16(reg_at), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaWordDasAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cf cpmm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 174 cprm2
	    runALU(AluAdd, high16(reg_at), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaWordDaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cf cpmm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 174 cprm2
	    runALU(AluAdd, high16(reg_at), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaWordAdr16AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cf cpmm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 174 cprm2
	    runALU(AluAdd, high16(reg_at), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaWordAdr32AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cf cpmm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 174 cprm2
	    runALU(AluAdd, high16(reg_at), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaWordDpcAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cf cpmm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 174 cprm2
	    runALU(AluAdd, high16(reg_at), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaWordDpciAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cf cpmm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 174 cprm2
	    runALU(AluAdd, high16(reg_at), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaWordImm16AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1d9 cprm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluSub, reg_dt, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 174 cprm2
	    runALU(AluAdd, high16(reg_at), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorByteDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 100 roaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluAbcdByte, reg_da[rx_index], reg_da[ry_index]);
	    updateCCR(CcrXNZVCU);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpmByteAipsAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6b cmmw1
	    reg_aob = reg_da[ry_index];
	    reg_pc = reg_au;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 86 cmmw2
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 122 cmmw3
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 170 cmmw4
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAbcdByte, reg_aluo, reg_dbin);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorByteDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorByteDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorByteDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorByteDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorByteDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorByteDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorByteDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorWordDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 100 roaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluAbcd, reg_da[rx_index], reg_da[ry_index]);
	    updateCCR(CcrXNZVCU);
	    // 8b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpmWordAipsAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6b cmmw1
	    reg_aob = reg_da[ry_index];
	    reg_pc = reg_au;
	    reg_au = reg_da[ry_index] + 2;
	    // 86 cmmw2
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 122 cmmw3
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 170 cmmw4
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAbcd, reg_aluo, reg_dbin);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorWordDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorWordDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorWordDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorWordDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorWordDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorWordDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorWordDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorLongDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 10c roal1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    runALU(AluAbcd, reg_da[rx_index], reg_da[ry_index]);
	    updateCCR(CcrXNZVCU);
	    // 259 roal2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25a roal3
	    runALU(AluAdd, high16(reg_da[rx_index]), high16(reg_da[ry_index]));
	    updateCCR(CcrXNZVCU);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpmLongAipsAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6f cmml1
	    reg_aob = reg_da[ry_index];
	    reg_pc = reg_au;
	    reg_au = reg_da[ry_index] + 2;
	    // 8e cmml2
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 154 cmml3
	    reg_aob = reg_at;
	    reg_alub = reg_dbin;
	    reg_da[ry_index] = reg_au;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 12e cmml4
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_da[rx_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 155 cmml5
	    reg_aob = reg_au;
	    reg_alue = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 156 cmml6
	    reg_aob = reg_pc;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAbcd, reg_aluo, reg_dbin);
	    updateCCR(CcrXNZVCU);
	    // 157 cmml7
	    reg_ird = reg_ir;
	    setIntState();
	    runALU(AluAdd, reg_alub, reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorLongDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorLongDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorLongDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorLongDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorLongDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorLongDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kEorLongDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaLongDsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1d5 cprl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluSub, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 173 cprl2
	    runALU(AluAdd, high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaLongAsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1d5 cprl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluSub, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 173 cprl2
	    runALU(AluAdd, high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaLongAisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 172 cpml2
	    runALU(AluAdd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaLongAipsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 172 cpml2
	    runALU(AluAdd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaLongPaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 172 cpml2
	    runALU(AluAdd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaLongDasAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 172 cpml2
	    runALU(AluAdd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaLongDaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 172 cpml2
	    runALU(AluAdd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaLongAdr16AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 172 cpml2
	    runALU(AluAdd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaLongAdr32AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 172 cpml2
	    runALU(AluAdd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaLongDpcAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 172 cpml2
	    runALU(AluAdd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaLongDpciAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluSub, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 172 cpml2
	    runALU(AluAdd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kCmpaLongImm32AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1d5 cprl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluSub, reg_dt, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 173 cprl2
	    runALU(AluAdd, high16(reg_dt), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndByteDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAndByte, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndByteAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAndByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndByteAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAndByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndBytePaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAndByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndByteDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAndByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndByteDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAndByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndByteAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAndByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndByteAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAndByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndByteDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAndByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndByteDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAndByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndByteImm8DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluAndByte, reg_dt, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndWordDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAnd, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndWordAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndWordAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndWordPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndWordDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndWordDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndWordAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndWordAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndWordDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndWordDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndWordImm16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluAnd, reg_dt, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndLongDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAnd, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    runALU(AluAnd, high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndLongAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAnd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndLongAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAnd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndLongPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAnd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndLongDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAnd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndLongDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAnd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndLongAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAnd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndLongAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAnd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndLongDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAnd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndLongDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAnd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAnd, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndLongImm32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluAnd, reg_dt, reg_da[rx_index]);
	    updateCCR(CcrNZVC);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    runALU(AluAnd, high16(reg_dt), high16(reg_da[rx_index]));
	    updateCCR(CcrNZVCU);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMuluWordDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 15b mulr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_da[ry_index];
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : testbit(reg_alue, 1) ? 1 : 2;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMu, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm3:
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	goto mulm4;
	mulm6:
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMuluWordAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : testbit(reg_alue, 1) ? 1 : 2;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMu, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm3:
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	goto mulm4;
	mulm6:
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMuluWordAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : testbit(reg_alue, 1) ? 1 : 2;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMu, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm3:
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	goto mulm4;
	mulm6:
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMuluWordPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : testbit(reg_alue, 1) ? 1 : 2;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMu, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm3:
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	goto mulm4;
	mulm6:
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMuluWordDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : testbit(reg_alue, 1) ? 1 : 2;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMu, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm3:
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	goto mulm4;
	mulm6:
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMuluWordDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : testbit(reg_alue, 1) ? 1 : 2;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMu, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm3:
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	goto mulm4;
	mulm6:
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMuluWordAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : testbit(reg_alue, 1) ? 1 : 2;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMu, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm3:
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	goto mulm4;
	mulm6:
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMuluWordAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : testbit(reg_alue, 1) ? 1 : 2;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMu, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm3:
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	goto mulm4;
	mulm6:
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMuluWordDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : testbit(reg_alue, 1) ? 1 : 2;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMu, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm3:
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	goto mulm4;
	mulm6:
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMuluWordDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : testbit(reg_alue, 1) ? 1 : 2;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMu, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm3:
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	goto mulm4;
	mulm6:
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMuluWordImm16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15b mulr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dt;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : testbit(reg_alue, 1) ? 1 : 2;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMu, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm3:
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	goto mulm4;
	mulm6:
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAbcdDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1cd rbrb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAbcdByte, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrXNZVCU);
	    // 11b rbrb2
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 238 rbrb3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAbcdPaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 107 asbb1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 135 asbb2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 136 asbb3
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 4e asbb4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_at = reg_au;
	    reg_da[rx_index] = reg_au;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 40 asbb5
	    reg_aob = reg_pc;
	    runALU(AluAbcdByte, reg_alub, reg_dbin);
	    updateCCR(CcrXNZVCU);
	    // 113 asbb6
	    reg_au = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndByteDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndByteDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndByteDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndByteDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndByteDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndByteDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndByteDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAndByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kExgDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e3 exge1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[rx_index];
	    reg_au = reg_da[ry_index];
	    // 231 exge2
	    reg_da[rx_index] = reg_au;
	    reg_da[ry_index] = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kExgAdAsProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e3 exge1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[rx_index];
	    reg_au = reg_da[ry_index];
	    // 231 exge2
	    reg_da[rx_index] = reg_au;
	    reg_da[ry_index] = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndWordDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndWordDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndWordDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndWordDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndWordDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndWordDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndWordDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kExgDdAsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e3 exge1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[rx_index];
	    reg_au = reg_da[ry_index];
	    // 231 exge2
	    reg_da[rx_index] = reg_au;
	    reg_da[ry_index] = reg_at;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndLongDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndLongDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndLongDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndLongDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndLongDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndLongDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAndLongDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAnd, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMulsWordDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 15b mulr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_da[ry_index];
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : ((reg_alue & 0x3) == 1) ? 1 : ((reg_alue & 0x3) == 2) ? 2 : 3;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMs, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else if (reg_t == 2)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	     }
	mulm5:
	    // a0 mulm5
	    runALU(AluSub, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	goto mulm4;
	mulm6:
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	mulm3:
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	goto mulm4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMulsWordAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : ((reg_alue & 0x3) == 1) ? 1 : ((reg_alue & 0x3) == 2) ? 2 : 3;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMs, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else if (reg_t == 2)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	     }
	mulm5:
	    // a0 mulm5
	    runALU(AluSub, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	goto mulm4;
	mulm6:
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	mulm3:
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	goto mulm4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMulsWordAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : ((reg_alue & 0x3) == 1) ? 1 : ((reg_alue & 0x3) == 2) ? 2 : 3;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMs, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else if (reg_t == 2)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	     }
	mulm5:
	    // a0 mulm5
	    runALU(AluSub, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	goto mulm4;
	mulm6:
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	mulm3:
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	goto mulm4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMulsWordPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : ((reg_alue & 0x3) == 1) ? 1 : ((reg_alue & 0x3) == 2) ? 2 : 3;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMs, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else if (reg_t == 2)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	     }
	mulm5:
	    // a0 mulm5
	    runALU(AluSub, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	goto mulm4;
	mulm6:
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    nextTrace();
	    return;
	mulm3:
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	goto mulm4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMulsWordDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : ((reg_alue & 0x3) == 1) ? 1 : ((reg_alue & 0x3) == 2) ? 2 : 3;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMs, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else if (reg_t == 2)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	     }
	mulm5:
	    // a0 mulm5
	    runALU(AluSub, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	goto mulm4;
	mulm6:
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	mulm3:
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	goto mulm4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMulsWordDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 14;
	}
	break;
	case 14:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : ((reg_alue & 0x3) == 1) ? 1 : ((reg_alue & 0x3) == 2) ? 2 : 3;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMs, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else if (reg_t == 2)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	     }
	mulm5:
	    // a0 mulm5
	    runALU(AluSub, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	goto mulm4;
	mulm6:
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    nextTrace();
	    return;
	mulm3:
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	goto mulm4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMulsWordAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : ((reg_alue & 0x3) == 1) ? 1 : ((reg_alue & 0x3) == 2) ? 2 : 3;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMs, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else if (reg_t == 2)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	     }
	mulm5:
	    // a0 mulm5
	    runALU(AluSub, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	goto mulm4;
	mulm6:
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	mulm3:
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	goto mulm4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMulsWordAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : ((reg_alue & 0x3) == 1) ? 1 : ((reg_alue & 0x3) == 2) ? 2 : 3;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMs, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else if (reg_t == 2)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	     }
	mulm5:
	    // a0 mulm5
	    runALU(AluSub, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	goto mulm4;
	mulm6:
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    nextTrace();
	    return;
	mulm3:
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	goto mulm4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMulsWordDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : ((reg_alue & 0x3) == 1) ? 1 : ((reg_alue & 0x3) == 2) ? 2 : 3;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMs, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else if (reg_t == 2)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	     }
	mulm5:
	    // a0 mulm5
	    runALU(AluSub, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	goto mulm4;
	mulm6:
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	mulm3:
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	goto mulm4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMulsWordDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 14;
	}
	break;
	case 14:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : ((reg_alue & 0x3) == 1) ? 1 : ((reg_alue & 0x3) == 2) ? 2 : 3;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMs, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else if (reg_t == 2)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	     }
	mulm5:
	    // a0 mulm5
	    runALU(AluSub, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	goto mulm4;
	mulm6:
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    nextTrace();
	    return;
	mulm3:
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	goto mulm4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kMulsWordImm16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15b mulr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dt;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, reg_da[rx_index], 0x0000);
	    updateCCR(CcrNZVC);
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : ((reg_alue & 0x3) == 1) ? 1 : ((reg_alue & 0x3) == 2) ? 2 : 3;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLongMs, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else if (reg_t == 2)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	     }
	mulm5:
	    // a0 mulm5
	    runALU(AluSub, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	goto mulm4;
	mulm6:
	    // 20 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    runALU(AluAnd, reg_aluo, 0xFFFF);
	    updateCCR(CcrNZVCU);
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	mulm3:
	    // 60 mulm3
	    runALU(AluAdd, reg_alub, reg_aluo);
	    updateCCR(CcrNZVCU);
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	goto mulm4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddByteDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAddByte, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddByteAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAddByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddByteAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAddByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddBytePaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAddByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddByteDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAddByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddByteDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAddByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddByteAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAddByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddByteAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAddByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddByteDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAddByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddByteDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAddByte, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddByteImm8DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluAddByte, reg_dt, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddWordDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAdd, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddWordAsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAdd, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddWordAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddWordAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddWordPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddWordDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddWordDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddWordAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddWordAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddWordDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddWordDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddWordImm16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluAdd, reg_dt, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddLongDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAdd, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    runALU(AluAddc, high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddLongAsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAdd, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    runALU(AluAddc, high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddLongAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAddc, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddLongAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAddc, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddLongPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAddc, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddLongDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAddc, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddLongDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAddc, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddLongAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAddc, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddLongAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAddc, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddLongDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAddc, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddLongDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAddc, reg_alub, high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddLongImm32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluAdd, reg_dt, reg_da[rx_index]);
	    updateCCR(CcrXNZVC);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    runALU(AluAddc, high16(reg_dt), high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaWordDsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c9 rorm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAdd, reg_da[ry_index], reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluAddc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaWordAsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c9 rorm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAdd, reg_da[ry_index], reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluAddc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaWordAisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluAddc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaWordAipsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluAddc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaWordPaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluAddc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaWordDasAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluAddc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaWordDaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluAddc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaWordAdr16AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluAddc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaWordAdr32AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluAddc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaWordDpcAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluAddc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaWordDpciAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluAddc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaWordImm16AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c9 rorm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluAdd, reg_dt, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    runALU(AluAddc, high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddxByteDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAddxByte, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrXNZVCU);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddxBytePaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 10f asxw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 131 asxw2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 132 asxw3
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 4a asxw4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_at = reg_au;
	    reg_da[rx_index] = reg_au;
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 65 asxw5
	    reg_aob = reg_pc;
	    reg_au = reg_at;
	    runALU(AluAddxByte, reg_alub, reg_dbin);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddByteDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddByteDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddByteDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndByte, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddByteDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddByteDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddByteDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddByteDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndByte, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readByte();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAddByte, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeByte();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddxWordDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAddx, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrXNZVCU);
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddxWordPaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 10f asxw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 131 asxw2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 132 asxw3
	    reg_au = reg_da[rx_index] - 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 4a asxw4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_at = reg_au;
	    reg_da[rx_index] = reg_au;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 65 asxw5
	    reg_aob = reg_pc;
	    reg_au = reg_at;
	    runALU(AluAddx, reg_alub, reg_dbin);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddWordDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddWordDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddWordDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddWordDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddWordDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddWordDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddWordDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddxLongDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAddx, reg_da[ry_index], reg_da[rx_index]);
	    updateCCR(CcrXNZVCU);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    runALU(AluAddx, high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    updateCCR(CcrXNZVCU);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddxLongPaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 10b asxl1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 48 asxl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_au = reg_au - 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 139 asxl3
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 13a asxl4
	    reg_au = reg_da[rx_index] - 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 4c asxl5
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_au = reg_au - 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 47 asxl6
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAddx, reg_aluo, reg_dbin);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 61 asxl7
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = ext32(reg_dbin);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 62 asxl8
	    reg_aob = reg_pc;
	    reg_au = reg_at;
	    runALU(AluAddx, reg_alub, reg_dbin);
	    updateCCR(CcrXNZVCU);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddLongDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddLongDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddLongDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddLongDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddLongDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddLongDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddLongDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    runALU(AluAdd, reg_da[rx_index], reg_dbin);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    runALU(AluAddc, high16(reg_da[rx_index]), reg_alue);
	    updateCCR(CcrXNZVCU);
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaLongDsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAdd, reg_da[ry_index], reg_da[rx_index]);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    runALU(AluAddc, high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaLongAsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    runALU(AluAdd, reg_da[ry_index], reg_da[rx_index]);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    runALU(AluAddc, high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaLongAisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAddc, reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaLongAipsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAddc, reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaLongPaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAddc, reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaLongDasAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAddc, reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaLongDaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAddc, reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaLongAdr16AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAddc, reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaLongAdr32AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 8 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 5 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAddc, reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaLongDpcAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAddc, reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaLongDpciAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsl2;
	adsl2:
	    // c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 26 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    runALU(AluAdd, reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    runALU(AluAddc, reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddaLongImm32AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    runALU(AluAdd, reg_dt, reg_da[rx_index]);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    runALU(AluAddc, high16(reg_dt), high16(reg_da[rx_index]));
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAsrByteImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAndByte, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluAsrByte, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLsrByteImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAndByte, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluLsrByte, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxrByteImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAndBytex, high16(reg_da[ry_index]), 0xFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndBytex, reg_da[ry_index], 0xFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRorByteImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAndByte, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRorByte, reg_aluo);
	    updateCCR(CcrNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAsrByteDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAndByte, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluAsrByte, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLsrByteDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAndByte, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluLsrByte, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxrByteDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAndBytex, high16(reg_da[ry_index]), 0xFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndBytex, reg_da[ry_index], 0xFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRorByteDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAndByte, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRorByte, reg_aluo);
	    updateCCR(CcrNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAsrWordImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluAsr, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLsrWordImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluLsr, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxrWordImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAndx, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndx, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRorWordImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRor, reg_aluo);
	    updateCCR(CcrNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAsrWordDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluAsr, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLsrWordDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluLsr, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxrWordDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAndx, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndx, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRorWordDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRor, reg_aluo);
	    updateCCR(CcrNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAsrLongImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 385 srrl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl3:
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluAsrLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl4:
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLsrLongImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 385 srrl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl3:
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluLsrLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl4:
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxrLongImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 385 srrl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAndx, high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndx, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl3:
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl4:
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    runALU(AluAndx, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRorLongImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 385 srrl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl3:
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRorLong, reg_aluo);
	    updateCCR(CcrNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl4:
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAsrLongDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 386 sril1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl3:
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluAsrLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl4:
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLsrLongDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 386 sril1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl3:
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluLsrLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl4:
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxrLongDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 386 sril1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAndx, high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndx, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl3:
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRoxrLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl4:
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    runALU(AluAndx, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRorLongDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 386 sril1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl3:
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRorLong, reg_aluo);
	    updateCCR(CcrNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl4:
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAsrAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluAsr, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAsrAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluAsr, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAsrPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluAsr, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAsrDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluAsr, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAsrDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluAsr, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAsrAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluAsr, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAsrAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluAsr, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAslByteImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAndByte, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluAslByte, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLslByteImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAndByte, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluLslByte, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxlByteImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAndBytex, high16(reg_da[ry_index]), 0xFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndBytex, reg_da[ry_index], 0xFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRoxlByte, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRolByteImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAndByte, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRolByte, reg_aluo);
	    updateCCR(CcrNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAslByteDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAndByte, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluAslByte, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLslByteDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAndByte, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluLslByte, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxlByteDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAndBytex, high16(reg_da[ry_index]), 0xFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndBytex, reg_da[ry_index], 0xFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRoxlByte, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRolByteDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAndByte, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndByte, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRolByte, reg_aluo);
	    updateCCR(CcrNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAslWordImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluAsl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLslWordImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluLsl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxlWordImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAndx, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndx, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRoxl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRolWordImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRol, reg_aluo);
	    updateCCR(CcrNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAslWordDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluAsl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLslWordDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluLsl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxlWordDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAndx, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndx, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRoxl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRolWordDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRol, reg_aluo);
	    updateCCR(CcrNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAslLongImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 385 srrl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl3:
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluAslLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl4:
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLslLongImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 385 srrl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl3:
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluLslLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl4:
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    runALU(AluAnd, reg_aluo, reg_alue);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxlLongImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 385 srrl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAndx, high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndx, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl3:
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRoxlLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl4:
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    runALU(AluAndx, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRolLongImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 385 srrl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl3:
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRolLong, reg_aluo);
	    updateCCR(CcrNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl4:
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAslLongDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 386 sril1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl3:
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluAslLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl4:
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLslLongDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 386 sril1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl3:
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluLslLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl4:
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    runALU(AluAnd, reg_aluo, reg_alue);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxlLongDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 386 sril1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAndx, high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAndx, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl3:
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRoxlLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl4:
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    runALU(AluAndx, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRolLongDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 386 sril1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    runALU(AluAnd, high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    runALU(AluAnd, reg_da[ry_index], 0xFFFF);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl3:
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    runALU(AluRolLong, reg_aluo);
	    updateCCR(CcrNZVC);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl4:
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    updateCCR(CcrNZU);
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAslAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluAsl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAslAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluAsl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAslPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluAsl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAslDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluAsl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAslDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluAsl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAslAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluAsl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAslAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluAsl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLsrAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluLsr, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLsrAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluLsr, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLsrPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluLsr, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLsrDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluLsr, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLsrDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluLsr, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLsrAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluLsr, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLsrAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluLsr, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLslAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluLsl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLslAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluLsl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLslPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluLsl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLslDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluLsl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLslDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluLsl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLslAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluLsl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLslAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    runALU(AluAnd, reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluLsl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxrAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRoxrLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxrAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndx, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRoxrLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxrPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndx, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRoxrLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxrDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRoxrLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxrDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRoxrLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxrAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRoxrLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxrAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRoxrLong, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxlAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRoxl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxlAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAndx, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRoxl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxlPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAndx, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRoxl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxlDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRoxl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxlDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRoxl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxlAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRoxl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRoxlAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAndx, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRoxl, reg_aluo);
	    updateCCR(CcrXNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRorAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRor, reg_aluo);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRorAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRor, reg_aluo);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRorPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRor, reg_aluo);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRorDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRor, reg_aluo);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRorDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRor, reg_aluo);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRorAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRor, reg_aluo);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRorAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRor, reg_aluo);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRolAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 6 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRol, reg_aluo);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRolAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRol, reg_aluo);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRolPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    runALU(AluAnd, reg_alub, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRol, reg_aluo);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRolDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRol, reg_aluo);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRolDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    runALU(AluExt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	goto adsw2;
	adsw2:
	    // 2a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    // 24 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRol, reg_aluo);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRolAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRol, reg_aluo);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kRolAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 9 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 4 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    setFC(true, false, true, false);
	    readWord();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    checkExcept();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    runALU(AluAnd, reg_dbin, 0xFFFF);
	    updateCCR(CcrNZVC);
	    // 304 stmw2
	    reg_au = reg_at;
	    runALU(AluRol, reg_aluo);
	    updateCCR(CcrNZVC);
	    setFC(false, true, true, false);
	    readWord();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    checkExcept();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false);
	    writeWord();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    checkExcept();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}


vector<progfunc> handlers = {
    getFunction(ResetDp),
    getFunction(DoubleFaultDp),
    getFunction(DoubleFaultDp),
    getFunction(DoubleFaultDp),
    getFunction(InterruptDp),
    getFunction(DoubleFaultDp),
    getFunction(DoubleFaultDp),
    getFunction(DoubleFaultDp),
    getFunction(DoubleFaultDp),
    getFunction(DoubleFaultDp),
    getFunction(OriByteImm8Ds),
    getFunction(OriByteImm8Ais),
    getFunction(OriByteImm8Aips),
    getFunction(OriByteImm8Pais),
    getFunction(OriByteImm8Das),
    getFunction(OriByteImm8Dais),
    getFunction(OriByteImm8Adr16),
    getFunction(OriByteImm8Adr32),
    getFunction(OriImm8Ccr),
    getFunction(OriWordImm16Ds),
    getFunction(OriWordImm16Ais),
    getFunction(OriWordImm16Aips),
    getFunction(OriWordImm16Pais),
    getFunction(OriWordImm16Das),
    getFunction(OriWordImm16Dais),
    getFunction(OriWordImm16Adr16),
    getFunction(OriWordImm16Adr32),
    getFunction(OriI16uSr),
    getFunction(OriLongImm32Ds),
    getFunction(OriLongImm32Ais),
    getFunction(OriLongImm32Aips),
    getFunction(OriLongImm32Pais),
    getFunction(OriLongImm32Das),
    getFunction(OriLongImm32Dais),
    getFunction(OriLongImm32Adr16),
    getFunction(OriLongImm32Adr32),
    getFunction(BtstDdDs),
    getFunction(MovepWordDasDd),
    getFunction(BtstDdAis),
    getFunction(BtstDdAips),
    getFunction(BtstDdPais),
    getFunction(BtstDdDas),
    getFunction(BtstDdDais),
    getFunction(BtstDdAdr16),
    getFunction(BtstDdAdr32),
    getFunction(BtstDdDpc),
    getFunction(BtstDdDpci),
    getFunction(BtstDdImm),
    getFunction(BchgDdDs),
    getFunction(MovepLongDasDd),
    getFunction(BchgDdAis),
    getFunction(BchgDdAips),
    getFunction(BchgDdPais),
    getFunction(BchgDdDas),
    getFunction(BchgDdDais),
    getFunction(BchgDdAdr16),
    getFunction(BchgDdAdr32),
    getFunction(BclrDdDs),
    getFunction(MovepWordDdDas),
    getFunction(BclrDdAis),
    getFunction(BclrDdAips),
    getFunction(BclrDdPais),
    getFunction(BclrDdDas),
    getFunction(BclrDdDais),
    getFunction(BclrDdAdr16),
    getFunction(BclrDdAdr32),
    getFunction(BsetDdDs),
    getFunction(MovepLongDdDas),
    getFunction(BsetDdAis),
    getFunction(BsetDdAips),
    getFunction(BsetDdPais),
    getFunction(BsetDdDas),
    getFunction(BsetDdDais),
    getFunction(BsetDdAdr16),
    getFunction(BsetDdAdr32),
    getFunction(AndiByteImm8Ds),
    getFunction(AndiByteImm8Ais),
    getFunction(AndiByteImm8Aips),
    getFunction(AndiByteImm8Pais),
    getFunction(AndiByteImm8Das),
    getFunction(AndiByteImm8Dais),
    getFunction(AndiByteImm8Adr16),
    getFunction(AndiByteImm8Adr32),
    getFunction(AndiImm8Ccr),
    getFunction(AndiWordImm16Ds),
    getFunction(AndiWordImm16Ais),
    getFunction(AndiWordImm16Aips),
    getFunction(AndiWordImm16Pais),
    getFunction(AndiWordImm16Das),
    getFunction(AndiWordImm16Dais),
    getFunction(AndiWordImm16Adr16),
    getFunction(AndiWordImm16Adr32),
    getFunction(AndiI16uSr),
    getFunction(AndiLongImm32Ds),
    getFunction(AndiLongImm32Ais),
    getFunction(AndiLongImm32Aips),
    getFunction(AndiLongImm32Pais),
    getFunction(AndiLongImm32Das),
    getFunction(AndiLongImm32Dais),
    getFunction(AndiLongImm32Adr16),
    getFunction(AndiLongImm32Adr32),
    getFunction(SubiByteImm8Ds),
    getFunction(SubiByteImm8Ais),
    getFunction(SubiByteImm8Aips),
    getFunction(SubiByteImm8Pais),
    getFunction(SubiByteImm8Das),
    getFunction(SubiByteImm8Dais),
    getFunction(SubiByteImm8Adr16),
    getFunction(SubiByteImm8Adr32),
    getFunction(SubiWordImm16Ds),
    getFunction(SubiWordImm16Ais),
    getFunction(SubiWordImm16Aips),
    getFunction(SubiWordImm16Pais),
    getFunction(SubiWordImm16Das),
    getFunction(SubiWordImm16Dais),
    getFunction(SubiWordImm16Adr16),
    getFunction(SubiWordImm16Adr32),
    getFunction(SubiLongImm32Ds),
    getFunction(SubiLongImm32Ais),
    getFunction(SubiLongImm32Aips),
    getFunction(SubiLongImm32Pais),
    getFunction(SubiLongImm32Das),
    getFunction(SubiLongImm32Dais),
    getFunction(SubiLongImm32Adr16),
    getFunction(SubiLongImm32Adr32),
    getFunction(AddiByteImm8Ds),
    getFunction(AddiByteImm8Ais),
    getFunction(AddiByteImm8Aips),
    getFunction(AddiByteImm8Pais),
    getFunction(AddiByteImm8Das),
    getFunction(AddiByteImm8Dais),
    getFunction(AddiByteImm8Adr16),
    getFunction(AddiByteImm8Adr32),
    getFunction(AddiWordImm16Ds),
    getFunction(AddiWordImm16Ais),
    getFunction(AddiWordImm16Aips),
    getFunction(AddiWordImm16Pais),
    getFunction(AddiWordImm16Das),
    getFunction(AddiWordImm16Dais),
    getFunction(AddiWordImm16Adr16),
    getFunction(AddiWordImm16Adr32),
    getFunction(AddiLongImm32Ds),
    getFunction(AddiLongImm32Ais),
    getFunction(AddiLongImm32Aips),
    getFunction(AddiLongImm32Pais),
    getFunction(AddiLongImm32Das),
    getFunction(AddiLongImm32Dais),
    getFunction(AddiLongImm32Adr16),
    getFunction(AddiLongImm32Adr32),
    getFunction(BtstImm8Ds),
    getFunction(BtstImm8Ais),
    getFunction(BtstImm8Aips),
    getFunction(BtstImm8Pais),
    getFunction(BtstImm8Das),
    getFunction(BtstImm8Dais),
    getFunction(BtstImm8Adr16),
    getFunction(BtstImm8Adr32),
    getFunction(BtstImm8Dpc),
    getFunction(BtstImm8Dpci),
    getFunction(BchgImm8Ds),
    getFunction(BchgImm8Ais),
    getFunction(BchgImm8Aips),
    getFunction(BchgImm8Pais),
    getFunction(BchgImm8Das),
    getFunction(BchgImm8Dais),
    getFunction(BchgImm8Adr16),
    getFunction(BchgImm8Adr32),
    getFunction(BclrImm8Ds),
    getFunction(BclrImm8Ais),
    getFunction(BclrImm8Aips),
    getFunction(BclrImm8Pais),
    getFunction(BclrImm8Das),
    getFunction(BclrImm8Dais),
    getFunction(BclrImm8Adr16),
    getFunction(BclrImm8Adr32),
    getFunction(BsetImm8Ds),
    getFunction(BsetImm8Ais),
    getFunction(BsetImm8Aips),
    getFunction(BsetImm8Pais),
    getFunction(BsetImm8Das),
    getFunction(BsetImm8Dais),
    getFunction(BsetImm8Adr16),
    getFunction(BsetImm8Adr32),
    getFunction(EoriByteImm8Ds),
    getFunction(EoriByteImm8Ais),
    getFunction(EoriByteImm8Aips),
    getFunction(EoriByteImm8Pais),
    getFunction(EoriByteImm8Das),
    getFunction(EoriByteImm8Dais),
    getFunction(EoriByteImm8Adr16),
    getFunction(EoriByteImm8Adr32),
    getFunction(EoriImm8Ccr),
    getFunction(EoriWordImm16Ds),
    getFunction(EoriWordImm16Ais),
    getFunction(EoriWordImm16Aips),
    getFunction(EoriWordImm16Pais),
    getFunction(EoriWordImm16Das),
    getFunction(EoriWordImm16Dais),
    getFunction(EoriWordImm16Adr16),
    getFunction(EoriWordImm16Adr32),
    getFunction(EoriI16uSr),
    getFunction(EoriLongImm32Ds),
    getFunction(EoriLongImm32Ais),
    getFunction(EoriLongImm32Aips),
    getFunction(EoriLongImm32Pais),
    getFunction(EoriLongImm32Das),
    getFunction(EoriLongImm32Dais),
    getFunction(EoriLongImm32Adr16),
    getFunction(EoriLongImm32Adr32),
    getFunction(CmpiByteImm8Ds),
    getFunction(CmpiByteImm8Ais),
    getFunction(CmpiByteImm8Aips),
    getFunction(CmpiByteImm8Pais),
    getFunction(CmpiByteImm8Das),
    getFunction(CmpiByteImm8Dais),
    getFunction(CmpiByteImm8Adr16),
    getFunction(CmpiByteImm8Adr32),
    getFunction(CmpiWordImm16Ds),
    getFunction(CmpiWordImm16Ais),
    getFunction(CmpiWordImm16Aips),
    getFunction(CmpiWordImm16Pais),
    getFunction(CmpiWordImm16Das),
    getFunction(CmpiWordImm16Dais),
    getFunction(CmpiWordImm16Adr16),
    getFunction(CmpiWordImm16Adr32),
    getFunction(CmpiLongImm32Ds),
    getFunction(CmpiLongImm32Ais),
    getFunction(CmpiLongImm32Aips),
    getFunction(CmpiLongImm32Pais),
    getFunction(CmpiLongImm32Das),
    getFunction(CmpiLongImm32Dais),
    getFunction(CmpiLongImm32Adr16),
    getFunction(CmpiLongImm32Adr32),
    getFunction(MoveByteDsDd),
    getFunction(MoveByteAisDd),
    getFunction(MoveByteAipsDd),
    getFunction(MoveBytePaisDd),
    getFunction(MoveByteDasDd),
    getFunction(MoveByteDaisDd),
    getFunction(MoveByteAdr16Dd),
    getFunction(MoveByteAdr32Dd),
    getFunction(MoveByteDpcDd),
    getFunction(MoveByteDpciDd),
    getFunction(MoveByteImm8Dd),
    getFunction(MoveByteDsAid),
    getFunction(MoveByteAisAid),
    getFunction(MoveByteAipsAid),
    getFunction(MoveBytePaisAid),
    getFunction(MoveByteDasAid),
    getFunction(MoveByteDaisAid),
    getFunction(MoveByteAdr16Aid),
    getFunction(MoveByteAdr32Aid),
    getFunction(MoveByteDpcAid),
    getFunction(MoveByteDpciAid),
    getFunction(MoveByteImm8Aid),
    getFunction(MoveByteDsAipd),
    getFunction(MoveByteAisAipd),
    getFunction(MoveByteAipsAipd),
    getFunction(MoveBytePaisAipd),
    getFunction(MoveByteDasAipd),
    getFunction(MoveByteDaisAipd),
    getFunction(MoveByteAdr16Aipd),
    getFunction(MoveByteAdr32Aipd),
    getFunction(MoveByteDpcAipd),
    getFunction(MoveByteDpciAipd),
    getFunction(MoveByteImm8Aipd),
    getFunction(MoveByteDsPaid),
    getFunction(MoveByteAisPaid),
    getFunction(MoveByteAipsPaid),
    getFunction(MoveBytePaisPaid),
    getFunction(MoveByteDasPaid),
    getFunction(MoveByteDaisPaid),
    getFunction(MoveByteAdr16Paid),
    getFunction(MoveByteAdr32Paid),
    getFunction(MoveByteDpcPaid),
    getFunction(MoveByteDpciPaid),
    getFunction(MoveByteImm8Paid),
    getFunction(MoveByteDsDad),
    getFunction(MoveByteAisDad),
    getFunction(MoveByteAipsDad),
    getFunction(MoveBytePaisDad),
    getFunction(MoveByteDasDad),
    getFunction(MoveByteDaisDad),
    getFunction(MoveByteAdr16Dad),
    getFunction(MoveByteAdr32Dad),
    getFunction(MoveByteDpcDad),
    getFunction(MoveByteDpciDad),
    getFunction(MoveByteImm8Dad),
    getFunction(MoveByteDsDaid),
    getFunction(MoveByteAisDaid),
    getFunction(MoveByteAipsDaid),
    getFunction(MoveBytePaisDaid),
    getFunction(MoveByteDasDaid),
    getFunction(MoveByteDaisDaid),
    getFunction(MoveByteAdr16Daid),
    getFunction(MoveByteAdr32Daid),
    getFunction(MoveByteDpcDaid),
    getFunction(MoveByteDpciDaid),
    getFunction(MoveByteImm8Daid),
    getFunction(MoveByteDsAdr16),
    getFunction(MoveByteAisAdr16),
    getFunction(MoveByteAipsAdr16),
    getFunction(MoveBytePaisAdr16),
    getFunction(MoveByteDasAdr16),
    getFunction(MoveByteDaisAdr16),
    getFunction(MoveByteAdr16Adr16),
    getFunction(MoveByteAdr32Adr16),
    getFunction(MoveByteDpcAdr16),
    getFunction(MoveByteDpciAdr16),
    getFunction(MoveByteImm8Adr16),
    getFunction(MoveByteDsAdr32),
    getFunction(MoveByteAisAdr32),
    getFunction(MoveByteAipsAdr32),
    getFunction(MoveBytePaisAdr32),
    getFunction(MoveByteDasAdr32),
    getFunction(MoveByteDaisAdr32),
    getFunction(MoveByteAdr16Adr32),
    getFunction(MoveByteAdr32Adr32),
    getFunction(MoveByteDpcAdr32),
    getFunction(MoveByteDpciAdr32),
    getFunction(MoveByteImm8Adr32),
    getFunction(MoveLongDsDd),
    getFunction(MoveLongAsDd),
    getFunction(MoveLongAisDd),
    getFunction(MoveLongAipsDd),
    getFunction(MoveLongPaisDd),
    getFunction(MoveLongDasDd),
    getFunction(MoveLongDaisDd),
    getFunction(MoveLongAdr16Dd),
    getFunction(MoveLongAdr32Dd),
    getFunction(MoveLongDpcDd),
    getFunction(MoveLongDpciDd),
    getFunction(MoveLongImm32Dd),
    getFunction(MoveaLongDsAd),
    getFunction(MoveaLongAsAd),
    getFunction(MoveaLongAisAd),
    getFunction(MoveaLongAipsAd),
    getFunction(MoveaLongPaisAd),
    getFunction(MoveaLongDasAd),
    getFunction(MoveaLongDaisAd),
    getFunction(MoveaLongAdr16Ad),
    getFunction(MoveaLongAdr32Ad),
    getFunction(MoveaLongDpcAd),
    getFunction(MoveaLongDpciAd),
    getFunction(MoveaLongImm32Ad),
    getFunction(MoveLongDsAid),
    getFunction(MoveLongAsAid),
    getFunction(MoveLongAisAid),
    getFunction(MoveLongAipsAid),
    getFunction(MoveLongPaisAid),
    getFunction(MoveLongDasAid),
    getFunction(MoveLongDaisAid),
    getFunction(MoveLongAdr16Aid),
    getFunction(MoveLongAdr32Aid),
    getFunction(MoveLongDpcAid),
    getFunction(MoveLongDpciAid),
    getFunction(MoveLongImm32Aid),
    getFunction(MoveLongDsAipd),
    getFunction(MoveLongAsAipd),
    getFunction(MoveLongAisAipd),
    getFunction(MoveLongAipsAipd),
    getFunction(MoveLongPaisAipd),
    getFunction(MoveLongDasAipd),
    getFunction(MoveLongDaisAipd),
    getFunction(MoveLongAdr16Aipd),
    getFunction(MoveLongAdr32Aipd),
    getFunction(MoveLongDpcAipd),
    getFunction(MoveLongDpciAipd),
    getFunction(MoveLongImm32Aipd),
    getFunction(MoveLongDsPaid),
    getFunction(MoveLongAsPaid),
    getFunction(MoveLongAisPaid),
    getFunction(MoveLongAipsPaid),
    getFunction(MoveLongPaisPaid),
    getFunction(MoveLongDasPaid),
    getFunction(MoveLongDaisPaid),
    getFunction(MoveLongAdr16Paid),
    getFunction(MoveLongAdr32Paid),
    getFunction(MoveLongDpcPaid),
    getFunction(MoveLongDpciPaid),
    getFunction(MoveLongImm32Paid),
    getFunction(MoveLongDsDad),
    getFunction(MoveLongAsDad),
    getFunction(MoveLongAisDad),
    getFunction(MoveLongAipsDad),
    getFunction(MoveLongPaisDad),
    getFunction(MoveLongDasDad),
    getFunction(MoveLongDaisDad),
    getFunction(MoveLongAdr16Dad),
    getFunction(MoveLongAdr32Dad),
    getFunction(MoveLongDpcDad),
    getFunction(MoveLongDpciDad),
    getFunction(MoveLongImm32Dad),
    getFunction(MoveLongDsDaid),
    getFunction(MoveLongAsDaid),
    getFunction(MoveLongAisDaid),
    getFunction(MoveLongAipsDaid),
    getFunction(MoveLongPaisDaid),
    getFunction(MoveLongDasDaid),
    getFunction(MoveLongDaisDaid),
    getFunction(MoveLongAdr16Daid),
    getFunction(MoveLongAdr32Daid),
    getFunction(MoveLongDpcDaid),
    getFunction(MoveLongDpciDaid),
    getFunction(MoveLongImm32Daid),
    getFunction(MoveLongDsAdr16),
    getFunction(MoveLongAsAdr16),
    getFunction(MoveLongAisAdr16),
    getFunction(MoveLongAipsAdr16),
    getFunction(MoveLongPaisAdr16),
    getFunction(MoveLongDasAdr16),
    getFunction(MoveLongDaisAdr16),
    getFunction(MoveLongAdr16Adr16),
    getFunction(MoveLongAdr32Adr16),
    getFunction(MoveLongDpcAdr16),
    getFunction(MoveLongDpciAdr16),
    getFunction(MoveLongImm32Adr16),
    getFunction(MoveLongDsAdr32),
    getFunction(MoveLongAsAdr32),
    getFunction(MoveLongAisAdr32),
    getFunction(MoveLongAipsAdr32),
    getFunction(MoveLongPaisAdr32),
    getFunction(MoveLongDasAdr32),
    getFunction(MoveLongDaisAdr32),
    getFunction(MoveLongAdr16Adr32),
    getFunction(MoveLongAdr32Adr32),
    getFunction(MoveLongDpcAdr32),
    getFunction(MoveLongDpciAdr32),
    getFunction(MoveLongImm32Adr32),
    getFunction(MoveWordDsDd),
    getFunction(MoveWordAsDd),
    getFunction(MoveWordAisDd),
    getFunction(MoveWordAipsDd),
    getFunction(MoveWordPaisDd),
    getFunction(MoveWordDasDd),
    getFunction(MoveWordDaisDd),
    getFunction(MoveWordAdr16Dd),
    getFunction(MoveWordAdr32Dd),
    getFunction(MoveWordDpcDd),
    getFunction(MoveWordDpciDd),
    getFunction(MoveWordImm16Dd),
    getFunction(MoveaWordDsAd),
    getFunction(MoveaWordAsAd),
    getFunction(MoveaWordAisAd),
    getFunction(MoveaWordAipsAd),
    getFunction(MoveaWordPaisAd),
    getFunction(MoveaWordDasAd),
    getFunction(MoveaWordDaisAd),
    getFunction(MoveaWordAdr16Ad),
    getFunction(MoveaWordAdr32Ad),
    getFunction(MoveaWordDpcAd),
    getFunction(MoveaWordDpciAd),
    getFunction(MoveaWordImm16Ad),
    getFunction(MoveWordDsAid),
    getFunction(MoveWordAsAid),
    getFunction(MoveWordAisAid),
    getFunction(MoveWordAipsAid),
    getFunction(MoveWordPaisAid),
    getFunction(MoveWordDasAid),
    getFunction(MoveWordDaisAid),
    getFunction(MoveWordAdr16Aid),
    getFunction(MoveWordAdr32Aid),
    getFunction(MoveWordDpcAid),
    getFunction(MoveWordDpciAid),
    getFunction(MoveWordImm16Aid),
    getFunction(MoveWordDsAipd),
    getFunction(MoveWordAsAipd),
    getFunction(MoveWordAisAipd),
    getFunction(MoveWordAipsAipd),
    getFunction(MoveWordPaisAipd),
    getFunction(MoveWordDasAipd),
    getFunction(MoveWordDaisAipd),
    getFunction(MoveWordAdr16Aipd),
    getFunction(MoveWordAdr32Aipd),
    getFunction(MoveWordDpcAipd),
    getFunction(MoveWordDpciAipd),
    getFunction(MoveWordImm16Aipd),
    getFunction(MoveWordDsPaid),
    getFunction(MoveWordAsPaid),
    getFunction(MoveWordAisPaid),
    getFunction(MoveWordAipsPaid),
    getFunction(MoveWordPaisPaid),
    getFunction(MoveWordDasPaid),
    getFunction(MoveWordDaisPaid),
    getFunction(MoveWordAdr16Paid),
    getFunction(MoveWordAdr32Paid),
    getFunction(MoveWordDpcPaid),
    getFunction(MoveWordDpciPaid),
    getFunction(MoveWordImm16Paid),
    getFunction(MoveWordDsDad),
    getFunction(MoveWordAsDad),
    getFunction(MoveWordAisDad),
    getFunction(MoveWordAipsDad),
    getFunction(MoveWordPaisDad),
    getFunction(MoveWordDasDad),
    getFunction(MoveWordDaisDad),
    getFunction(MoveWordAdr16Dad),
    getFunction(MoveWordAdr32Dad),
    getFunction(MoveWordDpcDad),
    getFunction(MoveWordDpciDad),
    getFunction(MoveWordImm16Dad),
    getFunction(MoveWordDsDaid),
    getFunction(MoveWordAsDaid),
    getFunction(MoveWordAisDaid),
    getFunction(MoveWordAipsDaid),
    getFunction(MoveWordPaisDaid),
    getFunction(MoveWordDasDaid),
    getFunction(MoveWordDaisDaid),
    getFunction(MoveWordAdr16Daid),
    getFunction(MoveWordAdr32Daid),
    getFunction(MoveWordDpcDaid),
    getFunction(MoveWordDpciDaid),
    getFunction(MoveWordImm16Daid),
    getFunction(MoveWordDsAdr16),
    getFunction(MoveWordAsAdr16),
    getFunction(MoveWordAisAdr16),
    getFunction(MoveWordAipsAdr16),
    getFunction(MoveWordPaisAdr16),
    getFunction(MoveWordDasAdr16),
    getFunction(MoveWordDaisAdr16),
    getFunction(MoveWordAdr16Adr16),
    getFunction(MoveWordAdr32Adr16),
    getFunction(MoveWordDpcAdr16),
    getFunction(MoveWordDpciAdr16),
    getFunction(MoveWordImm16Adr16),
    getFunction(MoveWordDsAdr32),
    getFunction(MoveWordAsAdr32),
    getFunction(MoveWordAisAdr32),
    getFunction(MoveWordAipsAdr32),
    getFunction(MoveWordPaisAdr32),
    getFunction(MoveWordDasAdr32),
    getFunction(MoveWordDaisAdr32),
    getFunction(MoveWordAdr16Adr32),
    getFunction(MoveWordAdr32Adr32),
    getFunction(MoveWordDpcAdr32),
    getFunction(MoveWordDpciAdr32),
    getFunction(MoveWordImm16Adr32),
    getFunction(NegxByteDs),
    getFunction(NegxByteAis),
    getFunction(NegxByteAips),
    getFunction(NegxBytePais),
    getFunction(NegxByteDas),
    getFunction(NegxByteDais),
    getFunction(NegxByteAdr16),
    getFunction(NegxByteAdr32),
    getFunction(NegxWordDs),
    getFunction(NegxWordAis),
    getFunction(NegxWordAips),
    getFunction(NegxWordPais),
    getFunction(NegxWordDas),
    getFunction(NegxWordDais),
    getFunction(NegxWordAdr16),
    getFunction(NegxWordAdr32),
    getFunction(NegxLongDs),
    getFunction(NegxLongAis),
    getFunction(NegxLongAips),
    getFunction(NegxLongPais),
    getFunction(NegxLongDas),
    getFunction(NegxLongDais),
    getFunction(NegxLongAdr16),
    getFunction(NegxLongAdr32),
    getFunction(MoveSrDs),
    getFunction(MoveSrAis),
    getFunction(MoveSrAips),
    getFunction(MoveSrPais),
    getFunction(MoveSrDas),
    getFunction(MoveSrDais),
    getFunction(MoveSrAdr16),
    getFunction(MoveSrAdr32),
    getFunction(ChkWordDsDd),
    getFunction(ChkWordAisDd),
    getFunction(ChkWordAipsDd),
    getFunction(ChkWordPaisDd),
    getFunction(ChkWordDasDd),
    getFunction(ChkWordDaisDd),
    getFunction(ChkWordAdr16Dd),
    getFunction(ChkWordAdr32Dd),
    getFunction(ChkWordDpcDd),
    getFunction(ChkWordDpciDd),
    getFunction(ChkWordImm16Dd),
    getFunction(LeaAisAd),
    getFunction(LeaDasAd),
    getFunction(LeaDaisAd),
    getFunction(LeaAdr16Ad),
    getFunction(LeaAdr32Ad),
    getFunction(LeaDpcAd),
    getFunction(LeaDpciAd),
    getFunction(ClrByteDs),
    getFunction(ClrByteAis),
    getFunction(ClrByteAips),
    getFunction(ClrBytePais),
    getFunction(ClrByteDas),
    getFunction(ClrByteDais),
    getFunction(ClrByteAdr16),
    getFunction(ClrByteAdr32),
    getFunction(ClrWordDs),
    getFunction(ClrWordAis),
    getFunction(ClrWordAips),
    getFunction(ClrWordPais),
    getFunction(ClrWordDas),
    getFunction(ClrWordDais),
    getFunction(ClrWordAdr16),
    getFunction(ClrWordAdr32),
    getFunction(ClrLongDs),
    getFunction(ClrLongAis),
    getFunction(ClrLongAips),
    getFunction(ClrLongPais),
    getFunction(ClrLongDas),
    getFunction(ClrLongDais),
    getFunction(ClrLongAdr16),
    getFunction(ClrLongAdr32),
    getFunction(NegByteDs),
    getFunction(NegByteAis),
    getFunction(NegByteAips),
    getFunction(NegBytePais),
    getFunction(NegByteDas),
    getFunction(NegByteDais),
    getFunction(NegByteAdr16),
    getFunction(NegByteAdr32),
    getFunction(NegWordDs),
    getFunction(NegWordAis),
    getFunction(NegWordAips),
    getFunction(NegWordPais),
    getFunction(NegWordDas),
    getFunction(NegWordDais),
    getFunction(NegWordAdr16),
    getFunction(NegWordAdr32),
    getFunction(NegLongDs),
    getFunction(NegLongAis),
    getFunction(NegLongAips),
    getFunction(NegLongPais),
    getFunction(NegLongDas),
    getFunction(NegLongDais),
    getFunction(NegLongAdr16),
    getFunction(NegLongAdr32),
    getFunction(MoveDsCcr),
    getFunction(MoveAisCcr),
    getFunction(MoveAipsCcr),
    getFunction(MovePaisCcr),
    getFunction(MoveDasCcr),
    getFunction(MoveDaisCcr),
    getFunction(MoveAdr16Ccr),
    getFunction(MoveAdr32Ccr),
    getFunction(MoveDpcCcr),
    getFunction(MoveDpciCcr),
    getFunction(MoveImm8Ccr),
    getFunction(NotByteDs),
    getFunction(NotByteAis),
    getFunction(NotByteAips),
    getFunction(NotBytePais),
    getFunction(NotByteDas),
    getFunction(NotByteDais),
    getFunction(NotByteAdr16),
    getFunction(NotByteAdr32),
    getFunction(NotWordDs),
    getFunction(NotWordAis),
    getFunction(NotWordAips),
    getFunction(NotWordPais),
    getFunction(NotWordDas),
    getFunction(NotWordDais),
    getFunction(NotWordAdr16),
    getFunction(NotWordAdr32),
    getFunction(NotLongDs),
    getFunction(NotLongAis),
    getFunction(NotLongAips),
    getFunction(NotLongPais),
    getFunction(NotLongDas),
    getFunction(NotLongDais),
    getFunction(NotLongAdr16),
    getFunction(NotLongAdr32),
    getFunction(MoveDsSr),
    getFunction(MoveAisSr),
    getFunction(MoveAipsSr),
    getFunction(MovePaisSr),
    getFunction(MoveDasSr),
    getFunction(MoveDaisSr),
    getFunction(MoveAdr16Sr),
    getFunction(MoveAdr32Sr),
    getFunction(MoveDpcSr),
    getFunction(MoveDpciSr),
    getFunction(MoveI16uSr),
    getFunction(NbcdByteDs),
    getFunction(NbcdByteAis),
    getFunction(NbcdByteAips),
    getFunction(NbcdBytePais),
    getFunction(NbcdByteDas),
    getFunction(NbcdByteDais),
    getFunction(NbcdByteAdr16),
    getFunction(NbcdByteAdr32),
    getFunction(SwapDs),
    getFunction(PeaAis),
    getFunction(PeaDas),
    getFunction(PeaDais),
    getFunction(PeaAdr16),
    getFunction(PeaAdr32),
    getFunction(PeaDpc),
    getFunction(PeaDpci),
    getFunction(ExtWordDs),
    getFunction(MovemWordListAis),
    getFunction(MovemWordListpPais),
    getFunction(MovemWordListDas),
    getFunction(MovemWordListDais),
    getFunction(MovemWordListAdr16),
    getFunction(MovemWordListAdr32),
    getFunction(ExtLongDs),
    getFunction(MovemLongListAis),
    getFunction(MovemLongListpPais),
    getFunction(MovemLongListDas),
    getFunction(MovemLongListDais),
    getFunction(MovemLongListAdr16),
    getFunction(MovemLongListAdr32),
    getFunction(TstByteDs),
    getFunction(TstByteAis),
    getFunction(TstByteAips),
    getFunction(TstBytePais),
    getFunction(TstByteDas),
    getFunction(TstByteDais),
    getFunction(TstByteAdr16),
    getFunction(TstByteAdr32),
    getFunction(TstWordDs),
    getFunction(TstWordAis),
    getFunction(TstWordAips),
    getFunction(TstWordPais),
    getFunction(TstWordDas),
    getFunction(TstWordDais),
    getFunction(TstWordAdr16),
    getFunction(TstWordAdr32),
    getFunction(TstLongDs),
    getFunction(TstLongAis),
    getFunction(TstLongAips),
    getFunction(TstLongPais),
    getFunction(TstLongDas),
    getFunction(TstLongDais),
    getFunction(TstLongAdr16),
    getFunction(TstLongAdr32),
    getFunction(TasDs),
    getFunction(TasAis),
    getFunction(TasAips),
    getFunction(TasPais),
    getFunction(TasDas),
    getFunction(TasDais),
    getFunction(TasAdr16),
    getFunction(TasAdr32),
    getFunction(MovemWordAisList),
    getFunction(MovemWordAipsList),
    getFunction(MovemWordDasList),
    getFunction(MovemWordDaisList),
    getFunction(MovemWordAdr16List),
    getFunction(MovemWordAdr32List),
    getFunction(MovemWordDpcList),
    getFunction(MovemWordDpciList),
    getFunction(MovemLongAisList),
    getFunction(MovemLongAipsList),
    getFunction(MovemLongDasList),
    getFunction(MovemLongDaisList),
    getFunction(MovemLongAdr16List),
    getFunction(MovemLongAdr32List),
    getFunction(MovemLongDpcList),
    getFunction(MovemLongDpciList),
    getFunction(TrapImm4),
    getFunction(LinkAsImm16),
    getFunction(UnlkAs),
    getFunction(MoveAsUsp),
    getFunction(MoveUspAs),
    getFunction(Reset),
    getFunction(Nop),
    getFunction(StopI16u),
    getFunction(Rte),
    getFunction(Rts),
    getFunction(Trapv),
    getFunction(Rtr),
    getFunction(JsrAis),
    getFunction(JsrDas),
    getFunction(JsrDais),
    getFunction(JsrAdr16),
    getFunction(JsrAdr32),
    getFunction(JsrDpc),
    getFunction(JsrDpci),
    getFunction(JmpAis),
    getFunction(JmpDas),
    getFunction(JmpDais),
    getFunction(JmpAdr16),
    getFunction(JmpAdr32),
    getFunction(JmpDpc),
    getFunction(JmpDpci),
    getFunction(AddqByteImm3Ds),
    getFunction(AddqByteImm3Ais),
    getFunction(AddqByteImm3Aips),
    getFunction(AddqByteImm3Pais),
    getFunction(AddqByteImm3Das),
    getFunction(AddqByteImm3Dais),
    getFunction(AddqByteImm3Adr16),
    getFunction(AddqByteImm3Adr32),
    getFunction(AddqWordImm3Ds),
    getFunction(AddqWordImm3As),
    getFunction(AddqWordImm3Ais),
    getFunction(AddqWordImm3Aips),
    getFunction(AddqWordImm3Pais),
    getFunction(AddqWordImm3Das),
    getFunction(AddqWordImm3Dais),
    getFunction(AddqWordImm3Adr16),
    getFunction(AddqWordImm3Adr32),
    getFunction(AddqLongImm3Ds),
    getFunction(AddqLongImm3As),
    getFunction(AddqLongImm3Ais),
    getFunction(AddqLongImm3Aips),
    getFunction(AddqLongImm3Pais),
    getFunction(AddqLongImm3Das),
    getFunction(AddqLongImm3Dais),
    getFunction(AddqLongImm3Adr16),
    getFunction(AddqLongImm3Adr32),
    getFunction(StDs),
    getFunction(DbtDsRel16),
    getFunction(StAis),
    getFunction(StAips),
    getFunction(StPais),
    getFunction(StDas),
    getFunction(StDais),
    getFunction(StAdr16),
    getFunction(StAdr32),
    getFunction(SubqByteImm3Ds),
    getFunction(SubqByteImm3Ais),
    getFunction(SubqByteImm3Aips),
    getFunction(SubqByteImm3Pais),
    getFunction(SubqByteImm3Das),
    getFunction(SubqByteImm3Dais),
    getFunction(SubqByteImm3Adr16),
    getFunction(SubqByteImm3Adr32),
    getFunction(SubqWordImm3Ds),
    getFunction(SubqWordImm3As),
    getFunction(SubqWordImm3Ais),
    getFunction(SubqWordImm3Aips),
    getFunction(SubqWordImm3Pais),
    getFunction(SubqWordImm3Das),
    getFunction(SubqWordImm3Dais),
    getFunction(SubqWordImm3Adr16),
    getFunction(SubqWordImm3Adr32),
    getFunction(SubqLongImm3Ds),
    getFunction(SubqLongImm3As),
    getFunction(SubqLongImm3Ais),
    getFunction(SubqLongImm3Aips),
    getFunction(SubqLongImm3Pais),
    getFunction(SubqLongImm3Das),
    getFunction(SubqLongImm3Dais),
    getFunction(SubqLongImm3Adr16),
    getFunction(SubqLongImm3Adr32),
    getFunction(SfDs),
    getFunction(DbraDsRel16),
    getFunction(SfAis),
    getFunction(SfAips),
    getFunction(SfPais),
    getFunction(SfDas),
    getFunction(SfDais),
    getFunction(SfAdr16),
    getFunction(SfAdr32),
    getFunction(ShiDs),
    getFunction(DbhiDsRel16),
    getFunction(ShiAis),
    getFunction(ShiAips),
    getFunction(ShiPais),
    getFunction(ShiDas),
    getFunction(ShiDais),
    getFunction(ShiAdr16),
    getFunction(ShiAdr32),
    getFunction(SlsDs),
    getFunction(DblsDsRel16),
    getFunction(SlsAis),
    getFunction(SlsAips),
    getFunction(SlsPais),
    getFunction(SlsDas),
    getFunction(SlsDais),
    getFunction(SlsAdr16),
    getFunction(SlsAdr32),
    getFunction(SccDs),
    getFunction(DbccDsRel16),
    getFunction(SccAis),
    getFunction(SccAips),
    getFunction(SccPais),
    getFunction(SccDas),
    getFunction(SccDais),
    getFunction(SccAdr16),
    getFunction(SccAdr32),
    getFunction(ScsDs),
    getFunction(DbcsDsRel16),
    getFunction(ScsAis),
    getFunction(ScsAips),
    getFunction(ScsPais),
    getFunction(ScsDas),
    getFunction(ScsDais),
    getFunction(ScsAdr16),
    getFunction(ScsAdr32),
    getFunction(SneDs),
    getFunction(DbneDsRel16),
    getFunction(SneAis),
    getFunction(SneAips),
    getFunction(SnePais),
    getFunction(SneDas),
    getFunction(SneDais),
    getFunction(SneAdr16),
    getFunction(SneAdr32),
    getFunction(SeqDs),
    getFunction(DbeqDsRel16),
    getFunction(SeqAis),
    getFunction(SeqAips),
    getFunction(SeqPais),
    getFunction(SeqDas),
    getFunction(SeqDais),
    getFunction(SeqAdr16),
    getFunction(SeqAdr32),
    getFunction(SvcDs),
    getFunction(DbvcDsRel16),
    getFunction(SvcAis),
    getFunction(SvcAips),
    getFunction(SvcPais),
    getFunction(SvcDas),
    getFunction(SvcDais),
    getFunction(SvcAdr16),
    getFunction(SvcAdr32),
    getFunction(SvsDs),
    getFunction(DbvsDsRel16),
    getFunction(SvsAis),
    getFunction(SvsAips),
    getFunction(SvsPais),
    getFunction(SvsDas),
    getFunction(SvsDais),
    getFunction(SvsAdr16),
    getFunction(SvsAdr32),
    getFunction(SplDs),
    getFunction(DbplDsRel16),
    getFunction(SplAis),
    getFunction(SplAips),
    getFunction(SplPais),
    getFunction(SplDas),
    getFunction(SplDais),
    getFunction(SplAdr16),
    getFunction(SplAdr32),
    getFunction(SmiDs),
    getFunction(DbmiDsRel16),
    getFunction(SmiAis),
    getFunction(SmiAips),
    getFunction(SmiPais),
    getFunction(SmiDas),
    getFunction(SmiDais),
    getFunction(SmiAdr16),
    getFunction(SmiAdr32),
    getFunction(SgeDs),
    getFunction(DbgeDsRel16),
    getFunction(SgeAis),
    getFunction(SgeAips),
    getFunction(SgePais),
    getFunction(SgeDas),
    getFunction(SgeDais),
    getFunction(SgeAdr16),
    getFunction(SgeAdr32),
    getFunction(SltDs),
    getFunction(DbltDsRel16),
    getFunction(SltAis),
    getFunction(SltAips),
    getFunction(SltPais),
    getFunction(SltDas),
    getFunction(SltDais),
    getFunction(SltAdr16),
    getFunction(SltAdr32),
    getFunction(SgtDs),
    getFunction(DbgtDsRel16),
    getFunction(SgtAis),
    getFunction(SgtAips),
    getFunction(SgtPais),
    getFunction(SgtDas),
    getFunction(SgtDais),
    getFunction(SgtAdr16),
    getFunction(SgtAdr32),
    getFunction(SleDs),
    getFunction(DbleDsRel16),
    getFunction(SleAis),
    getFunction(SleAips),
    getFunction(SlePais),
    getFunction(SleDas),
    getFunction(SleDais),
    getFunction(SleAdr16),
    getFunction(SleAdr32),
    getFunction(BraRel16),
    getFunction(BraRel8),
    getFunction(BsrRel16),
    getFunction(BsrRel8),
    getFunction(BhiRel16),
    getFunction(BhiRel8),
    getFunction(BlsRel16),
    getFunction(BlsRel8),
    getFunction(BccRel16),
    getFunction(BccRel8),
    getFunction(BcsRel16),
    getFunction(BcsRel8),
    getFunction(BneRel16),
    getFunction(BneRel8),
    getFunction(BeqRel16),
    getFunction(BeqRel8),
    getFunction(BvcRel16),
    getFunction(BvcRel8),
    getFunction(BvsRel16),
    getFunction(BvsRel8),
    getFunction(BplRel16),
    getFunction(BplRel8),
    getFunction(BmiRel16),
    getFunction(BmiRel8),
    getFunction(BgeRel16),
    getFunction(BgeRel8),
    getFunction(BltRel16),
    getFunction(BltRel8),
    getFunction(BgtRel16),
    getFunction(BgtRel8),
    getFunction(BleRel16),
    getFunction(BleRel8),
    getFunction(MoveqImm8oDd),
    getFunction(OrByteDsDd),
    getFunction(OrByteAisDd),
    getFunction(OrByteAipsDd),
    getFunction(OrBytePaisDd),
    getFunction(OrByteDasDd),
    getFunction(OrByteDaisDd),
    getFunction(OrByteAdr16Dd),
    getFunction(OrByteAdr32Dd),
    getFunction(OrByteDpcDd),
    getFunction(OrByteDpciDd),
    getFunction(OrByteImm8Dd),
    getFunction(OrWordDsDd),
    getFunction(OrWordAisDd),
    getFunction(OrWordAipsDd),
    getFunction(OrWordPaisDd),
    getFunction(OrWordDasDd),
    getFunction(OrWordDaisDd),
    getFunction(OrWordAdr16Dd),
    getFunction(OrWordAdr32Dd),
    getFunction(OrWordDpcDd),
    getFunction(OrWordDpciDd),
    getFunction(OrWordImm16Dd),
    getFunction(OrLongDsDd),
    getFunction(OrLongAisDd),
    getFunction(OrLongAipsDd),
    getFunction(OrLongPaisDd),
    getFunction(OrLongDasDd),
    getFunction(OrLongDaisDd),
    getFunction(OrLongAdr16Dd),
    getFunction(OrLongAdr32Dd),
    getFunction(OrLongDpcDd),
    getFunction(OrLongDpciDd),
    getFunction(OrLongImm32Dd),
    getFunction(DivuWordDsDd),
    getFunction(DivuWordAisDd),
    getFunction(DivuWordAipsDd),
    getFunction(DivuWordPaisDd),
    getFunction(DivuWordDasDd),
    getFunction(DivuWordDaisDd),
    getFunction(DivuWordAdr16Dd),
    getFunction(DivuWordAdr32Dd),
    getFunction(DivuWordDpcDd),
    getFunction(DivuWordDpciDd),
    getFunction(DivuWordImm16Dd),
    getFunction(SbcdDsDd),
    getFunction(SbcdPaisPaid),
    getFunction(OrByteDdAis),
    getFunction(OrByteDdAips),
    getFunction(OrByteDdPais),
    getFunction(OrByteDdDas),
    getFunction(OrByteDdDais),
    getFunction(OrByteDdAdr16),
    getFunction(OrByteDdAdr32),
    getFunction(OrWordDdAis),
    getFunction(OrWordDdAips),
    getFunction(OrWordDdPais),
    getFunction(OrWordDdDas),
    getFunction(OrWordDdDais),
    getFunction(OrWordDdAdr16),
    getFunction(OrWordDdAdr32),
    getFunction(OrLongDdAis),
    getFunction(OrLongDdAips),
    getFunction(OrLongDdPais),
    getFunction(OrLongDdDas),
    getFunction(OrLongDdDais),
    getFunction(OrLongDdAdr16),
    getFunction(OrLongDdAdr32),
    getFunction(DivsWordDsDd),
    getFunction(DivsWordAisDd),
    getFunction(DivsWordAipsDd),
    getFunction(DivsWordPaisDd),
    getFunction(DivsWordDasDd),
    getFunction(DivsWordDaisDd),
    getFunction(DivsWordAdr16Dd),
    getFunction(DivsWordAdr32Dd),
    getFunction(DivsWordDpcDd),
    getFunction(DivsWordDpciDd),
    getFunction(DivsWordImm16Dd),
    getFunction(SubByteDsDd),
    getFunction(SubByteAisDd),
    getFunction(SubByteAipsDd),
    getFunction(SubBytePaisDd),
    getFunction(SubByteDasDd),
    getFunction(SubByteDaisDd),
    getFunction(SubByteAdr16Dd),
    getFunction(SubByteAdr32Dd),
    getFunction(SubByteDpcDd),
    getFunction(SubByteDpciDd),
    getFunction(SubByteImm8Dd),
    getFunction(SubWordDsDd),
    getFunction(SubWordAsDd),
    getFunction(SubWordAisDd),
    getFunction(SubWordAipsDd),
    getFunction(SubWordPaisDd),
    getFunction(SubWordDasDd),
    getFunction(SubWordDaisDd),
    getFunction(SubWordAdr16Dd),
    getFunction(SubWordAdr32Dd),
    getFunction(SubWordDpcDd),
    getFunction(SubWordDpciDd),
    getFunction(SubWordImm16Dd),
    getFunction(SubLongDsDd),
    getFunction(SubLongAsDd),
    getFunction(SubLongAisDd),
    getFunction(SubLongAipsDd),
    getFunction(SubLongPaisDd),
    getFunction(SubLongDasDd),
    getFunction(SubLongDaisDd),
    getFunction(SubLongAdr16Dd),
    getFunction(SubLongAdr32Dd),
    getFunction(SubLongDpcDd),
    getFunction(SubLongDpciDd),
    getFunction(SubLongImm32Dd),
    getFunction(SubaWordDsAd),
    getFunction(SubaWordAsAd),
    getFunction(SubaWordAisAd),
    getFunction(SubaWordAipsAd),
    getFunction(SubaWordPaisAd),
    getFunction(SubaWordDasAd),
    getFunction(SubaWordDaisAd),
    getFunction(SubaWordAdr16Ad),
    getFunction(SubaWordAdr32Ad),
    getFunction(SubaWordDpcAd),
    getFunction(SubaWordDpciAd),
    getFunction(SubaWordImm16Ad),
    getFunction(SubxByteDsDd),
    getFunction(SubxBytePaisPaid),
    getFunction(SubByteDdAis),
    getFunction(SubByteDdAips),
    getFunction(SubByteDdPais),
    getFunction(SubByteDdDas),
    getFunction(SubByteDdDais),
    getFunction(SubByteDdAdr16),
    getFunction(SubByteDdAdr32),
    getFunction(SubxWordDsDd),
    getFunction(SubxWordPaisPaid),
    getFunction(SubWordDdAis),
    getFunction(SubWordDdAips),
    getFunction(SubWordDdPais),
    getFunction(SubWordDdDas),
    getFunction(SubWordDdDais),
    getFunction(SubWordDdAdr16),
    getFunction(SubWordDdAdr32),
    getFunction(SubxLongDsDd),
    getFunction(SubxLongPaisPaid),
    getFunction(SubLongDdAis),
    getFunction(SubLongDdAips),
    getFunction(SubLongDdPais),
    getFunction(SubLongDdDas),
    getFunction(SubLongDdDais),
    getFunction(SubLongDdAdr16),
    getFunction(SubLongDdAdr32),
    getFunction(SubaLongDsAd),
    getFunction(SubaLongAsAd),
    getFunction(SubaLongAisAd),
    getFunction(SubaLongAipsAd),
    getFunction(SubaLongPaisAd),
    getFunction(SubaLongDasAd),
    getFunction(SubaLongDaisAd),
    getFunction(SubaLongAdr16Ad),
    getFunction(SubaLongAdr32Ad),
    getFunction(SubaLongDpcAd),
    getFunction(SubaLongDpciAd),
    getFunction(SubaLongImm32Ad),
    getFunction(CmpByteDsDd),
    getFunction(CmpByteAisDd),
    getFunction(CmpByteAipsDd),
    getFunction(CmpBytePaisDd),
    getFunction(CmpByteDasDd),
    getFunction(CmpByteDaisDd),
    getFunction(CmpByteAdr16Dd),
    getFunction(CmpByteAdr32Dd),
    getFunction(CmpByteDpcDd),
    getFunction(CmpByteDpciDd),
    getFunction(CmpByteImm8Dd),
    getFunction(CmpWordDsDd),
    getFunction(CmpWordAsDd),
    getFunction(CmpWordAisDd),
    getFunction(CmpWordAipsDd),
    getFunction(CmpWordPaisDd),
    getFunction(CmpWordDasDd),
    getFunction(CmpWordDaisDd),
    getFunction(CmpWordAdr16Dd),
    getFunction(CmpWordAdr32Dd),
    getFunction(CmpWordDpcDd),
    getFunction(CmpWordDpciDd),
    getFunction(CmpWordImm16Dd),
    getFunction(CmpLongDsDd),
    getFunction(CmpLongAsDd),
    getFunction(CmpLongAisDd),
    getFunction(CmpLongAipsDd),
    getFunction(CmpLongPaisDd),
    getFunction(CmpLongDasDd),
    getFunction(CmpLongDaisDd),
    getFunction(CmpLongAdr16Dd),
    getFunction(CmpLongAdr32Dd),
    getFunction(CmpLongDpcDd),
    getFunction(CmpLongDpciDd),
    getFunction(CmpLongImm32Dd),
    getFunction(CmpaWordDsAd),
    getFunction(CmpaWordAsAd),
    getFunction(CmpaWordAisAd),
    getFunction(CmpaWordAipsAd),
    getFunction(CmpaWordPaisAd),
    getFunction(CmpaWordDasAd),
    getFunction(CmpaWordDaisAd),
    getFunction(CmpaWordAdr16Ad),
    getFunction(CmpaWordAdr32Ad),
    getFunction(CmpaWordDpcAd),
    getFunction(CmpaWordDpciAd),
    getFunction(CmpaWordImm16Ad),
    getFunction(EorByteDdDs),
    getFunction(CmpmByteAipsAipd),
    getFunction(EorByteDdAis),
    getFunction(EorByteDdAips),
    getFunction(EorByteDdPais),
    getFunction(EorByteDdDas),
    getFunction(EorByteDdDais),
    getFunction(EorByteDdAdr16),
    getFunction(EorByteDdAdr32),
    getFunction(EorWordDdDs),
    getFunction(CmpmWordAipsAipd),
    getFunction(EorWordDdAis),
    getFunction(EorWordDdAips),
    getFunction(EorWordDdPais),
    getFunction(EorWordDdDas),
    getFunction(EorWordDdDais),
    getFunction(EorWordDdAdr16),
    getFunction(EorWordDdAdr32),
    getFunction(EorLongDdDs),
    getFunction(CmpmLongAipsAipd),
    getFunction(EorLongDdAis),
    getFunction(EorLongDdAips),
    getFunction(EorLongDdPais),
    getFunction(EorLongDdDas),
    getFunction(EorLongDdDais),
    getFunction(EorLongDdAdr16),
    getFunction(EorLongDdAdr32),
    getFunction(CmpaLongDsAd),
    getFunction(CmpaLongAsAd),
    getFunction(CmpaLongAisAd),
    getFunction(CmpaLongAipsAd),
    getFunction(CmpaLongPaisAd),
    getFunction(CmpaLongDasAd),
    getFunction(CmpaLongDaisAd),
    getFunction(CmpaLongAdr16Ad),
    getFunction(CmpaLongAdr32Ad),
    getFunction(CmpaLongDpcAd),
    getFunction(CmpaLongDpciAd),
    getFunction(CmpaLongImm32Ad),
    getFunction(AndByteDsDd),
    getFunction(AndByteAisDd),
    getFunction(AndByteAipsDd),
    getFunction(AndBytePaisDd),
    getFunction(AndByteDasDd),
    getFunction(AndByteDaisDd),
    getFunction(AndByteAdr16Dd),
    getFunction(AndByteAdr32Dd),
    getFunction(AndByteDpcDd),
    getFunction(AndByteDpciDd),
    getFunction(AndByteImm8Dd),
    getFunction(AndWordDsDd),
    getFunction(AndWordAisDd),
    getFunction(AndWordAipsDd),
    getFunction(AndWordPaisDd),
    getFunction(AndWordDasDd),
    getFunction(AndWordDaisDd),
    getFunction(AndWordAdr16Dd),
    getFunction(AndWordAdr32Dd),
    getFunction(AndWordDpcDd),
    getFunction(AndWordDpciDd),
    getFunction(AndWordImm16Dd),
    getFunction(AndLongDsDd),
    getFunction(AndLongAisDd),
    getFunction(AndLongAipsDd),
    getFunction(AndLongPaisDd),
    getFunction(AndLongDasDd),
    getFunction(AndLongDaisDd),
    getFunction(AndLongAdr16Dd),
    getFunction(AndLongAdr32Dd),
    getFunction(AndLongDpcDd),
    getFunction(AndLongDpciDd),
    getFunction(AndLongImm32Dd),
    getFunction(MuluWordDsDd),
    getFunction(MuluWordAisDd),
    getFunction(MuluWordAipsDd),
    getFunction(MuluWordPaisDd),
    getFunction(MuluWordDasDd),
    getFunction(MuluWordDaisDd),
    getFunction(MuluWordAdr16Dd),
    getFunction(MuluWordAdr32Dd),
    getFunction(MuluWordDpcDd),
    getFunction(MuluWordDpciDd),
    getFunction(MuluWordImm16Dd),
    getFunction(AbcdDsDd),
    getFunction(AbcdPaisPaid),
    getFunction(AndByteDdAis),
    getFunction(AndByteDdAips),
    getFunction(AndByteDdPais),
    getFunction(AndByteDdDas),
    getFunction(AndByteDdDais),
    getFunction(AndByteDdAdr16),
    getFunction(AndByteDdAdr32),
    getFunction(ExgDdDs),
    getFunction(ExgAdAs),
    getFunction(AndWordDdAis),
    getFunction(AndWordDdAips),
    getFunction(AndWordDdPais),
    getFunction(AndWordDdDas),
    getFunction(AndWordDdDais),
    getFunction(AndWordDdAdr16),
    getFunction(AndWordDdAdr32),
    getFunction(ExgDdAs),
    getFunction(AndLongDdAis),
    getFunction(AndLongDdAips),
    getFunction(AndLongDdPais),
    getFunction(AndLongDdDas),
    getFunction(AndLongDdDais),
    getFunction(AndLongDdAdr16),
    getFunction(AndLongDdAdr32),
    getFunction(MulsWordDsDd),
    getFunction(MulsWordAisDd),
    getFunction(MulsWordAipsDd),
    getFunction(MulsWordPaisDd),
    getFunction(MulsWordDasDd),
    getFunction(MulsWordDaisDd),
    getFunction(MulsWordAdr16Dd),
    getFunction(MulsWordAdr32Dd),
    getFunction(MulsWordDpcDd),
    getFunction(MulsWordDpciDd),
    getFunction(MulsWordImm16Dd),
    getFunction(AddByteDsDd),
    getFunction(AddByteAisDd),
    getFunction(AddByteAipsDd),
    getFunction(AddBytePaisDd),
    getFunction(AddByteDasDd),
    getFunction(AddByteDaisDd),
    getFunction(AddByteAdr16Dd),
    getFunction(AddByteAdr32Dd),
    getFunction(AddByteDpcDd),
    getFunction(AddByteDpciDd),
    getFunction(AddByteImm8Dd),
    getFunction(AddWordDsDd),
    getFunction(AddWordAsDd),
    getFunction(AddWordAisDd),
    getFunction(AddWordAipsDd),
    getFunction(AddWordPaisDd),
    getFunction(AddWordDasDd),
    getFunction(AddWordDaisDd),
    getFunction(AddWordAdr16Dd),
    getFunction(AddWordAdr32Dd),
    getFunction(AddWordDpcDd),
    getFunction(AddWordDpciDd),
    getFunction(AddWordImm16Dd),
    getFunction(AddLongDsDd),
    getFunction(AddLongAsDd),
    getFunction(AddLongAisDd),
    getFunction(AddLongAipsDd),
    getFunction(AddLongPaisDd),
    getFunction(AddLongDasDd),
    getFunction(AddLongDaisDd),
    getFunction(AddLongAdr16Dd),
    getFunction(AddLongAdr32Dd),
    getFunction(AddLongDpcDd),
    getFunction(AddLongDpciDd),
    getFunction(AddLongImm32Dd),
    getFunction(AddaWordDsAd),
    getFunction(AddaWordAsAd),
    getFunction(AddaWordAisAd),
    getFunction(AddaWordAipsAd),
    getFunction(AddaWordPaisAd),
    getFunction(AddaWordDasAd),
    getFunction(AddaWordDaisAd),
    getFunction(AddaWordAdr16Ad),
    getFunction(AddaWordAdr32Ad),
    getFunction(AddaWordDpcAd),
    getFunction(AddaWordDpciAd),
    getFunction(AddaWordImm16Ad),
    getFunction(AddxByteDsDd),
    getFunction(AddxBytePaisPaid),
    getFunction(AddByteDdAis),
    getFunction(AddByteDdAips),
    getFunction(AddByteDdPais),
    getFunction(AddByteDdDas),
    getFunction(AddByteDdDais),
    getFunction(AddByteDdAdr16),
    getFunction(AddByteDdAdr32),
    getFunction(AddxWordDsDd),
    getFunction(AddxWordPaisPaid),
    getFunction(AddWordDdAis),
    getFunction(AddWordDdAips),
    getFunction(AddWordDdPais),
    getFunction(AddWordDdDas),
    getFunction(AddWordDdDais),
    getFunction(AddWordDdAdr16),
    getFunction(AddWordDdAdr32),
    getFunction(AddxLongDsDd),
    getFunction(AddxLongPaisPaid),
    getFunction(AddLongDdAis),
    getFunction(AddLongDdAips),
    getFunction(AddLongDdPais),
    getFunction(AddLongDdDas),
    getFunction(AddLongDdDais),
    getFunction(AddLongDdAdr16),
    getFunction(AddLongDdAdr32),
    getFunction(AddaLongDsAd),
    getFunction(AddaLongAsAd),
    getFunction(AddaLongAisAd),
    getFunction(AddaLongAipsAd),
    getFunction(AddaLongPaisAd),
    getFunction(AddaLongDasAd),
    getFunction(AddaLongDaisAd),
    getFunction(AddaLongAdr16Ad),
    getFunction(AddaLongAdr32Ad),
    getFunction(AddaLongDpcAd),
    getFunction(AddaLongDpciAd),
    getFunction(AddaLongImm32Ad),
    getFunction(AsrByteImm3Ds),
    getFunction(LsrByteImm3Ds),
    getFunction(RoxrByteImm3Ds),
    getFunction(RorByteImm3Ds),
    getFunction(AsrByteDdDs),
    getFunction(LsrByteDdDs),
    getFunction(RoxrByteDdDs),
    getFunction(RorByteDdDs),
    getFunction(AsrWordImm3Ds),
    getFunction(LsrWordImm3Ds),
    getFunction(RoxrWordImm3Ds),
    getFunction(RorWordImm3Ds),
    getFunction(AsrWordDdDs),
    getFunction(LsrWordDdDs),
    getFunction(RoxrWordDdDs),
    getFunction(RorWordDdDs),
    getFunction(AsrLongImm3Ds),
    getFunction(LsrLongImm3Ds),
    getFunction(RoxrLongImm3Ds),
    getFunction(RorLongImm3Ds),
    getFunction(AsrLongDdDs),
    getFunction(LsrLongDdDs),
    getFunction(RoxrLongDdDs),
    getFunction(RorLongDdDs),
    getFunction(AsrAis),
    getFunction(AsrAips),
    getFunction(AsrPais),
    getFunction(AsrDas),
    getFunction(AsrDais),
    getFunction(AsrAdr16),
    getFunction(AsrAdr32),
    getFunction(AslByteImm3Ds),
    getFunction(LslByteImm3Ds),
    getFunction(RoxlByteImm3Ds),
    getFunction(RolByteImm3Ds),
    getFunction(AslByteDdDs),
    getFunction(LslByteDdDs),
    getFunction(RoxlByteDdDs),
    getFunction(RolByteDdDs),
    getFunction(AslWordImm3Ds),
    getFunction(LslWordImm3Ds),
    getFunction(RoxlWordImm3Ds),
    getFunction(RolWordImm3Ds),
    getFunction(AslWordDdDs),
    getFunction(LslWordDdDs),
    getFunction(RoxlWordDdDs),
    getFunction(RolWordDdDs),
    getFunction(AslLongImm3Ds),
    getFunction(LslLongImm3Ds),
    getFunction(RoxlLongImm3Ds),
    getFunction(RolLongImm3Ds),
    getFunction(AslLongDdDs),
    getFunction(LslLongDdDs),
    getFunction(RoxlLongDdDs),
    getFunction(RolLongDdDs),
    getFunction(AslAis),
    getFunction(AslAips),
    getFunction(AslPais),
    getFunction(AslDas),
    getFunction(AslDais),
    getFunction(AslAdr16),
    getFunction(AslAdr32),
    getFunction(LsrAis),
    getFunction(LsrAips),
    getFunction(LsrPais),
    getFunction(LsrDas),
    getFunction(LsrDais),
    getFunction(LsrAdr16),
    getFunction(LsrAdr32),
    getFunction(LslAis),
    getFunction(LslAips),
    getFunction(LslPais),
    getFunction(LslDas),
    getFunction(LslDais),
    getFunction(LslAdr16),
    getFunction(LslAdr32),
    getFunction(RoxrAis),
    getFunction(RoxrAips),
    getFunction(RoxrPais),
    getFunction(RoxrDas),
    getFunction(RoxrDais),
    getFunction(RoxrAdr16),
    getFunction(RoxrAdr32),
    getFunction(RoxlAis),
    getFunction(RoxlAips),
    getFunction(RoxlPais),
    getFunction(RoxlDas),
    getFunction(RoxlDais),
    getFunction(RoxlAdr16),
    getFunction(RoxlAdr32),
    getFunction(RorAis),
    getFunction(RorAips),
    getFunction(RorPais),
    getFunction(RorDas),
    getFunction(RorDais),
    getFunction(RorAdr16),
    getFunction(RorAdr32),
    getFunction(RolAis),
    getFunction(RolAips),
    getFunction(RolPais),
    getFunction(RolDas),
    getFunction(RolDais),
    getFunction(RolAdr16),
    getFunction(RolAdr32),
};