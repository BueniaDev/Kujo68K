void m68kResetDpProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 002 rstp3
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 296 rstp4
	    reg_ird = reg_ir;
	    setIntState();
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setTrace();
	    // 27e rstp5
	    trapExcept(0x00);
	    reg_ftu = 0x0000;
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 27f rstp6
	    initST();
	    reg_sr |= 0x700;
	    updateInterrupts();
	    reg_au = ext32(reg_ftu);
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    // 2fb rstp7
	    reg_aob = reg_au;
	    setReg16High(reg_da[16], reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, true, true);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2ff rstp8
	    reg_aob = reg_au;
	    setReg16High(reg_da[16], reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, true, true);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 300 rstp9
	    reg_aob = reg_au;
	    initST();
	    setReg16Low(reg_da[16], reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, true, true);
	    readWord();
	    startBus();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    clearTrace();
	    // 11e rstpa
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, true, true);
	    readWord();
	    startBus();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, true, true);
	    readWord();
	    startBus();
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    inst_cycle = 14;
	}
	break;
	case 14:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, true, false);
	    readWord();
	    startBus();
	    inst_cycle = 15;
	}
	break;
	case 15:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kBusErrorDpProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 003 bser1
	    reg_ssw = (base_ssw | (testbit(reg_sr, 13) ? 0x4 : 0));
	    reg_at = reg_aob;
	    reg_ftu = reg_sr;
	    reg_au = reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3a7 bser2
	    initST();
	    reg_pc = reg_au;
	    aluAnd(reg_au, 0xFFFF);
	    reg_au = reg_da[16] - 2;
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    clearTrace();
	    // 3ca bser3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, true, true);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0a2 bser4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_ftu = reg_ird;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, true, true);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 3c6 bser5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, true, true);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 088 bser6
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_pc = reg_at;
	    reg_ftu = ((reg_ftu & ~0x1F) | reg_ssw);
	    reg_au = reg_au - 2;
	    aluAnd(reg_at, 0xFFFF);
	    setFC(true, false, false, true, true);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, true, true);
	    writeWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x02);
	    reg_da[16] = reg_au;
	    reg_ftu = 0x0008;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, true, true);
	    writeWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, true, true);
	    writeWord();
	    startBus();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, true, true);
	    readWord();
	    startBus();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, true, true);
	    readWord();
	    startBus();
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, true, true);
	    readWord();
	    startBus();
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 14;
	}
	break;
	case 14:
	{
	    inst_cycle = 15;
	}
	break;
	case 15:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, true, false);
	    readWord();
	    startBus();
	    inst_cycle = 16;
	}
	break;
	case 16:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kAddressErrorDpProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 003 bser1
	    reg_ssw = (base_ssw | (testbit(reg_sr, 13) ? 0x4 : 0));
	    reg_at = reg_aob;
	    reg_ftu = reg_sr;
	    reg_au = reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3a7 bser2
	    initST();
	    reg_pc = reg_au;
	    aluAnd(reg_au, 0xFFFF);
	    reg_au = reg_da[16] - 2;
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    clearTrace();
	    // 3ca bser3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, true, true);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0a2 bser4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_ftu = reg_ird;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, true, true);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 3c6 bser5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, true, true);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 088 bser6
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_pc = reg_at;
	    reg_ftu = ((reg_ftu & ~0x1F) | reg_ssw);
	    reg_au = reg_au - 2;
	    aluAnd(reg_at, 0xFFFF);
	    setFC(true, false, false, true, true);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, true, true);
	    writeWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x03);
	    reg_da[16] = reg_au;
	    reg_ftu = 0x000c;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, true, true);
	    writeWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, true, true);
	    writeWord();
	    startBus();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, true, true);
	    readWord();
	    startBus();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, true, true);
	    readWord();
	    startBus();
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, true, true);
	    readWord();
	    startBus();
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 14;
	}
	break;
	case 14:
	{
	    inst_cycle = 15;
	}
	break;
	case 15:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, true, false);
	    readWord();
	    startBus();
	    inst_cycle = 16;
	}
	break;
	case 16:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kDoubleFaultDpProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 001 halt1
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kInterruptDpProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c4 itlx1
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 234 itlx2
	    initST();
	    reg_alub = reg_ftu;
	    reg_pc = reg_au;
	    reg_sr = ((reg_sr & ~0x700) | ((next_state >> 16) & 0x700));
	    updateInterrupts();
	    aluAnd(reg_au, 0xFFFF);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 235 itlx3
	    reg_ftu = (0xfff0 | ((next_state >> 23) & 0xE));
	    reg_au = reg_da[16] - 2;
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 0eb itlx4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, true, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 236 itlx5
	    reg_aob = reg_at;
	    setFC(true, true, true, true, false);
	    startIRQVectorLookup();
	    readWordCPU();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    endIRQVectorLookup();
	    reg_irc = reg_edb;
	    // 118 itlx6
	    reg_ir = reg_irc;
	    updateIPL();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    // 292 itlx7
	    reg_ird = reg_ir;
	    setIntState();
	    setFTUConst();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    setTrace();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(reg_int_vec);
	    reg_da[16] = reg_au;
	    reg_ftu = reg_int_vec;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, true, false);
	    writeWord();
	    startBus();
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, true, false);
	    writeWord();
	    startBus();
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, true, false);
	    readWord();
	    startBus();
	    inst_cycle = 14;
	}
	break;
	case 14:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, true, false);
	    readWord();
	    startBus();
	    inst_cycle = 15;
	}
	break;
	case 15:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, true, false);
	    readWord();
	    startBus();
	    inst_cycle = 16;
	}
	break;
	case 16:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 17;
	}
	break;
	case 17:
	{
	    inst_cycle = 18;
	}
	break;
	case 18:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, true, false);
	    readWord();
	    startBus();
	    inst_cycle = 19;
	}
	break;
	case 19:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kIllegalDpProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c0 trac1
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3a3 trac2
	    initST();
	    reg_pc = reg_au;
	    aluAnd(reg_au, 0xFFFF);
	    reg_au = reg_da[16] - 2;
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    clearTrace();
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, true, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x04);
	    reg_da[16] = reg_au;
	    reg_ftu = 0x0010;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, true, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, true, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, true, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, true, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, true, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, true, false);
	    readWord();
	    startBus();
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kTraceDpProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c0 trac1
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3a3 trac2
	    initST();
	    reg_pc = reg_au;
	    aluAnd(reg_au, 0xFFFF);
	    reg_au = reg_da[16] - 2;
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    clearTrace();
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, true, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x09);
	    reg_da[16] = reg_au;
	    reg_ftu = 0x0024;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, true, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, true, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, true, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, true, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, true, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, true, false);
	    readWord();
	    startBus();
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kPrivilegeDpProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c0 trac1
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3a3 trac2
	    initST();
	    reg_pc = reg_au;
	    aluAnd(reg_au, 0xFFFF);
	    reg_au = reg_da[16] - 2;
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    clearTrace();
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, true, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x08);
	    reg_da[16] = reg_au;
	    reg_ftu = 0x0020;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, true, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, true, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, true, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, true, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, true, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, true, false);
	    readWord();
	    startBus();
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLineADpProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c0 trac1
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3a3 trac2
	    initST();
	    reg_pc = reg_au;
	    aluAnd(reg_au, 0xFFFF);
	    reg_au = reg_da[16] - 2;
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    clearTrace();
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, true, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x0a);
	    reg_da[16] = reg_au;
	    reg_ftu = 0x0028;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, true, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, true, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, true, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, true, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, true, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, true, false);
	    readWord();
	    startBus();
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

void m68kLineFDpProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c0 trac1
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3a3 trac2
	    initST();
	    reg_pc = reg_au;
	    aluAnd(reg_au, 0xFFFF);
	    reg_au = reg_da[16] - 2;
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    clearTrace();
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, true, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x0b);
	    reg_da[16] = reg_au;
	    reg_ftu = 0x002c;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, true, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, true, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, true, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, true, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, true, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, true, false);
	    readWord();
	    startBus();
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0000 fff8
void m68kOriByteImm8DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 100 roaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    aluOrByte(reg_dt, reg_da[ry_index]);
	    updateNZVC();
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0010 fff8
void m68kOriByteImm8AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOrByte(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0018 fff8
void m68kOriByteImm8AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOrByte(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0020 fff8
void m68kOriByteImm8PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_dt, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOrByte(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0028 fff8
void m68kOriByteImm8DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOrByte(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0030 fff8
void m68kOriByteImm8DaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOrByte(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0038 ffff
void m68kOriByteImm8Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluOrByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOrByte(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0039 ffff
void m68kOriByteImm8Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluOrByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOrByte(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 003c ffff
void m68kOriImm8CcrProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1cc stiw1
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 307 stiw2
	    aluOrByte(reg_ftu, reg_dt);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 320 stiw3
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_aluo;
	    reg_au = reg_au + 2;
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0040 fff8
void m68kOriWordImm16DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 100 roaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    aluOr(reg_dt, reg_da[ry_index]);
	    updateNZVC();
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0050 fff8
void m68kOriWordImm16AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOr(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0058 fff8
void m68kOriWordImm16AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluOr(reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOr(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0060 fff8
void m68kOriWordImm16PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - 2;
	    aluOr(reg_dt, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOr(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0068 fff8
void m68kOriWordImm16DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOr(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0070 fff8
void m68kOriWordImm16DaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOr(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0078 ffff
void m68kOriWordImm16Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluOr(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOr(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0079 ffff
void m68kOriWordImm16Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluOr(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOr(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 007c ffff
void m68kOriI16uSrProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    if (!testbit(reg_sr, 13))
	    {
		setPriv();
		return;
	    }

	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1cc stiw1
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 307 stiw2
	    aluOr(reg_ftu, reg_dt);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 320 stiw3
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_aluo;
	    reg_au = reg_au + 2;
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
	    updateSupervisor();
	    updateInterrupts();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0080 fff8
void m68kOriLongImm32DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 10c roal1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    aluOr(reg_dt, reg_da[ry_index]);
	    updateNZVC();
	    // 259 roal2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25a roal3
	    aluOr(high16(reg_dt), high16(reg_da[ry_index]));
	    updateNZVCU();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0090 fff8
void m68kOriLongImm32AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOr(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluOr(high16(reg_dt), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0098 fff8
void m68kOriLongImm32AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOr(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluOr(high16(reg_dt), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 00a0 fff8
void m68kOriLongImm32PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOr(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluOr(high16(reg_dt), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 00a8 fff8
void m68kOriLongImm32DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOr(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluOr(high16(reg_dt), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 00b0 fff8
void m68kOriLongImm32DaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOr(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluOr(high16(reg_dt), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 00b8 ffff
void m68kOriLongImm32Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluOr(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOr(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluOr(high16(reg_dt), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 00b9 ffff
void m68kOriLongImm32Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 00d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluOr(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOr(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluOr(high16(reg_dt), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0100 f1f8
void m68kBtstDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e7 btsr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[rx_index];
	    reg_au = reg_da[ry_index];
	    aluXor(reg_da[rx_index], reg_da[ry_index]);
	    // 0e7 btsr2
	    reg_t = testbit(reg_dcr, 4) ? 1 : 0;
	    reg_alub = reg_da[ry_index];
	    reg_au = reg_pc + 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto btsr3;
	    }
	    else
	    {
		goto bcsr4;
	    }
	bcsr4:
	    // 0c4 bcsr4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    aluAnd(reg_alub, (1 << (reg_dcr & 0xF)));
	    updateZ();
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    nextTrace();
	    return;
	btsr3:
	    // 044 btsr3
	    reg_ird = reg_ir;
	    setIntState();
	    aluAnd(high16(reg_da[ry_index]), (1 << (reg_dcr & 0xF)));
	    updateZ();
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0108 f1f8
void m68kMovepWordDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1d2 mpiw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 29a mpiw2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setReg8High(reg_dbin, reg_edb);
	    // 368 mpiw3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setReg8(reg_dbin, reg_edb);
	    // 36a mpiw4
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0110 f1f8
void m68kBtstDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAndByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0118 f1f8
void m68kBtstDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    aluXorByte(reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAndByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0120 f1f8
void m68kBtstDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    aluXorByte(reg_da[rx_index], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAndByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0128 f1f8
void m68kBtstDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAndByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0130 f1f8
void m68kBtstDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAndByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0138 f1ff
void m68kBtstDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluXorByte(reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAndByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0139 f1ff
void m68kBtstDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluXorByte(reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAndByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 013a f1ff
void m68kBtstDdDpcProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAndByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 013b f1ff
void m68kBtstDdDpciProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAndByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 013c f1ff
void m68kBtstDdImmProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 0ab btsi1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16High(reg_dt, high16(reg_at));
	    // 0e7 btsr2
	    reg_t = testbit(reg_dcr, 4) ? 1 : 0;
	    reg_alub = reg_dt;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dt, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto btsr3;
	    }
	    else
	    {
		goto bcsr4;
	    }
	bcsr4:
	    // 0c4 bcsr4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_dt, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFTUConst();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    nextTrace();
	    return;
	btsr3:
	    // 044 btsr3
	    reg_ird = reg_ir;
	    setIntState();
	    aluAndByte(high16(reg_dt), (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0140 f1f8
void m68kBchgDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3ef bcsr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[rx_index];
	    reg_au = reg_da[ry_index];
	    aluXor(reg_da[rx_index], reg_da[ry_index]);
	    // 06a bcsr2
	    reg_t = testbit(reg_dcr, 4) ? 1 : 0;
	    reg_alub = reg_da[ry_index];
	    reg_au = reg_pc + 2;
	    aluXor(reg_da[ry_index], (1 << (reg_dcr & 0xF)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto bcsr3;
	    }
	    else
	    {
		goto bcsr4;
	    }
	bcsr4:
	    // 0c4 bcsr4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    aluAnd(reg_alub, (1 << (reg_dcr & 0xF)));
	    updateZ();
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    nextTrace();
	    return;
	bcsr3:
	    // 084 bcsr3
	    reg_alub = high16(reg_da[ry_index]);
	    aluXor(high16(reg_da[ry_index]), (1 << (reg_dcr & 0xF)));
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 0a1 bcsr5
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    aluAnd(reg_alub, (1 << (reg_dcr & 0xF)));
	    updateZ();
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0148 f1f8
void m68kMovepLongDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1d6 mpil1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 29e mpil2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setReg8High(reg_dbin, reg_edb);
	    // 34e mpil3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setReg8(reg_dbin, reg_edb);
	    // 34f mpil4
	    reg_aob = reg_au;
	    setReg16High(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setReg8High(reg_dbin, reg_edb);
	    // 368 mpiw3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setReg8(reg_dbin, reg_edb);
	    // 36a mpiw4
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0150 f1f8
void m68kBchgDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 081 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluXorByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0158 f1f8
void m68kBchgDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    aluXorByte(reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 081 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluXorByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0160 f1f8
void m68kBchgDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    aluXorByte(reg_da[rx_index], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 081 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluXorByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0168 f1f8
void m68kBchgDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 081 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluXorByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0170 f1f8
void m68kBchgDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 081 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluXorByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0178 f1ff
void m68kBchgDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluXorByte(reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 081 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluXorByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0179 f1ff
void m68kBchgDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluXorByte(reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 081 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluXorByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0180 f1f8
void m68kBclrDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3eb bclr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[rx_index];
	    reg_au = reg_da[ry_index];
	    aluOr(reg_da[rx_index], reg_da[ry_index]);
	    // 06e bclr2
	    reg_t = testbit(reg_dcr, 4) ? 1 : 0;
	    reg_alub = reg_da[ry_index];
	    reg_au = reg_pc + 2;
	    aluOr(reg_da[ry_index], (1 << (reg_dcr & 0xF)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto bclr3;
	    }
	    else
	    {
		goto bclr4;
	    }
	bclr4:
	    // 0cc bclr4
	    aluXor(reg_aluo, (1 << (reg_dcr & 0xF)));
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 0c4 bcsr4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    aluAnd(reg_alub, (1 << (reg_dcr & 0xF)));
	    updateZ();
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	bclr3:
	    // 08c bclr3
	    reg_alub = high16(reg_da[ry_index]);
	    aluOr(high16(reg_da[ry_index]), (1 << (reg_dcr & 0xF)));
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    // 0c8 bclr5
	    aluXor(reg_aluo, (1 << (reg_dcr & 0xF)));
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    // 0a1 bcsr5
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    aluAnd(reg_alub, (1 << (reg_dcr & 0xF)));
	    updateZ();
	    setFTUConst();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0188 f1f8
void m68kMovepWordDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1ca mpow1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 36d mpow2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExHigh(reg_dbout, reg_da[rx_index]);
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 36e mpow3
	    reg_aob = reg_au;
	    setReg8ExLow(reg_dbout, reg_da[rx_index]);
	    reg_au = reg_pc + 4;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0190 f1f8
void m68kBclrDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 069 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    aluOrByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 067 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluXorByte(reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0198 f1f8
void m68kBclrDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 069 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    aluOrByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 067 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluXorByte(reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 01a0 f1f8
void m68kBclrDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_da[rx_index], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 069 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    aluOrByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 067 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluXorByte(reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 01a8 f1f8
void m68kBclrDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 069 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    aluOrByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 067 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluXorByte(reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 01b0 f1f8
void m68kBclrDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 069 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    aluOrByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 067 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluXorByte(reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 01b8 f1ff
void m68kBclrDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluOrByte(reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 069 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    aluOrByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 067 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluXorByte(reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 01b9 f1ff
void m68kBclrDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluOrByte(reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 069 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    aluOrByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 067 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluXorByte(reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 01c0 f1f8
void m68kBsetDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3ef bcsr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[rx_index];
	    reg_au = reg_da[ry_index];
	    aluOr(reg_da[rx_index], reg_da[ry_index]);
	    // 06a bcsr2
	    reg_t = testbit(reg_dcr, 4) ? 1 : 0;
	    reg_alub = reg_da[ry_index];
	    reg_au = reg_pc + 2;
	    aluOr(reg_da[ry_index], (1 << (reg_dcr & 0xF)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto bcsr3;
	    }
	    else
	    {
		goto bcsr4;
	    }
	bcsr4:
	    // 0c4 bcsr4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    aluAnd(reg_alub, (1 << (reg_dcr & 0xF)));
	    updateZ();
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    nextTrace();
	    return;
	bcsr3:
	    // 084 bcsr3
	    reg_alub = high16(reg_da[ry_index]);
	    aluOr(high16(reg_da[ry_index]), (1 << (reg_dcr & 0xF)));
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 0a1 bcsr5
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    aluAnd(reg_alub, (1 << (reg_dcr & 0xF)));
	    updateZ();
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 01c8 f1f8
void m68kMovepLongDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1ce mpol1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 36b mpol2
	    reg_aob = reg_au;
	    setReg8ExHigh(reg_dbout, high16(reg_da[rx_index]));
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 36c mpol3
	    reg_aob = reg_au;
	    setReg8ExLow(reg_dbout, high16(reg_da[rx_index]));
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 36d mpow2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExHigh(reg_dbout, reg_da[rx_index]);
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 36e mpow3
	    reg_aob = reg_au;
	    setReg8ExLow(reg_dbout, reg_da[rx_index]);
	    reg_au = reg_pc + 4;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 01d0 f1f8
void m68kBsetDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 081 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluOrByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 01d8 f1f8
void m68kBsetDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 081 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluOrByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 01e0 f1f8
void m68kBsetDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_da[rx_index], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 081 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluOrByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 01e8 f1f8
void m68kBsetDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 081 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluOrByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 01f0 f1f8
void m68kBsetDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 081 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluOrByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 01f8 f1ff
void m68kBsetDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluOrByte(reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 081 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluOrByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 01f9 f1ff
void m68kBsetDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluOrByte(reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 081 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluOrByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0200 fff8
void m68kAndiByteImm8DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 100 roaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    aluAndByte(reg_dt, reg_da[ry_index]);
	    updateNZVC();
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0210 fff8
void m68kAndiByteImm8AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAndByte(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0218 fff8
void m68kAndiByteImm8AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    aluAndByte(reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAndByte(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0220 fff8
void m68kAndiByteImm8PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    aluAndByte(reg_dt, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAndByte(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0228 fff8
void m68kAndiByteImm8DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAndByte(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0230 fff8
void m68kAndiByteImm8DaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAndByte(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0238 ffff
void m68kAndiByteImm8Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluAndByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAndByte(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0239 ffff
void m68kAndiByteImm8Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluAndByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAndByte(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 023c ffff
void m68kAndiImm8CcrProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1cc stiw1
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 307 stiw2
	    aluAndByte(reg_ftu, reg_dt);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 320 stiw3
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_aluo;
	    reg_au = reg_au + 2;
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0240 fff8
void m68kAndiWordImm16DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 100 roaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    aluAnd(reg_dt, reg_da[ry_index]);
	    updateNZVC();
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0250 fff8
void m68kAndiWordImm16AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0258 fff8
void m68kAndiWordImm16AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0260 fff8
void m68kAndiWordImm16PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - 2;
	    aluAnd(reg_dt, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0268 fff8
void m68kAndiWordImm16DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0270 fff8
void m68kAndiWordImm16DaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0278 ffff
void m68kAndiWordImm16Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluAnd(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0279 ffff
void m68kAndiWordImm16Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluAnd(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 027c ffff
void m68kAndiI16uSrProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    if (!testbit(reg_sr, 13))
	    {
		setPriv();
		return;
	    }

	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1cc stiw1
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 307 stiw2
	    aluAnd(reg_ftu, reg_dt);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 320 stiw3
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_aluo;
	    reg_au = reg_au + 2;
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
	    updateSupervisor();
	    updateInterrupts();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0280 fff8
void m68kAndiLongImm32DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 10c roal1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    aluAnd(reg_dt, reg_da[ry_index]);
	    updateNZVC();
	    // 259 roal2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25a roal3
	    aluAnd(high16(reg_dt), high16(reg_da[ry_index]));
	    updateNZVCU();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0290 fff8
void m68kAndiLongImm32AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAnd(high16(reg_dt), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0298 fff8
void m68kAndiLongImm32AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAnd(high16(reg_dt), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 02a0 fff8
void m68kAndiLongImm32PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAnd(high16(reg_dt), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 02a8 fff8
void m68kAndiLongImm32DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAnd(high16(reg_dt), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 02b0 fff8
void m68kAndiLongImm32DaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAnd(high16(reg_dt), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 02b8 ffff
void m68kAndiLongImm32Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluAnd(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAnd(high16(reg_dt), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 02b9 ffff
void m68kAndiLongImm32Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 00d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluAnd(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAnd(high16(reg_dt), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0400 fff8
void m68kSubiByteImm8DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 100 roaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    aluSubByte(reg_dt, reg_da[ry_index]);
	    updateXNZVC();
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0410 fff8
void m68kSubiByteImm8AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubByte(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0418 fff8
void m68kSubiByteImm8AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubByte(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0420 fff8
void m68kSubiByteImm8PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubByte(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0428 fff8
void m68kSubiByteImm8DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubByte(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0430 fff8
void m68kSubiByteImm8DaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubByte(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0438 ffff
void m68kSubiByteImm8Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubByte(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0439 ffff
void m68kSubiByteImm8Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubByte(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0440 fff8
void m68kSubiWordImm16DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 100 roaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    aluSub(reg_dt, reg_da[ry_index]);
	    updateXNZVC();
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0450 fff8
void m68kSubiWordImm16AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0458 fff8
void m68kSubiWordImm16AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0460 fff8
void m68kSubiWordImm16PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0468 fff8
void m68kSubiWordImm16DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0470 fff8
void m68kSubiWordImm16DaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0478 ffff
void m68kSubiWordImm16Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0479 ffff
void m68kSubiWordImm16Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0480 fff8
void m68kSubiLongImm32DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 10c roal1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    aluSub(reg_dt, reg_da[ry_index]);
	    updateXNZVC();
	    // 259 roal2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25a roal3
	    aluSubc(high16(reg_dt), high16(reg_da[ry_index]));
	    updateXNZVCU();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0490 fff8
void m68kSubiLongImm32AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluSubc(high16(reg_dt), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0498 fff8
void m68kSubiLongImm32AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluSubc(high16(reg_dt), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 04a0 fff8
void m68kSubiLongImm32PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluSubc(high16(reg_dt), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 04a8 fff8
void m68kSubiLongImm32DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluSubc(high16(reg_dt), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 04b0 fff8
void m68kSubiLongImm32DaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluSubc(high16(reg_dt), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 04b8 ffff
void m68kSubiLongImm32Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluSubc(high16(reg_dt), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 04b9 ffff
void m68kSubiLongImm32Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 00d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluSubc(high16(reg_dt), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0600 fff8
void m68kAddiByteImm8DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 100 roaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    aluAddByte(reg_dt, reg_da[ry_index]);
	    updateXNZVC();
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0610 fff8
void m68kAddiByteImm8AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAddByte(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0618 fff8
void m68kAddiByteImm8AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAddByte(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0620 fff8
void m68kAddiByteImm8PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAddByte(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0628 fff8
void m68kAddiByteImm8DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAddByte(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0630 fff8
void m68kAddiByteImm8DaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAddByte(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0638 ffff
void m68kAddiByteImm8Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAddByte(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0639 ffff
void m68kAddiByteImm8Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAddByte(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0640 fff8
void m68kAddiWordImm16DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 100 roaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    aluAdd(reg_dt, reg_da[ry_index]);
	    updateXNZVC();
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0650 fff8
void m68kAddiWordImm16AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAdd(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0658 fff8
void m68kAddiWordImm16AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAdd(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0660 fff8
void m68kAddiWordImm16PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAdd(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0668 fff8
void m68kAddiWordImm16DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAdd(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0670 fff8
void m68kAddiWordImm16DaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAdd(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0678 ffff
void m68kAddiWordImm16Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAdd(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0679 ffff
void m68kAddiWordImm16Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAdd(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0680 fff8
void m68kAddiLongImm32DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 10c roal1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    aluAdd(reg_dt, reg_da[ry_index]);
	    updateXNZVC();
	    // 259 roal2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25a roal3
	    aluAddc(high16(reg_dt), high16(reg_da[ry_index]));
	    updateXNZVCU();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0690 fff8
void m68kAddiLongImm32AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAdd(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAddc(high16(reg_dt), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0698 fff8
void m68kAddiLongImm32AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAdd(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAddc(high16(reg_dt), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 06a0 fff8
void m68kAddiLongImm32PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAdd(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAddc(high16(reg_dt), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 06a8 fff8
void m68kAddiLongImm32DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAdd(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAddc(high16(reg_dt), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 06b0 fff8
void m68kAddiLongImm32DaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAdd(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAddc(high16(reg_dt), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 06b8 ffff
void m68kAddiLongImm32Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAdd(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAddc(high16(reg_dt), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 06b9 ffff
void m68kAddiLongImm32Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 00d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAdd(reg_dt, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAddc(high16(reg_dt), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0800 fff8
void m68kBtstImm8DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 3e7 btsr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = reg_dt;
	    reg_au = reg_da[ry_index];
	    aluXor(reg_dt, reg_da[ry_index]);
	    // 0e7 btsr2
	    reg_t = testbit(reg_dcr, 4) ? 1 : 0;
	    reg_alub = reg_da[ry_index];
	    reg_au = reg_pc + 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto btsr3;
	    }
	    else
	    {
		goto bcsr4;
	    }
	bcsr4:
	    // 0c4 bcsr4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    aluAnd(reg_alub, (1 << (reg_dcr & 0xF)));
	    updateZ();
	    setFTUConst();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    nextTrace();
	    return;
	btsr3:
	    // 044 btsr3
	    reg_ird = reg_ir;
	    setIntState();
	    aluAnd(high16(reg_da[ry_index]), (1 << (reg_dcr & 0xF)));
	    updateZ();
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0810 fff8
void m68kBtstImm8AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAndByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0818 fff8
void m68kBtstImm8AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    aluXorByte(reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAndByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0820 fff8
void m68kBtstImm8PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    aluXorByte(reg_dt, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAndByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0828 fff8
void m68kBtstImm8DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAndByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0830 fff8
void m68kBtstImm8DaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAndByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0838 ffff
void m68kBtstImm8Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluXorByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAndByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0839 ffff
void m68kBtstImm8Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluXorByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAndByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 083a ffff
void m68kBtstImm8DpcProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(false, true, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAndByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 083b ffff
void m68kBtstImm8DpciProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(false, true, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 215 btsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAndByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0840 fff8
void m68kBchgImm8DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 3ef bcsr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = reg_dt;
	    reg_au = reg_da[ry_index];
	    aluXor(reg_dt, reg_da[ry_index]);
	    // 06a bcsr2
	    reg_t = testbit(reg_dcr, 4) ? 1 : 0;
	    reg_alub = reg_da[ry_index];
	    reg_au = reg_pc + 2;
	    aluXor(reg_da[ry_index], (1 << (reg_dcr & 0xF)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto bcsr3;
	    }
	    else
	    {
		goto bcsr4;
	    }
	bcsr4:
	    // 0c4 bcsr4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    aluAnd(reg_alub, (1 << (reg_dcr & 0xF)));
	    updateZ();
	    setFTUConst();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    nextTrace();
	    return;
	bcsr3:
	    // 084 bcsr3
	    reg_alub = high16(reg_da[ry_index]);
	    aluXor(high16(reg_da[ry_index]), (1 << (reg_dcr & 0xF)));
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 0a1 bcsr5
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    aluAnd(reg_alub, (1 << (reg_dcr & 0xF)));
	    updateZ();
	    setFTUConst();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0850 fff8
void m68kBchgImm8AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 081 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluXorByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0858 fff8
void m68kBchgImm8AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    aluXorByte(reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 081 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluXorByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0860 fff8
void m68kBchgImm8PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    aluXorByte(reg_dt, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 081 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluXorByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0868 fff8
void m68kBchgImm8DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 081 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluXorByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0870 fff8
void m68kBchgImm8DaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 081 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluXorByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0878 ffff
void m68kBchgImm8Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluXorByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 081 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluXorByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0879 ffff
void m68kBchgImm8Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluXorByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 081 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluXorByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0880 fff8
void m68kBclrImm8DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 3eb bclr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = reg_dt;
	    reg_au = reg_da[ry_index];
	    aluXor(reg_dt, reg_da[ry_index]);
	    // 06e bclr2
	    reg_t = testbit(reg_dcr, 4) ? 1 : 0;
	    reg_alub = reg_da[ry_index];
	    reg_au = reg_pc + 2;
	    aluXor(reg_da[ry_index], (1 << (reg_dcr & 0xF)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto bclr3;
	    }
	    else
	    {
		goto bclr4;
	    }
	bclr4:
	    // 0cc bclr4
	    aluXor(reg_aluo, (1 << (reg_dcr & 0xF)));
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 0c4 bcsr4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    aluAnd(reg_alub, (1 << (reg_dcr & 0xF)));
	    updateZ();
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	bclr3:
	    // 08c bclr3
	    reg_alub = high16(reg_da[ry_index]);
	    aluXor(high16(reg_da[ry_index]), (1 << (reg_dcr & 0xF)));
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    // 0c8 bclr5
	    aluXor(reg_aluo, (1 << (reg_dcr & 0xF)));
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    // 0a1 bcsr5
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    aluAnd(reg_alub, (1 << (reg_dcr & 0xF)));
	    updateZ();
	    setFTUConst();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0890 fff8
void m68kBclrImm8AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 069 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    aluXorByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 067 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluXorByte(reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0898 fff8
void m68kBclrImm8AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    aluXorByte(reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 069 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    aluXorByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 067 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluXorByte(reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 08a0 fff8
void m68kBclrImm8PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    aluXorByte(reg_dt, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 069 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    aluXorByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 067 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluXorByte(reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 08a8 fff8
void m68kBclrImm8DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 069 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    aluXorByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 067 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluXorByte(reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 08b0 fff8
void m68kBclrImm8DaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 069 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    aluXorByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 067 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluXorByte(reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 08b8 ffff
void m68kBclrImm8Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluXorByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 069 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    aluXorByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 067 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluXorByte(reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 08b9 ffff
void m68kBclrImm8Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluXorByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 069 bclm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    aluXorByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    // 067 bclm2
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluXorByte(reg_aluo, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 08c0 fff8
void m68kBsetImm8DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 3ef bcsr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = reg_dt;
	    reg_au = reg_da[ry_index];
	    aluXor(reg_dt, reg_da[ry_index]);
	    // 06a bcsr2
	    reg_t = testbit(reg_dcr, 4) ? 1 : 0;
	    reg_alub = reg_da[ry_index];
	    reg_au = reg_pc + 2;
	    aluXor(reg_da[ry_index], (1 << (reg_dcr & 0xF)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto bcsr3;
	    }
	    else
	    {
		goto bcsr4;
	    }
	bcsr4:
	    // 0c4 bcsr4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    aluAnd(reg_alub, (1 << (reg_dcr & 0xF)));
	    updateZ();
	    setFTUConst();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    nextTrace();
	    return;
	bcsr3:
	    // 084 bcsr3
	    reg_alub = high16(reg_da[ry_index]);
	    aluXor(high16(reg_da[ry_index]), (1 << (reg_dcr & 0xF)));
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 0a1 bcsr5
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    aluAnd(reg_alub, (1 << (reg_dcr & 0xF)));
	    updateZ();
	    setFTUConst();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 08d0 fff8
void m68kBsetImm8AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 081 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluXorByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 08d8 fff8
void m68kBsetImm8AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    aluXorByte(reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 081 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluXorByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 08e0 fff8
void m68kBsetImm8PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    aluXorByte(reg_dt, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 081 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluXorByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 08e8 fff8
void m68kBsetImm8DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 081 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluXorByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 08f0 fff8
void m68kBsetImm8DaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 081 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluXorByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 08f8 ffff
void m68kBsetImm8Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluXorByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 081 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluXorByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 08f9 ffff
void m68kBsetImm8Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluXorByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 081 bcsm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluXorByte(reg_dbin, (1 << (reg_dcr & 0x7)));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 082 bcsm2
	    reg_aob = reg_at;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    aluAndByte(reg_alub, (1 << (reg_dcr & 0x7)));
	    updateZ();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0a00 fff8
void m68kEoriByteImm8DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 100 roaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    aluXorByte(reg_dt, reg_da[ry_index]);
	    updateNZVC();
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0a10 fff8
void m68kEoriByteImm8AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXorByte(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0a18 fff8
void m68kEoriByteImm8AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    aluXorByte(reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXorByte(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0a20 fff8
void m68kEoriByteImm8PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    aluXorByte(reg_dt, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXorByte(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0a28 fff8
void m68kEoriByteImm8DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXorByte(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0a30 fff8
void m68kEoriByteImm8DaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXorByte(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0a38 ffff
void m68kEoriByteImm8Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluXorByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXorByte(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0a39 ffff
void m68kEoriByteImm8Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluXorByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXorByte(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0a3c ffff
void m68kEoriImm8CcrProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1cc stiw1
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 307 stiw2
	    aluXorByte(reg_ftu, reg_dt);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 320 stiw3
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_aluo;
	    reg_au = reg_au + 2;
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0a40 fff8
void m68kEoriWordImm16DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 100 roaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    aluXor(reg_dt, reg_da[ry_index]);
	    updateNZVC();
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0a50 fff8
void m68kEoriWordImm16AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXor(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0a58 fff8
void m68kEoriWordImm16AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluXor(reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXor(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0a60 fff8
void m68kEoriWordImm16PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - 2;
	    aluXor(reg_dt, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXor(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0a68 fff8
void m68kEoriWordImm16DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXor(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0a70 fff8
void m68kEoriWordImm16DaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXor(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0a78 ffff
void m68kEoriWordImm16Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluXor(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXor(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0a79 ffff
void m68kEoriWordImm16Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluXor(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXor(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0a7c ffff
void m68kEoriI16uSrProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    if (!testbit(reg_sr, 13))
	    {
		setPriv();
		return;
	    }

	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1cc stiw1
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 307 stiw2
	    aluXor(reg_ftu, reg_dt);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 320 stiw3
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_aluo;
	    reg_au = reg_au + 2;
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
	    updateSupervisor();
	    updateInterrupts();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0a80 fff8
void m68kEoriLongImm32DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 10c roal1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    aluXor(reg_dt, reg_da[ry_index]);
	    updateNZVC();
	    // 259 roal2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25a roal3
	    aluXor(high16(reg_dt), high16(reg_da[ry_index]));
	    updateNZVCU();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0a90 fff8
void m68kEoriLongImm32AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXor(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluXor(high16(reg_dt), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0a98 fff8
void m68kEoriLongImm32AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXor(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluXor(high16(reg_dt), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0aa0 fff8
void m68kEoriLongImm32PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXor(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluXor(high16(reg_dt), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0aa8 fff8
void m68kEoriLongImm32DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXor(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluXor(high16(reg_dt), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0ab0 fff8
void m68kEoriLongImm32DaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXor(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluXor(high16(reg_dt), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0ab8 ffff
void m68kEoriLongImm32Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluXor(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXor(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluXor(high16(reg_dt), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0ab9 ffff
void m68kEoriLongImm32Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 00d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluXor(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXor(reg_dt, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluXor(high16(reg_dt), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0c00 fff8
void m68kCmpiByteImm8DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 108 rcaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    aluSubByte(reg_dt, reg_da[ry_index]);
	    updateNZVC();
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0c10 fff8
void m68kCmpiByteImm8AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 087 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluSubByte(reg_dt, reg_dbin);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0c18 fff8
void m68kCmpiByteImm8AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 087 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluSubByte(reg_dt, reg_dbin);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0c20 fff8
void m68kCmpiByteImm8PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 087 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluSubByte(reg_dt, reg_dbin);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0c28 fff8
void m68kCmpiByteImm8DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 087 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluSubByte(reg_dt, reg_dbin);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0c30 fff8
void m68kCmpiByteImm8DaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 087 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluSubByte(reg_dt, reg_dbin);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0c38 ffff
void m68kCmpiByteImm8Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 087 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluSubByte(reg_dt, reg_dbin);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0c39 ffff
void m68kCmpiByteImm8Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 087 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluSubByte(reg_dt, reg_dbin);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0c40 fff8
void m68kCmpiWordImm16DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 108 rcaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    aluSub(reg_dt, reg_da[ry_index]);
	    updateNZVC();
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0c50 fff8
void m68kCmpiWordImm16AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 087 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluSub(reg_dt, reg_dbin);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0c58 fff8
void m68kCmpiWordImm16AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 087 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluSub(reg_dt, reg_dbin);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0c60 fff8
void m68kCmpiWordImm16PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 087 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluSub(reg_dt, reg_dbin);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0c68 fff8
void m68kCmpiWordImm16DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 087 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluSub(reg_dt, reg_dbin);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0c70 fff8
void m68kCmpiWordImm16DaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 087 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluSub(reg_dt, reg_dbin);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0c78 ffff
void m68kCmpiWordImm16Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 087 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluSub(reg_dt, reg_dbin);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0c79 ffff
void m68kCmpiWordImm16Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 087 cpdw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluSub(reg_dt, reg_dbin);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0c80 fff8
void m68kCmpiLongImm32DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 104 rcal1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    aluSub(reg_dt, reg_da[ry_index]);
	    updateNZVC();
	    // 239 rcal2
	    aluSubc(high16(reg_dt), high16(reg_da[ry_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 08d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0c90 fff8
void m68kCmpiLongImm32AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 08f cpdl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluSub(reg_dt, reg_dbin);
	    updateNZVC();
	    // 171 cpdl2
	    reg_ird = reg_ir;
	    setIntState();
	    aluSubc(high16(reg_dt), reg_alue);
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0c98 fff8
void m68kCmpiLongImm32AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 08f cpdl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluSub(reg_dt, reg_dbin);
	    updateNZVC();
	    // 171 cpdl2
	    reg_ird = reg_ir;
	    setIntState();
	    aluSubc(high16(reg_dt), reg_alue);
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0ca0 fff8
void m68kCmpiLongImm32PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 08f cpdl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluSub(reg_dt, reg_dbin);
	    updateNZVC();
	    // 171 cpdl2
	    reg_ird = reg_ir;
	    setIntState();
	    aluSubc(high16(reg_dt), reg_alue);
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0ca8 fff8
void m68kCmpiLongImm32DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 08f cpdl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluSub(reg_dt, reg_dbin);
	    updateNZVC();
	    // 171 cpdl2
	    reg_ird = reg_ir;
	    setIntState();
	    aluSubc(high16(reg_dt), reg_alue);
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0cb0 fff8
void m68kCmpiLongImm32DaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 08f cpdl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluSub(reg_dt, reg_dbin);
	    updateNZVC();
	    // 171 cpdl2
	    reg_ird = reg_ir;
	    setIntState();
	    aluSubc(high16(reg_dt), reg_alue);
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0cb8 ffff
void m68kCmpiLongImm32Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 08f cpdl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluSub(reg_dt, reg_dbin);
	    updateNZVC();
	    // 171 cpdl2
	    reg_ird = reg_ir;
	    setIntState();
	    aluSubc(high16(reg_dt), reg_alue);
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 0cb9 ffff
void m68kCmpiLongImm32Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e0 o#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b9 o#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 00d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 08f cpdl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluSub(reg_dt, reg_dbin);
	    updateNZVC();
	    // 171 cpdl2
	    reg_ird = reg_ir;
	    setIntState();
	    aluSubc(high16(reg_dt), reg_alue);
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 1000 f1f8
void m68kMoveByteDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 121 rrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    aluAndByte(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 1010 f1f8
void m68kMoveByteAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg8(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 1018 f1f8
void m68kMoveByteAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg8(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 1020 f1f8
void m68kMoveBytePaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg8(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 1028 f1f8
void m68kMoveByteDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg8(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 1030 f1f8
void m68kMoveByteDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg8(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 1038 f1ff
void m68kMoveByteAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg8(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 1039 f1ff
void m68kMoveByteAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg8(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 103a f1ff
void m68kMoveByteDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg8(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 103b f1ff
void m68kMoveByteDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg8(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 103c f1ff
void m68kMoveByteImm8DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 121 rrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_dt;
	    reg_au = reg_au + 2;
	    aluAndByte(reg_dt, 0xFFFF);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 1080 f1f8
void m68kMoveByteDsAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2fa rmrw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_da[ry_index]);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ((rx_index < 15) ? 1 : 2);
	    aluAndByte(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 1090 f1f8
void m68kMoveByteAisAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ((rx_index < 15) ? 1 : 2);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 1098 f1f8
void m68kMoveByteAipsAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ((rx_index < 15) ? 1 : 2);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 10a0 f1f8
void m68kMoveBytePaisAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ((rx_index < 15) ? 1 : 2);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 10a8 f1f8
void m68kMoveByteDasAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ((rx_index < 15) ? 1 : 2);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 10b0 f1f8
void m68kMoveByteDaisAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ((rx_index < 15) ? 1 : 2);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 10b8 f1ff
void m68kMoveByteAdr16AidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ((rx_index < 15) ? 1 : 2);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 10b9 f1ff
void m68kMoveByteAdr32AidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ((rx_index < 15) ? 1 : 2);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 10ba f1ff
void m68kMoveByteDpcAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ((rx_index < 15) ? 1 : 2);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 10bb f1ff
void m68kMoveByteDpciAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ((rx_index < 15) ? 1 : 2);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 10bc f1ff
void m68kMoveByteImm8AidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2fa rmrw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_dt);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ((rx_index < 15) ? 1 : 2);
	    aluAndByte(reg_dt, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 10c0 f1f8
void m68kMoveByteDsAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2fe rmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_da[ry_index]);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ((rx_index < 15) ? 1 : 2);
	    aluAndByte(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 10d0 f1f8
void m68kMoveByteAisAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ((rx_index < 15) ? 1 : 2);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 10d8 f1f8
void m68kMoveByteAipsAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ((rx_index < 15) ? 1 : 2);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 10e0 f1f8
void m68kMoveBytePaisAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ((rx_index < 15) ? 1 : 2);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 10e8 f1f8
void m68kMoveByteDasAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ((rx_index < 15) ? 1 : 2);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 10f0 f1f8
void m68kMoveByteDaisAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ((rx_index < 15) ? 1 : 2);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 10f8 f1ff
void m68kMoveByteAdr16AipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ((rx_index < 15) ? 1 : 2);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 10f9 f1ff
void m68kMoveByteAdr32AipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ((rx_index < 15) ? 1 : 2);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 10fa f1ff
void m68kMoveByteDpcAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ((rx_index < 15) ? 1 : 2);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 10fb f1ff
void m68kMoveByteDpciAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_dbin);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ((rx_index < 15) ? 1 : 2);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 10fc f1ff
void m68kMoveByteImm8AipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2fe rmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_dt);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ((rx_index < 15) ? 1 : 2);
	    aluAndByte(reg_dt, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 1100 f1f8
void m68kMoveByteDsPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2f8 rmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    aluAndByte(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 1110 f1f8
void m68kMoveByteAisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 1118 f1f8
void m68kMoveByteAipsPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 1120 f1f8
void m68kMoveBytePaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 1128 f1f8
void m68kMoveByteDasPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 1130 f1f8
void m68kMoveByteDaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 1138 f1ff
void m68kMoveByteAdr16PaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 1139 f1ff
void m68kMoveByteAdr32PaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 113a f1ff
void m68kMoveByteDpcPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 113b f1ff
void m68kMoveByteDpciPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 113c f1ff
void m68kMoveByteImm8PaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2f8 rmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    aluAndByte(reg_dt, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 1140 f1f8
void m68kMoveByteDsDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2da rmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 2db rmdw2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_da[ry_index]);
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 1150 f1f8
void m68kMoveByteAisDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 1158 f1f8
void m68kMoveByteAipsDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 1160 f1f8
void m68kMoveBytePaisDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 1168 f1f8
void m68kMoveByteDasDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 1170 f1f8
void m68kMoveByteDaisDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 1178 f1ff
void m68kMoveByteAdr16DadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 1179 f1ff
void m68kMoveByteAdr32DadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 117a f1ff
void m68kMoveByteDpcDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 117b f1ff
void m68kMoveByteDpciDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 117c f1ff
void m68kMoveByteImm8DadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2da rmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 2db rmdw2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_dt);
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dt, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 1180 f1f8
void m68kMoveByteDsDaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1eb rmxw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 109 rmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto rmxw3;
	    }
	    else
	    {
		goto rmxw2;
	    }
	rmxw2:
	    // 128 rmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto rmdw2;
	rmxw3:
	    // 1e8 rmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto rmdw2;
	rmdw2:
	    // 2db rmdw2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_da[ry_index]);
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 1190 f1f8
void m68kMoveByteAisDaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    aluExt(reg_aluo);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxw3;
	    }
	    else
	    {
		goto mmxw2;
	    }
	mmxw2:
	    // 028 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto maww2;
	mmxw3:
	    // 0e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto maww2;
	maww2:
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 1198 f1f8
void m68kMoveByteAipsDaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    aluExt(reg_aluo);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxw3;
	    }
	    else
	    {
		goto mmxw2;
	    }
	mmxw2:
	    // 028 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto maww2;
	mmxw3:
	    // 0e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto maww2;
	maww2:
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 11a0 f1f8
void m68kMoveBytePaisDaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    aluExt(reg_aluo);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxw3;
	    }
	    else
	    {
		goto mmxw2;
	    }
	mmxw2:
	    // 028 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto maww2;
	mmxw3:
	    // 0e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto maww2;
	maww2:
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 11a8 f1f8
void m68kMoveByteDasDaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    aluExt(reg_aluo);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxw3;
	    }
	    else
	    {
		goto mmxw2;
	    }
	mmxw2:
	    // 028 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto maww2;
	mmxw3:
	    // 0e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto maww2;
	maww2:
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 11b0 f1f8
void m68kMoveByteDaisDaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    aluExt(reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxw3;
	    }
	    else
	    {
		goto mmxw2;
	    }
	mmxw2:
	    // 028 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto maww2;
	mmxw3:
	    // 0e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto maww2;
	maww2:
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 11b8 f1ff
void m68kMoveByteAdr16DaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    aluExt(reg_aluo);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxw3;
	    }
	    else
	    {
		goto mmxw2;
	    }
	mmxw2:
	    // 028 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto maww2;
	mmxw3:
	    // 0e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto maww2;
	maww2:
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 11b9 f1ff
void m68kMoveByteAdr32DaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    aluExt(reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxw3;
	    }
	    else
	    {
		goto mmxw2;
	    }
	mmxw2:
	    // 028 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto maww2;
	mmxw3:
	    // 0e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto maww2;
	maww2:
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 11ba f1ff
void m68kMoveByteDpcDaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    aluExt(reg_aluo);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxw3;
	    }
	    else
	    {
		goto mmxw2;
	    }
	mmxw2:
	    // 028 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto maww2;
	mmxw3:
	    // 0e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto maww2;
	maww2:
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 11bb f1ff
void m68kMoveByteDpciDaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    aluExt(reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxw3;
	    }
	    else
	    {
		goto mmxw2;
	    }
	mmxw2:
	    // 028 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto maww2;
	mmxw3:
	    // 0e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto maww2;
	maww2:
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 11bc f1ff
void m68kMoveByteImm8DaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1eb rmxw0
	    aluExt(reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 109 rmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto rmxw3;
	    }
	    else
	    {
		goto rmxw2;
	    }
	rmxw2:
	    // 128 rmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto rmdw2;
	rmxw3:
	    // 1e8 rmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto rmdw2;
	rmdw2:
	    // 2db rmdw2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_dt);
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dt, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 11c0 fff8
void m68kMoveByteDsAdr16Program()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2d9 raww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_da[ry_index]);
	    reg_au = ext32(reg_dbin);
	    aluAndByte(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 11d0 fff8
void m68kMoveByteAisAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 11d8 fff8
void m68kMoveByteAipsAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 11e0 fff8
void m68kMoveBytePaisAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 11e8 fff8
void m68kMoveByteDasAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 11f0 fff8
void m68kMoveByteDaisAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 11f8 ffff
void m68kMoveByteAdr16Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 11f9 ffff
void m68kMoveByteAdr32Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 11fa ffff
void m68kMoveByteDpcAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 11fb ffff
void m68kMoveByteDpciAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 11fc ffff
void m68kMoveByteImm8Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2d9 raww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dt);
	    reg_au = ext32(reg_dbin);
	    aluAndByte(reg_dt, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 13c0 fff8
void m68kMoveByteDsAdr32Program()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1ea ralw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2bb ralw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_da[ry_index]);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluAndByte(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 13d0 fff8
void m68kMoveByteAisAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 13d8 fff8
void m68kMoveByteAipsAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 13e0 fff8
void m68kMoveBytePaisAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 13e8 fff8
void m68kMoveByteDasAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 13f0 fff8
void m68kMoveByteDaisAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 13f8 ffff
void m68kMoveByteAdr16Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 13f9 ffff
void m68kMoveByteAdr32Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 13fa ffff
void m68kMoveByteDpcAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 13fb ffff
void m68kMoveByteDpciAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 13fc ffff
void m68kMoveByteImm8Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1ea ralw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2bb ralw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dt);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluAndByte(reg_dt, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2000 f1f8
void m68kMoveLongDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 129 rrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    // 278 rrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    updateNZU();
	    reg_da[rx_index] = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2008 f1f8
void m68kMoveLongAsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 129 rrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    // 278 rrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_at;
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    updateNZU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2010 f1f8
void m68kMoveLongAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2018 f1f8
void m68kMoveLongAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2020 f1f8
void m68kMoveLongPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2028 f1f8
void m68kMoveLongDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2030 f1f8
void m68kMoveLongDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2038 f1ff
void m68kMoveLongAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2039 f1ff
void m68kMoveLongAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 00d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 203a f1ff
void m68kMoveLongDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 203b f1ff
void m68kMoveLongDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 203c f1ff
void m68kMoveLongImm32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 129 rrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_dt;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dt, 0xFFFF);
	    updateNZVC();
	    // 278 rrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_at;
	    aluAnd(high16(reg_dt), 0xFFFF);
	    updateNZU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2040 f1f8
void m68kMoveaLongDsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 129 rrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    // 278 rrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_at;
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2048 f1f8
void m68kMoveaLongAsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 129 rrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    // 278 rrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    reg_da[rx_index] = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2050 f1f8
void m68kMoveaLongAisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2058 f1f8
void m68kMoveaLongAipsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2060 f1f8
void m68kMoveaLongPaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2068 f1f8
void m68kMoveaLongDasAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2070 f1f8
void m68kMoveaLongDaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2078 f1ff
void m68kMoveaLongAdr16AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2079 f1ff
void m68kMoveaLongAdr32AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 00d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 207a f1ff
void m68kMoveaLongDpcAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 207b f1ff
void m68kMoveaLongDpciAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29f mrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 36f mrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_alue);
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 207c f1ff
void m68kMoveaLongImm32AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 129 rrgl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_dt;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dt, 0xFFFF);
	    // 278 rrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_at;
	    aluAnd(high16(reg_dt), 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2080 f1f8
void m68kMoveLongDsAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2f9 rmrl1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = high16(reg_da[ry_index]);
	    reg_alub = high16(reg_da[ry_index]);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 23f rmrl2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_au = reg_pc;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 258 rmrl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2088 f1f8
void m68kMoveLongAsAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2f9 rmrl1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = high16(reg_da[ry_index]);
	    reg_alub = high16(reg_da[ry_index]);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 23f rmrl2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_au = reg_pc;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 258 rmrl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2090 f1f8
void m68kMoveLongAisAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3a9 mmrl1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 3aa mmrl2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2098 f1f8
void m68kMoveLongAipsAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3a9 mmrl1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 3aa mmrl2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 20a0 f1f8
void m68kMoveLongPaisAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3a9 mmrl1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 3aa mmrl2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 20a8 f1f8
void m68kMoveLongDasAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3a9 mmrl1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 3aa mmrl2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 20b0 f1f8
void m68kMoveLongDaisAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3a9 mmrl1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 3aa mmrl2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 20b8 f1ff
void m68kMoveLongAdr16AidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3a9 mmrl1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 3aa mmrl2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 20b9 f1ff
void m68kMoveLongAdr32AidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 00d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3a9 mmrl1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 3aa mmrl2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 20ba f1ff
void m68kMoveLongDpcAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3a9 mmrl1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 3aa mmrl2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 20bb f1ff
void m68kMoveLongDpciAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3a9 mmrl1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 3aa mmrl2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 20bc f1ff
void m68kMoveLongImm32AidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2f9 rmrl1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = high16(reg_dt);
	    reg_alub = high16(reg_dt);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 23f rmrl2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dt;
	    reg_au = reg_pc;
	    aluAnd(reg_dt, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 258 rmrl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 20c0 f1f8
void m68kMoveLongDsAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2fd rmil1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = high16(reg_da[ry_index]);
	    reg_alub = high16(reg_da[ry_index]);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 23c rmil2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 23d rmil3
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 20c8 f1f8
void m68kMoveLongAsAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2fd rmil1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = high16(reg_da[ry_index]);
	    reg_alub = high16(reg_da[ry_index]);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 23c rmil2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 23d rmil3
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 20d0 f1f8
void m68kMoveLongAisAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3ad mmil1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 3ae mmil2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 20d8 f1f8
void m68kMoveLongAipsAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3ad mmil1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 3ae mmil2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 20e0 f1f8
void m68kMoveLongPaisAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3ad mmil1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 3ae mmil2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 20e8 f1f8
void m68kMoveLongDasAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3ad mmil1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 3ae mmil2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 20f0 f1f8
void m68kMoveLongDaisAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3ad mmil1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 3ae mmil2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 20f8 f1ff
void m68kMoveLongAdr16AipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3ad mmil1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 3ae mmil2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 20f9 f1ff
void m68kMoveLongAdr32AipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 00d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3ad mmil1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 3ae mmil2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 20fa f1ff
void m68kMoveLongDpcAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3ad mmil1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 3ae mmil2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 20fb f1ff
void m68kMoveLongDpciAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3ad mmil1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_alue;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 3ae mmil2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 20fc f1ff
void m68kMoveLongImm32AipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2fd rmil1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = high16(reg_dt);
	    reg_alub = high16(reg_dt);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 23c rmil2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dt;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dt, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 23d rmil3
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2100 f1f8
void m68kMoveLongDsPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2fc rmml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 23e rmml2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2108 f1f8
void m68kMoveLongAsPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2fc rmml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 23e rmml2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2110 f1f8
void m68kMoveLongAisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38f mmml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34a mmml2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2118 f1f8
void m68kMoveLongAipsPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38f mmml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34a mmml2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2120 f1f8
void m68kMoveLongPaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38f mmml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34a mmml2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2128 f1f8
void m68kMoveLongDasPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38f mmml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34a mmml2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2130 f1f8
void m68kMoveLongDaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38f mmml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34a mmml2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2138 f1ff
void m68kMoveLongAdr16PaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38f mmml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34a mmml2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2139 f1ff
void m68kMoveLongAdr32PaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 00d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38f mmml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34a mmml2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 213a f1ff
void m68kMoveLongDpcPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38f mmml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34a mmml2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 213b f1ff
void m68kMoveLongDpciPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38f mmml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34a mmml2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 213c f1ff
void m68kMoveLongImm32PaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2fc rmml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    aluAnd(reg_dt, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 23e rmml2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAnd(high16(reg_dt), 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2140 f1f8
void m68kMoveLongDsDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2de rmdl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 2be rmdl2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_da[ry_index]);
	    reg_alub = high16(reg_da[ry_index]);
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 2df rmdl3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_au = reg_pc + 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 258 rmrl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2148 f1f8
void m68kMoveLongAsDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2de rmdl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 2be rmdl2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_da[ry_index]);
	    reg_alub = high16(reg_da[ry_index]);
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 2df rmdl3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_au = reg_pc + 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 258 rmrl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2150 f1f8
void m68kMoveLongAisDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38e mmdl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2158 f1f8
void m68kMoveLongAipsDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38e mmdl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2160 f1f8
void m68kMoveLongPaisDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38e mmdl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2168 f1f8
void m68kMoveLongDasDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38e mmdl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2170 f1f8
void m68kMoveLongDaisDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38e mmdl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2178 f1ff
void m68kMoveLongAdr16DadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38e mmdl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2179 f1ff
void m68kMoveLongAdr32DadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 00d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38e mmdl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 217a f1ff
void m68kMoveLongDpcDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38e mmdl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 217b f1ff
void m68kMoveLongDpciDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38e mmdl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 217c f1ff
void m68kMoveLongImm32DadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2de rmdl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 2be rmdl2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_dt);
	    reg_alub = high16(reg_dt);
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_dt), 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 2df rmdl3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dt;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dt, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 258 rmrl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2180 f1f8
void m68kMoveLongDsDaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1ef rmxl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 105 rmxl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto rmxl3;
	    }
	    else
	    {
		goto rmxl2;
	    }
	rmxl2:
	    // 12c rmxl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto rmdl2;
	rmxl3:
	    // 1ec rmxl3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto rmdl2;
	rmdl2:
	    // 2be rmdl2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_da[ry_index]);
	    reg_alub = high16(reg_da[ry_index]);
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 2df rmdl3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_au = reg_pc + 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 258 rmrl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2188 f1f8
void m68kMoveLongAsDaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1ef rmxl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 105 rmxl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto rmxl3;
	    }
	    else
	    {
		goto rmxl2;
	    }
	rmxl2:
	    // 12c rmxl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto rmdl2;
	rmxl3:
	    // 1ec rmxl3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto rmdl2;
	rmdl2:
	    // 2be rmdl2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_da[ry_index]);
	    reg_alub = high16(reg_da[ry_index]);
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 2df rmdl3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_au = reg_pc + 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 258 rmrl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2190 f1f8
void m68kMoveLongAisDaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29c mmxl0
	    aluExt(reg_aluo);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 10d mmxl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxl3;
	    }
	    else
	    {
		goto mmxl2;
	    }
	mmxl2:
	    // 02c mmxl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto mawl2;
	mmxl3:
	    // 0ec mmxl3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto mawl2;
	mawl2:
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 2198 f1f8
void m68kMoveLongAipsDaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29c mmxl0
	    aluExt(reg_aluo);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 10d mmxl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxl3;
	    }
	    else
	    {
		goto mmxl2;
	    }
	mmxl2:
	    // 02c mmxl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto mawl2;
	mmxl3:
	    // 0ec mmxl3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto mawl2;
	mawl2:
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 21a0 f1f8
void m68kMoveLongPaisDaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29c mmxl0
	    aluExt(reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 10d mmxl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxl3;
	    }
	    else
	    {
		goto mmxl2;
	    }
	mmxl2:
	    // 02c mmxl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto mawl2;
	mmxl3:
	    // 0ec mmxl3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto mawl2;
	mawl2:
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 21a8 f1f8
void m68kMoveLongDasDaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29c mmxl0
	    aluExt(reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 10d mmxl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxl3;
	    }
	    else
	    {
		goto mmxl2;
	    }
	mmxl2:
	    // 02c mmxl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto mawl2;
	mmxl3:
	    // 0ec mmxl3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto mawl2;
	mawl2:
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 21b0 f1f8
void m68kMoveLongDaisDaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29c mmxl0
	    aluExt(reg_aluo);
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 10d mmxl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxl3;
	    }
	    else
	    {
		goto mmxl2;
	    }
	mmxl2:
	    // 02c mmxl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto mawl2;
	mmxl3:
	    // 0ec mmxl3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto mawl2;
	mawl2:
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 21b8 f1ff
void m68kMoveLongAdr16DaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29c mmxl0
	    aluExt(reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 10d mmxl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxl3;
	    }
	    else
	    {
		goto mmxl2;
	    }
	mmxl2:
	    // 02c mmxl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto mawl2;
	mmxl3:
	    // 0ec mmxl3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto mawl2;
	mawl2:
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 21b9 f1ff
void m68kMoveLongAdr32DaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 00d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29c mmxl0
	    aluExt(reg_aluo);
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 10d mmxl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxl3;
	    }
	    else
	    {
		goto mmxl2;
	    }
	mmxl2:
	    // 02c mmxl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto mawl2;
	mmxl3:
	    // 0ec mmxl3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto mawl2;
	mawl2:
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 21ba f1ff
void m68kMoveLongDpcDaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29c mmxl0
	    aluExt(reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 10d mmxl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxl3;
	    }
	    else
	    {
		goto mmxl2;
	    }
	mmxl2:
	    // 02c mmxl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto mawl2;
	mmxl3:
	    // 0ec mmxl3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto mawl2;
	mawl2:
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 21bb f1ff
void m68kMoveLongDpciDaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29c mmxl0
	    aluExt(reg_aluo);
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 10d mmxl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxl3;
	    }
	    else
	    {
		goto mmxl2;
	    }
	mmxl2:
	    // 02c mmxl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto mawl2;
	mmxl3:
	    // 0ec mmxl3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto mawl2;
	mawl2:
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 21bc f1ff
void m68kMoveLongImm32DaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1ef rmxl0
	    aluExt(reg_dbin);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 105 rmxl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto rmxl3;
	    }
	    else
	    {
		goto rmxl2;
	    }
	rmxl2:
	    // 12c rmxl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto rmdl2;
	rmxl3:
	    // 1ec rmxl3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto rmdl2;
	rmdl2:
	    // 2be rmdl2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_dt);
	    reg_alub = high16(reg_dt);
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_dt), 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 2df rmdl3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dt;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dt, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 258 rmrl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 21c0 fff8
void m68kMoveLongDsAdr16Program()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2dd rawl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_da[ry_index]);
	    reg_au = ext32(reg_dbin);
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 2ba rall3
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_da[ry_index]);
	    reg_alub = high16(reg_da[ry_index]);
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 21c8 fff8
void m68kMoveLongAsAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2dd rawl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_da[ry_index]);
	    reg_au = ext32(reg_dbin);
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 2ba rall3
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_da[ry_index]);
	    reg_alub = high16(reg_da[ry_index]);
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 21d0 fff8
void m68kMoveLongAisAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38c mawl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 21d8 fff8
void m68kMoveLongAipsAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38c mawl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 21e0 fff8
void m68kMoveLongPaisAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38c mawl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 21e8 fff8
void m68kMoveLongDasAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38c mawl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 21f0 fff8
void m68kMoveLongDaisAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38c mawl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 21f8 ffff
void m68kMoveLongAdr16Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38c mawl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 21f9 ffff
void m68kMoveLongAdr32Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 00d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38c mawl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 21fa ffff
void m68kMoveLongDpcAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38c mawl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 21fb ffff
void m68kMoveLongDpciAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38c mawl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 32f mawl2
	    reg_aob = reg_au;
	    reg_dbout = reg_alue;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 21fc ffff
void m68kMoveLongImm32Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2dd rawl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dt);
	    reg_au = ext32(reg_dbin);
	    aluAnd(reg_dt, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 2ba rall3
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_dt);
	    reg_alub = high16(reg_dt);
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_dt), 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 23c0 fff8
void m68kMoveLongDsAdr32Program()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1ee rall1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2bf rall2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_da[ry_index]);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 2ba rall3
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_da[ry_index]);
	    reg_alub = high16(reg_da[ry_index]);
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 23c8 fff8
void m68kMoveLongAsAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1ee rall1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2bf rall2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_da[ry_index]);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 2ba rall3
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_da[ry_index]);
	    reg_alub = high16(reg_da[ry_index]);
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 23d0 fff8
void m68kMoveLongAisAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 30f mall1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dbin);
	    setReg16High(reg_at, reg_aluo);
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 329 mall2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_dbout = reg_aluo;
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 32a mall3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 23d8 fff8
void m68kMoveLongAipsAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 30f mall1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dbin);
	    setReg16High(reg_at, reg_aluo);
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 329 mall2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_dbout = reg_aluo;
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 32a mall3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 23e0 fff8
void m68kMoveLongPaisAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 30f mall1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dbin);
	    setReg16High(reg_at, reg_aluo);
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 329 mall2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_dbout = reg_aluo;
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 32a mall3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 23e8 fff8
void m68kMoveLongDasAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 30f mall1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dbin);
	    setReg16High(reg_at, reg_aluo);
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 329 mall2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_dbout = reg_aluo;
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 32a mall3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 23f0 fff8
void m68kMoveLongDaisAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 30f mall1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dbin);
	    setReg16High(reg_at, reg_aluo);
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 329 mall2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_dbout = reg_aluo;
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 32a mall3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 23f8 ffff
void m68kMoveLongAdr16Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 30f mall1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dbin);
	    setReg16High(reg_at, reg_aluo);
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 329 mall2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_dbout = reg_aluo;
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 32a mall3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 23f9 ffff
void m68kMoveLongAdr32Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 00d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 30f mall1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dbin);
	    setReg16High(reg_at, reg_aluo);
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 329 mall2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_dbout = reg_aluo;
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 32a mall3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 23fa ffff
void m68kMoveLongDpcAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 30f mall1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dbin);
	    setReg16High(reg_at, reg_aluo);
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 329 mall2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_dbout = reg_aluo;
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 32a mall3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 23fb ffff
void m68kMoveLongDpciAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 30f mall1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dbin);
	    setReg16High(reg_at, reg_aluo);
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 329 mall2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_dbout = reg_aluo;
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 32a mall3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 23fc ffff
void m68kMoveLongImm32Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1ee rall1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2bf rall2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dt);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluAnd(reg_dt, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 2ba rall3
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_dt);
	    reg_alub = high16(reg_dt);
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_dt), 0xFFFF);
	    updateNZU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3000 f1f8
void m68kMoveWordDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 121 rrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3008 f1f8
void m68kMoveWordAsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 121 rrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3010 f1f8
void m68kMoveWordAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3018 f1f8
void m68kMoveWordAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3020 f1f8
void m68kMoveWordPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3028 f1f8
void m68kMoveWordDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3030 f1f8
void m68kMoveWordDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3038 f1ff
void m68kMoveWordAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3039 f1ff
void m68kMoveWordAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 303a f1ff
void m68kMoveWordDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 303b f1ff
void m68kMoveWordDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29b mrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 303c f1ff
void m68kMoveWordImm16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 121 rrgw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_dt;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dt, 0xFFFF);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3040 f1f8
void m68kMoveaWordDsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 279 rrgm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    reg_au = reg_au + 2;
	    // 278 rrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_at;
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3048 f1f8
void m68kMoveaWordAsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 279 rrgm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    reg_au = reg_au + 2;
	    // 278 rrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    reg_da[rx_index] = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3050 f1f8
void m68kMoveaWordAisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 158 mrgm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_da[rx_index] = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3058 f1f8
void m68kMoveaWordAipsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 158 mrgm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_da[rx_index] = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3060 f1f8
void m68kMoveaWordPaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 158 mrgm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_da[rx_index] = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3068 f1f8
void m68kMoveaWordDasAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 158 mrgm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_da[rx_index] = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3070 f1f8
void m68kMoveaWordDaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 158 mrgm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_da[rx_index] = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3078 f1ff
void m68kMoveaWordAdr16AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 158 mrgm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_da[rx_index] = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3079 f1ff
void m68kMoveaWordAdr32AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 158 mrgm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_da[rx_index] = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 307a f1ff
void m68kMoveaWordDpcAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 158 mrgm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_da[rx_index] = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 307b f1ff
void m68kMoveaWordDpciAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 158 mrgm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_da[rx_index] = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 307c f1ff
void m68kMoveaWordImm16AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 279 rrgm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    reg_au = reg_au + 2;
	    // 278 rrgl2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_at;
	    aluAnd(high16(reg_dt), 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3080 f1f8
void m68kMoveWordDsAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2fa rmrw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3088 f1f8
void m68kMoveWordAsAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2fa rmrw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3090 f1f8
void m68kMoveWordAisAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3098 f1f8
void m68kMoveWordAipsAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 30a0 f1f8
void m68kMoveWordPaisAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 30a8 f1f8
void m68kMoveWordDasAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 30b0 f1f8
void m68kMoveWordDaisAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 30b8 f1ff
void m68kMoveWordAdr16AidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 30b9 f1ff
void m68kMoveWordAdr32AidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 30ba f1ff
void m68kMoveWordDpcAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 30bb f1ff
void m68kMoveWordDpciAidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3ab mmrw1
	    reg_aob = reg_da[rx_index];
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 30bc f1ff
void m68kMoveWordImm16AidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2fa rmrw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dt;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_dt, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 30c0 f1f8
void m68kMoveWordDsAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2fe rmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 30c8 f1f8
void m68kMoveWordAsAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2fe rmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 30d0 f1f8
void m68kMoveWordAisAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 30d8 f1f8
void m68kMoveWordAipsAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 30e0 f1f8
void m68kMoveWordPaisAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 30e8 f1f8
void m68kMoveWordDasAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 30f0 f1f8
void m68kMoveWordDaisAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 30f8 f1ff
void m68kMoveWordAdr16AipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 30f9 f1ff
void m68kMoveWordAdr32AipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 30fa f1ff
void m68kMoveWordDpcAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 30fb f1ff
void m68kMoveWordDpciAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3af mmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dbin;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 30fc f1ff
void m68kMoveWordImm16AipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2fe rmiw1
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dt;
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_dt, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3100 f1f8
void m68kMoveWordDsPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2f8 rmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3108 f1f8
void m68kMoveWordAsPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2f8 rmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3110 f1f8
void m68kMoveWordAisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3118 f1f8
void m68kMoveWordAipsPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3120 f1f8
void m68kMoveWordPaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3128 f1f8
void m68kMoveWordDasPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3130 f1f8
void m68kMoveWordDaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3138 f1ff
void m68kMoveWordAdr16PaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3139 f1ff
void m68kMoveWordAdr32PaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 313a f1ff
void m68kMoveWordDpcPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 313b f1ff
void m68kMoveWordDpciPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38b mmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 313c f1ff
void m68kMoveWordImm16PaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2f8 rmmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] - 2;
	    aluAnd(reg_dt, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34b mmmw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3140 f1f8
void m68kMoveWordDsDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2da rmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 2db rmdw2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_au = reg_pc + 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3148 f1f8
void m68kMoveWordAsDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2da rmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 2db rmdw2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_au = reg_pc + 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3150 f1f8
void m68kMoveWordAisDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3158 f1f8
void m68kMoveWordAipsDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3160 f1f8
void m68kMoveWordPaisDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3168 f1f8
void m68kMoveWordDasDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3170 f1f8
void m68kMoveWordDaisDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3178 f1ff
void m68kMoveWordAdr16DadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3179 f1ff
void m68kMoveWordAdr32DadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 317a f1ff
void m68kMoveWordDpcDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 317b f1ff
void m68kMoveWordDpciDadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 38a mmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_da[rx_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 317c f1ff
void m68kMoveWordImm16DadProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2da rmdw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 2db rmdw2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dt;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dt, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3180 f1f8
void m68kMoveWordDsDaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1eb rmxw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 109 rmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto rmxw3;
	    }
	    else
	    {
		goto rmxw2;
	    }
	rmxw2:
	    // 128 rmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto rmdw2;
	rmxw3:
	    // 1e8 rmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto rmdw2;
	rmdw2:
	    // 2db rmdw2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_au = reg_pc + 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3188 f1f8
void m68kMoveWordAsDaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1eb rmxw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 109 rmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto rmxw3;
	    }
	    else
	    {
		goto rmxw2;
	    }
	rmxw2:
	    // 128 rmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto rmdw2;
	rmxw3:
	    // 1e8 rmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto rmdw2;
	rmdw2:
	    // 2db rmdw2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_da[ry_index];
	    reg_au = reg_pc + 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3190 f1f8
void m68kMoveWordAisDaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    aluExt(reg_aluo);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxw3;
	    }
	    else
	    {
		goto mmxw2;
	    }
	mmxw2:
	    // 028 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto maww2;
	mmxw3:
	    // 0e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto maww2;
	maww2:
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 3198 f1f8
void m68kMoveWordAipsDaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    aluExt(reg_aluo);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxw3;
	    }
	    else
	    {
		goto mmxw2;
	    }
	mmxw2:
	    // 028 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto maww2;
	mmxw3:
	    // 0e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto maww2;
	maww2:
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 31a0 f1f8
void m68kMoveWordPaisDaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    aluExt(reg_aluo);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxw3;
	    }
	    else
	    {
		goto mmxw2;
	    }
	mmxw2:
	    // 028 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto maww2;
	mmxw3:
	    // 0e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto maww2;
	maww2:
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 31a8 f1f8
void m68kMoveWordDasDaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    aluExt(reg_aluo);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxw3;
	    }
	    else
	    {
		goto mmxw2;
	    }
	mmxw2:
	    // 028 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto maww2;
	mmxw3:
	    // 0e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto maww2;
	maww2:
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 31b0 f1f8
void m68kMoveWordDaisDaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    aluExt(reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxw3;
	    }
	    else
	    {
		goto mmxw2;
	    }
	mmxw2:
	    // 028 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto maww2;
	mmxw3:
	    // 0e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto maww2;
	maww2:
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 31b8 f1ff
void m68kMoveWordAdr16DaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    aluExt(reg_aluo);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxw3;
	    }
	    else
	    {
		goto mmxw2;
	    }
	mmxw2:
	    // 028 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto maww2;
	mmxw3:
	    // 0e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto maww2;
	maww2:
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 31b9 f1ff
void m68kMoveWordAdr32DaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    aluExt(reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxw3;
	    }
	    else
	    {
		goto mmxw2;
	    }
	mmxw2:
	    // 028 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto maww2;
	mmxw3:
	    // 0e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto maww2;
	maww2:
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 31ba f1ff
void m68kMoveWordDpcDaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    aluExt(reg_aluo);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxw3;
	    }
	    else
	    {
		goto mmxw2;
	    }
	mmxw2:
	    // 028 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto maww2;
	mmxw3:
	    // 0e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto maww2;
	maww2:
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 31bb f1ff
void m68kMoveWordDpciDaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 298 mmxw0
	    aluExt(reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 101 mmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto mmxw3;
	    }
	    else
	    {
		goto mmxw2;
	    }
	mmxw2:
	    // 028 mmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto maww2;
	mmxw3:
	    // 0e8 mmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto maww2;
	maww2:
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 31bc f1ff
void m68kMoveWordImm16DaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1eb rmxw0
	    aluExt(reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 109 rmxw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_pc = reg_au;
	    reg_au = reg_da[rx_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto rmxw3;
	    }
	    else
	    {
		goto rmxw2;
	    }
	rmxw2:
	    // 128 rmxw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto rmdw2;
	rmxw3:
	    // 1e8 rmxw3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto rmdw2;
	rmdw2:
	    // 2db rmdw2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_dt;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dt, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 31c0 fff8
void m68kMoveWordDsAdr16Program()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2d9 raww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_da[ry_index]);
	    reg_au = ext32(reg_dbin);
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 31c8 fff8
void m68kMoveWordAsAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2d9 raww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_da[ry_index]);
	    reg_au = ext32(reg_dbin);
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 31d0 fff8
void m68kMoveWordAisAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 31d8 fff8
void m68kMoveWordAipsAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 31e0 fff8
void m68kMoveWordPaisAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 31e8 fff8
void m68kMoveWordDasAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 31f0 fff8
void m68kMoveWordDaisAdr16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 31f8 ffff
void m68kMoveWordAdr16Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 31f9 ffff
void m68kMoveWordAdr32Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 31fa ffff
void m68kMoveWordDpcAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 31fb ffff
void m68kMoveWordDpciAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 388 maww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 31fc ffff
void m68kMoveWordImm16Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2d9 raww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dt);
	    reg_au = ext32(reg_dbin);
	    aluAnd(reg_dt, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 33c0 fff8
void m68kMoveWordDsAdr32Program()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1ea ralw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2bb ralw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_da[ry_index]);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 33c8 fff8
void m68kMoveWordAsAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1ea ralw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2bb ralw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_da[ry_index]);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 33d0 fff8
void m68kMoveWordAisAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 33d8 fff8
void m68kMoveWordAipsAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 33e0 fff8
void m68kMoveWordPaisAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 33e8 fff8
void m68kMoveWordDasAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 33f0 fff8
void m68kMoveWordDaisAdr32Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 33f8 ffff
void m68kMoveWordAdr16Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 33f9 ffff
void m68kMoveWordAdr32Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 33fa ffff
void m68kMoveWordDpcAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 33fb ffff
void m68kMoveWordDpciAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 32b malw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_aluo);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 32e malw2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 33fc ffff
void m68kMoveWordImm16Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1ea ralw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2bb ralw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dt);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluAnd(reg_dt, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 389 maww2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4000 fff8
void m68kNegxByteDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 133 nnrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluSubxByte(reg_da[ry_index], 0x0000);
	    updateXNZVCU();
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4010 fff8
void m68kNegxByteAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubxByte(reg_dbin, 0x0000);
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4018 fff8
void m68kNegxByteAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubxByte(reg_dbin, 0x0000);
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4020 fff8
void m68kNegxBytePaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubxByte(reg_dbin, 0x0000);
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4028 fff8
void m68kNegxByteDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubxByte(reg_dbin, 0x0000);
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4030 fff8
void m68kNegxByteDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubxByte(reg_dbin, 0x0000);
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4038 ffff
void m68kNegxByteAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubxByte(reg_dbin, 0x0000);
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4039 ffff
void m68kNegxByteAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubxByte(reg_dbin, 0x0000);
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4040 fff8
void m68kNegxWordDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 133 nnrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluSubx(reg_da[ry_index], 0x0000);
	    updateXNZVCU();
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4050 fff8
void m68kNegxWordAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubx(reg_dbin, 0x0000);
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4058 fff8
void m68kNegxWordAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubx(reg_dbin, 0x0000);
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4060 fff8
void m68kNegxWordPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubx(reg_dbin, 0x0000);
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4068 fff8
void m68kNegxWordDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubx(reg_dbin, 0x0000);
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4070 fff8
void m68kNegxWordDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubx(reg_dbin, 0x0000);
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4078 ffff
void m68kNegxWordAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubx(reg_dbin, 0x0000);
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4079 ffff
void m68kNegxWordAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubx(reg_dbin, 0x0000);
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4080 fff8
void m68kNegxLongDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 137 nnrl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluSubx(reg_da[ry_index], 0x0000);
	    updateXNZVCU();
	    // 15e nnrl2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    aluSubc(high16(reg_da[ry_index]), 0x0000);
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4090 fff8
void m68kNegxLongAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubx(reg_dbin, 0x0000);
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    aluSubc(reg_alub, 0x0000);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4098 fff8
void m68kNegxLongAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubx(reg_dbin, 0x0000);
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    aluSubc(reg_alub, 0x0000);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 40a0 fff8
void m68kNegxLongPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubx(reg_dbin, 0x0000);
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    aluSubc(reg_alub, 0x0000);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 40a8 fff8
void m68kNegxLongDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubx(reg_dbin, 0x0000);
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    aluSubc(reg_alub, 0x0000);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 40b0 fff8
void m68kNegxLongDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubx(reg_dbin, 0x0000);
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    aluSubc(reg_alub, 0x0000);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 40b8 ffff
void m68kNegxLongAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubx(reg_dbin, 0x0000);
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    aluSubc(reg_alub, 0x0000);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 40b9 ffff
void m68kNegxLongAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 00d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubx(reg_dbin, 0x0000);
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    aluSubc(reg_alub, 0x0000);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 40c0 fff8
void m68kMoveSrDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3a5 strw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_ftu = reg_sr;
	    // 340 strw2
	    setReg16Low(reg_da[ry_index], reg_ftu);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 08d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 40d0 fff8
void m68kMoveSrAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3a1 stmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_ftu = reg_sr;
	    // 324 sftm2
	    reg_au = reg_at;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 40d8 fff8
void m68kMoveSrAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3a1 stmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_ftu = reg_sr;
	    // 324 sftm2
	    reg_au = reg_at;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 40e0 fff8
void m68kMoveSrPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3a1 stmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_ftu = reg_sr;
	    // 324 sftm2
	    reg_au = reg_at;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 40e8 fff8
void m68kMoveSrDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3a1 stmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_ftu = reg_sr;
	    // 324 sftm2
	    reg_au = reg_at;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 40f0 fff8
void m68kMoveSrDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3a1 stmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_ftu = reg_sr;
	    // 324 sftm2
	    reg_au = reg_at;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 40f8 ffff
void m68kMoveSrAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3a1 stmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_ftu = reg_sr;
	    // 324 sftm2
	    reg_au = reg_at;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 40f9 ffff
void m68kMoveSrAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3a1 stmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_ftu = reg_sr;
	    // 324 sftm2
	    reg_au = reg_at;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4180 f1f8
void m68kChkWordDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 152 chkr1
	    reg_alub = reg_da[rx_index];
	    reg_au = reg_au - 2;
	    aluSub(reg_da[rx_index], reg_da[ry_index]);
	    updateNZVC();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 153 chkr2
	    reg_t = ((reg_isr & (SrOverflow | SrSign)) == 0) ? 1 : 0;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto chkr3;
	    }
	    else
	    {
		goto trap1;
	    }
	trap1:
	    // 1d0 trap1
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 347 trap2
	    initST();
	    reg_au = reg_da[16] - 2;
	    aluAnd(reg_pc, 0xFFFF);
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x06);
	    reg_da[16] = reg_au;
	    reg_ftu = 0x0018;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 14;
	}
	break;
	case 14:
	{
	    inst_cycle = 15;
	}
	break;
	case 15:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    goto mmrw3;
	chkr3:
	    // 110 chkr3
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    inst_cycle = 17;
	}
	break;
	case 17:
	{
	    inst_cycle = 18;
	}
	break;
	case 18:
	{
	    if (reg_t)
	    {
		goto trap1;
	    }
	    else
	    {
		goto chkr4;
	    }
	mmrw3:
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 16;
	}
	break;
	case 16:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	chkr4:
	    // 150 chkr4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    goto mmrw3;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4190 f1f8
void m68kChkWordAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 151 chkm1
	    reg_alub = reg_da[rx_index];
	    reg_au = reg_au - 2;
	    aluSub(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 153 chkr2
	    reg_t = ((reg_isr & (SrOverflow | SrSign)) == 0) ? 1 : 0;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (reg_t)
	    {
		goto chkr3;
	    }
	    else
	    {
		goto trap1;
	    }
	trap1:
	    // 1d0 trap1
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    // 347 trap2
	    initST();
	    reg_au = reg_da[16] - 2;
	    aluAnd(reg_pc, 0xFFFF);
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x06);
	    reg_da[16] = reg_au;
	    reg_ftu = 0x0018;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 14;
	}
	break;
	case 14:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 15;
	}
	break;
	case 15:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 16;
	}
	break;
	case 16:
	{
	    inst_cycle = 17;
	}
	break;
	case 17:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    goto mmrw3;
	chkr3:
	    // 110 chkr3
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    inst_cycle = 19;
	}
	break;
	case 19:
	{
	    inst_cycle = 20;
	}
	break;
	case 20:
	{
	    if (reg_t)
	    {
		goto trap1;
	    }
	    else
	    {
		goto chkr4;
	    }
	mmrw3:
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 18;
	}
	break;
	case 18:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	chkr4:
	    // 150 chkr4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    goto mmrw3;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4198 f1f8
void m68kChkWordAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 151 chkm1
	    reg_alub = reg_da[rx_index];
	    reg_au = reg_au - 2;
	    aluSub(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 153 chkr2
	    reg_t = ((reg_isr & (SrOverflow | SrSign)) == 0) ? 1 : 0;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (reg_t)
	    {
		goto chkr3;
	    }
	    else
	    {
		goto trap1;
	    }
	trap1:
	    // 1d0 trap1
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    // 347 trap2
	    initST();
	    reg_au = reg_da[16] - 2;
	    aluAnd(reg_pc, 0xFFFF);
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x06);
	    reg_da[16] = reg_au;
	    reg_ftu = 0x0018;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 14;
	}
	break;
	case 14:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 15;
	}
	break;
	case 15:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 16;
	}
	break;
	case 16:
	{
	    inst_cycle = 17;
	}
	break;
	case 17:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    goto mmrw3;
	chkr3:
	    // 110 chkr3
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    inst_cycle = 19;
	}
	break;
	case 19:
	{
	    inst_cycle = 20;
	}
	break;
	case 20:
	{
	    if (reg_t)
	    {
		goto trap1;
	    }
	    else
	    {
		goto chkr4;
	    }
	mmrw3:
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 18;
	}
	break;
	case 18:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	chkr4:
	    // 150 chkr4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    goto mmrw3;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 41a0 f1f8
void m68kChkWordPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 151 chkm1
	    reg_alub = reg_da[rx_index];
	    reg_au = reg_au - 2;
	    aluSub(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 153 chkr2
	    reg_t = ((reg_isr & (SrOverflow | SrSign)) == 0) ? 1 : 0;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (reg_t)
	    {
		goto chkr3;
	    }
	    else
	    {
		goto trap1;
	    }
	trap1:
	    // 1d0 trap1
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    // 347 trap2
	    initST();
	    reg_au = reg_da[16] - 2;
	    aluAnd(reg_pc, 0xFFFF);
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x06);
	    reg_da[16] = reg_au;
	    reg_ftu = 0x0018;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 14;
	}
	break;
	case 14:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 15;
	}
	break;
	case 15:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 16;
	}
	break;
	case 16:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 17;
	}
	break;
	case 17:
	{
	    inst_cycle = 18;
	}
	break;
	case 18:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    goto mmrw3;
	chkr3:
	    // 110 chkr3
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    inst_cycle = 20;
	}
	break;
	case 20:
	{
	    inst_cycle = 21;
	}
	break;
	case 21:
	{
	    if (reg_t)
	    {
		goto trap1;
	    }
	    else
	    {
		goto chkr4;
	    }
	mmrw3:
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 19;
	}
	break;
	case 19:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	chkr4:
	    // 150 chkr4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    goto mmrw3;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 41a8 f1f8
void m68kChkWordDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 151 chkm1
	    reg_alub = reg_da[rx_index];
	    reg_au = reg_au - 2;
	    aluSub(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 153 chkr2
	    reg_t = ((reg_isr & (SrOverflow | SrSign)) == 0) ? 1 : 0;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (reg_t)
	    {
		goto chkr3;
	    }
	    else
	    {
		goto trap1;
	    }
	trap1:
	    // 1d0 trap1
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    // 347 trap2
	    initST();
	    reg_au = reg_da[16] - 2;
	    aluAnd(reg_pc, 0xFFFF);
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x06);
	    reg_da[16] = reg_au;
	    reg_ftu = 0x0018;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 14;
	}
	break;
	case 14:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 15;
	}
	break;
	case 15:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 16;
	}
	break;
	case 16:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 17;
	}
	break;
	case 17:
	{
	    inst_cycle = 18;
	}
	break;
	case 18:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    goto mmrw3;
	chkr3:
	    // 110 chkr3
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    inst_cycle = 20;
	}
	break;
	case 20:
	{
	    inst_cycle = 21;
	}
	break;
	case 21:
	{
	    if (reg_t)
	    {
		goto trap1;
	    }
	    else
	    {
		goto chkr4;
	    }
	mmrw3:
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 19;
	}
	break;
	case 19:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	chkr4:
	    // 150 chkr4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    goto mmrw3;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 41b0 f1f8
void m68kChkWordDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 23;
	}
	break;
	case 23:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 151 chkm1
	    reg_alub = reg_da[rx_index];
	    reg_au = reg_au - 2;
	    aluSub(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 153 chkr2
	    reg_t = ((reg_isr & (SrOverflow | SrSign)) == 0) ? 1 : 0;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (reg_t)
	    {
		goto chkr3;
	    }
	    else
	    {
		goto trap1;
	    }
	trap1:
	    // 1d0 trap1
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    // 347 trap2
	    initST();
	    reg_au = reg_da[16] - 2;
	    aluAnd(reg_pc, 0xFFFF);
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x06);
	    reg_da[16] = reg_au;
	    reg_ftu = 0x0018;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 14;
	}
	break;
	case 14:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 15;
	}
	break;
	case 15:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 16;
	}
	break;
	case 16:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 17;
	}
	break;
	case 17:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 18;
	}
	break;
	case 18:
	{
	    inst_cycle = 19;
	}
	break;
	case 19:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    goto mmrw3;
	chkr3:
	    // 110 chkr3
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    inst_cycle = 21;
	}
	break;
	case 21:
	{
	    inst_cycle = 22;
	}
	break;
	case 22:
	{
	    if (reg_t)
	    {
		goto trap1;
	    }
	    else
	    {
		goto chkr4;
	    }
	mmrw3:
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 20;
	}
	break;
	case 20:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	chkr4:
	    // 150 chkr4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    goto mmrw3;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 41b8 f1ff
void m68kChkWordAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 151 chkm1
	    reg_alub = reg_da[rx_index];
	    reg_au = reg_au - 2;
	    aluSub(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 153 chkr2
	    reg_t = ((reg_isr & (SrOverflow | SrSign)) == 0) ? 1 : 0;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (reg_t)
	    {
		goto chkr3;
	    }
	    else
	    {
		goto trap1;
	    }
	trap1:
	    // 1d0 trap1
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    // 347 trap2
	    initST();
	    reg_au = reg_da[16] - 2;
	    aluAnd(reg_pc, 0xFFFF);
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x06);
	    reg_da[16] = reg_au;
	    reg_ftu = 0x0018;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 14;
	}
	break;
	case 14:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 15;
	}
	break;
	case 15:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 16;
	}
	break;
	case 16:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 17;
	}
	break;
	case 17:
	{
	    inst_cycle = 18;
	}
	break;
	case 18:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    goto mmrw3;
	chkr3:
	    // 110 chkr3
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    inst_cycle = 20;
	}
	break;
	case 20:
	{
	    inst_cycle = 21;
	}
	break;
	case 21:
	{
	    if (reg_t)
	    {
		goto trap1;
	    }
	    else
	    {
		goto chkr4;
	    }
	mmrw3:
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 19;
	}
	break;
	case 19:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	chkr4:
	    // 150 chkr4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    goto mmrw3;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 41b9 f1ff
void m68kChkWordAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 151 chkm1
	    reg_alub = reg_da[rx_index];
	    reg_au = reg_au - 2;
	    aluSub(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 153 chkr2
	    reg_t = ((reg_isr & (SrOverflow | SrSign)) == 0) ? 1 : 0;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (reg_t)
	    {
		goto chkr3;
	    }
	    else
	    {
		goto trap1;
	    }
	trap1:
	    // 1d0 trap1
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    // 347 trap2
	    initST();
	    reg_au = reg_da[16] - 2;
	    aluAnd(reg_pc, 0xFFFF);
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x06);
	    reg_da[16] = reg_au;
	    reg_ftu = 0x0018;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 14;
	}
	break;
	case 14:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 15;
	}
	break;
	case 15:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 16;
	}
	break;
	case 16:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 17;
	}
	break;
	case 17:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 18;
	}
	break;
	case 18:
	{
	    inst_cycle = 19;
	}
	break;
	case 19:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    goto mmrw3;
	chkr3:
	    // 110 chkr3
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    inst_cycle = 21;
	}
	break;
	case 21:
	{
	    inst_cycle = 22;
	}
	break;
	case 22:
	{
	    if (reg_t)
	    {
		goto trap1;
	    }
	    else
	    {
		goto chkr4;
	    }
	mmrw3:
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 20;
	}
	break;
	case 20:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	chkr4:
	    // 150 chkr4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    goto mmrw3;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 41ba f1ff
void m68kChkWordDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 151 chkm1
	    reg_alub = reg_da[rx_index];
	    reg_au = reg_au - 2;
	    aluSub(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 153 chkr2
	    reg_t = ((reg_isr & (SrOverflow | SrSign)) == 0) ? 1 : 0;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (reg_t)
	    {
		goto chkr3;
	    }
	    else
	    {
		goto trap1;
	    }
	trap1:
	    // 1d0 trap1
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    // 347 trap2
	    initST();
	    reg_au = reg_da[16] - 2;
	    aluAnd(reg_pc, 0xFFFF);
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x06);
	    reg_da[16] = reg_au;
	    reg_ftu = 0x0018;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 14;
	}
	break;
	case 14:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 15;
	}
	break;
	case 15:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 16;
	}
	break;
	case 16:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 17;
	}
	break;
	case 17:
	{
	    inst_cycle = 18;
	}
	break;
	case 18:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    goto mmrw3;
	chkr3:
	    // 110 chkr3
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    inst_cycle = 20;
	}
	break;
	case 20:
	{
	    inst_cycle = 21;
	}
	break;
	case 21:
	{
	    if (reg_t)
	    {
		goto trap1;
	    }
	    else
	    {
		goto chkr4;
	    }
	mmrw3:
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 19;
	}
	break;
	case 19:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	chkr4:
	    // 150 chkr4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    goto mmrw3;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 41bb f1ff
void m68kChkWordDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 23;
	}
	break;
	case 23:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 151 chkm1
	    reg_alub = reg_da[rx_index];
	    reg_au = reg_au - 2;
	    aluSub(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 153 chkr2
	    reg_t = ((reg_isr & (SrOverflow | SrSign)) == 0) ? 1 : 0;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (reg_t)
	    {
		goto chkr3;
	    }
	    else
	    {
		goto trap1;
	    }
	trap1:
	    // 1d0 trap1
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    // 347 trap2
	    initST();
	    reg_au = reg_da[16] - 2;
	    aluAnd(reg_pc, 0xFFFF);
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x06);
	    reg_da[16] = reg_au;
	    reg_ftu = 0x0018;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 14;
	}
	break;
	case 14:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 15;
	}
	break;
	case 15:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 16;
	}
	break;
	case 16:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 17;
	}
	break;
	case 17:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 18;
	}
	break;
	case 18:
	{
	    inst_cycle = 19;
	}
	break;
	case 19:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    goto mmrw3;
	chkr3:
	    // 110 chkr3
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    inst_cycle = 21;
	}
	break;
	case 21:
	{
	    inst_cycle = 22;
	}
	break;
	case 22:
	{
	    if (reg_t)
	    {
		goto trap1;
	    }
	    else
	    {
		goto chkr4;
	    }
	mmrw3:
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 20;
	}
	break;
	case 20:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	chkr4:
	    // 150 chkr4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    goto mmrw3;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 41bc f1ff
void m68kChkWordImm16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 152 chkr1
	    reg_alub = reg_da[rx_index];
	    reg_au = reg_au - 2;
	    aluSub(reg_da[rx_index], reg_dt);
	    updateNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 153 chkr2
	    reg_t = ((reg_isr & (SrOverflow | SrSign)) == 0) ? 1 : 0;
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (reg_t)
	    {
		goto chkr3;
	    }
	    else
	    {
		goto trap1;
	    }
	trap1:
	    // 1d0 trap1
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    // 347 trap2
	    initST();
	    reg_au = reg_da[16] - 2;
	    aluAnd(reg_pc, 0xFFFF);
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x06);
	    reg_da[16] = reg_au;
	    reg_ftu = 0x0018;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 14;
	}
	break;
	case 14:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 15;
	}
	break;
	case 15:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 16;
	}
	break;
	case 16:
	{
	    inst_cycle = 17;
	}
	break;
	case 17:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    goto mmrw3;
	chkr3:
	    // 110 chkr3
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    inst_cycle = 19;
	}
	break;
	case 19:
	{
	    inst_cycle = 20;
	}
	break;
	case 20:
	{
	    if (reg_t)
	    {
		goto trap1;
	    }
	    else
	    {
		goto chkr4;
	    }
	mmrw3:
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 18;
	}
	break;
	case 18:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	chkr4:
	    // 150 chkr4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    goto mmrw3;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 41d0 f1f8
void m68kLeaAisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2f1 leaa1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_ftu = reg_dbin;
	    // 066 leaa2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 41e8 f1f8
void m68kLeaDasAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2f2 lead1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    // 309 lead2
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 41f0 f1f8
void m68kLeaDaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1fb leax0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3ea leax1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto leax3;
	    }
	    else
	    {
		goto leax2;
	    }
	leax2:
	    // 130 leax2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto leax4;
	leax3:
	    // 1f0 leax3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto leax4;
	leax4:
	    // 30a leax4
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 4;
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 41f8 f1ff
void m68kLeaAdr16AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 275 laaw1
	    reg_aob = reg_au;
	    reg_da[rx_index] = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 41f9 f1ff
void m68kLeaAdr32AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e4 laal1
	    reg_aob = reg_au;
	    setReg16High(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2bd laal2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_da[rx_index], reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 41fa f1ff
void m68kLeaDpcAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2f2 lead1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    // 309 lead2
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 41fb f1ff
void m68kLeaDpciAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1fb leax0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3ea leax1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto leax3;
	    }
	    else
	    {
		goto leax2;
	    }
	leax2:
	    // 130 leax2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto leax4;
	leax3:
	    // 1f0 leax3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto leax4;
	leax4:
	    // 30a leax4
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 4;
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4200 fff8
void m68kClrByteDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 133 nnrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAndByte(reg_da[ry_index], 0x0000);
	    updateNZVC();
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4210 fff8
void m68kClrByteAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAndByte(reg_dbin, 0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4218 fff8
void m68kClrByteAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    aluAndByte(reg_da[reg_movems], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAndByte(reg_dbin, 0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4220 fff8
void m68kClrBytePaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    aluAndByte(reg_da[reg_movems], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAndByte(reg_dbin, 0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4228 fff8
void m68kClrByteDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAndByte(reg_dbin, 0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4230 fff8
void m68kClrByteDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAndByte(reg_dbin, 0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4238 ffff
void m68kClrByteAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluAndByte(reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAndByte(reg_dbin, 0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4239 ffff
void m68kClrByteAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluAndByte(reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAndByte(reg_dbin, 0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4240 fff8
void m68kClrWordDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 133 nnrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_da[ry_index], 0x0000);
	    updateNZVC();
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4250 fff8
void m68kClrWordAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_dbin, 0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4258 fff8
void m68kClrWordAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_da[reg_movems], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_dbin, 0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4260 fff8
void m68kClrWordPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - 2;
	    aluAnd(reg_da[reg_movems], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_dbin, 0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4268 fff8
void m68kClrWordDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_dbin, 0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4270 fff8
void m68kClrWordDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_dbin, 0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4278 ffff
void m68kClrWordAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluAnd(reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_dbin, 0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4279 ffff
void m68kClrWordAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluAnd(reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_dbin, 0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4280 fff8
void m68kClrLongDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 137 nnrl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_da[ry_index], 0x0000);
	    updateNZVC();
	    // 15e nnrl2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    aluAnd(high16(reg_da[ry_index]), 0x0000);
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4290 fff8
void m68kClrLongAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_dbin, 0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    aluAnd(reg_alub, 0x0000);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4298 fff8
void m68kClrLongAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_dbin, 0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    aluAnd(reg_alub, 0x0000);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 42a0 fff8
void m68kClrLongPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_dbin, 0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    aluAnd(reg_alub, 0x0000);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 42a8 fff8
void m68kClrLongDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_dbin, 0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    aluAnd(reg_alub, 0x0000);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 42b0 fff8
void m68kClrLongDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_dbin, 0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    aluAnd(reg_alub, 0x0000);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 42b8 ffff
void m68kClrLongAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluAnd(reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_dbin, 0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    aluAnd(reg_alub, 0x0000);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 42b9 ffff
void m68kClrLongAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 00d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluAnd(reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_dbin, 0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    aluAnd(reg_alub, 0x0000);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4400 fff8
void m68kNegByteDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 133 nnrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluSubByte(reg_da[ry_index], 0x0000);
	    updateXNZVC();
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4410 fff8
void m68kNegByteAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubByte(reg_dbin, 0x0000);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4418 fff8
void m68kNegByteAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubByte(reg_dbin, 0x0000);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4420 fff8
void m68kNegBytePaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubByte(reg_dbin, 0x0000);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4428 fff8
void m68kNegByteDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubByte(reg_dbin, 0x0000);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4430 fff8
void m68kNegByteDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubByte(reg_dbin, 0x0000);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4438 ffff
void m68kNegByteAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubByte(reg_dbin, 0x0000);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4439 ffff
void m68kNegByteAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubByte(reg_dbin, 0x0000);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4440 fff8
void m68kNegWordDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 133 nnrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluSub(reg_da[ry_index], 0x0000);
	    updateXNZVC();
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4450 fff8
void m68kNegWordAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_dbin, 0x0000);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4458 fff8
void m68kNegWordAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_dbin, 0x0000);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4460 fff8
void m68kNegWordPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_dbin, 0x0000);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4468 fff8
void m68kNegWordDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_dbin, 0x0000);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4470 fff8
void m68kNegWordDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_dbin, 0x0000);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4478 ffff
void m68kNegWordAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_dbin, 0x0000);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4479 ffff
void m68kNegWordAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_dbin, 0x0000);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4480 fff8
void m68kNegLongDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 137 nnrl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluSub(reg_da[ry_index], 0x0000);
	    updateXNZVC();
	    // 15e nnrl2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    aluSubc(high16(reg_da[ry_index]), 0x0000);
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4490 fff8
void m68kNegLongAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_dbin, 0x0000);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    aluSubc(reg_alub, 0x0000);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4498 fff8
void m68kNegLongAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_dbin, 0x0000);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    aluSubc(reg_alub, 0x0000);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 44a0 fff8
void m68kNegLongPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_dbin, 0x0000);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    aluSubc(reg_alub, 0x0000);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 44a8 fff8
void m68kNegLongDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_dbin, 0x0000);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    aluSubc(reg_alub, 0x0000);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 44b0 fff8
void m68kNegLongDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_dbin, 0x0000);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    aluSubc(reg_alub, 0x0000);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 44b8 ffff
void m68kNegLongAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_dbin, 0x0000);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    aluSubc(reg_alub, 0x0000);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 44b9 ffff
void m68kNegLongAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 00d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_dbin, 0x0000);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    aluSubc(reg_alub, 0x0000);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 44c0 fff8
void m68kMoveDsCcrProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 301 rstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_da[ry_index];
	    reg_au = reg_au - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 44d0 fff8
void m68kMoveAisCcrProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 44d8 fff8
void m68kMoveAipsCcrProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 44e0 fff8
void m68kMovePaisCcrProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 44e8 fff8
void m68kMoveDasCcrProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 44f0 fff8
void m68kMoveDaisCcrProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 44f8 ffff
void m68kMoveAdr16CcrProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 44f9 ffff
void m68kMoveAdr32CcrProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 44fa ffff
void m68kMoveDpcCcrProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 44fb ffff
void m68kMoveDpciCcrProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 44fc ffff
void m68kMoveImm8CcrProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 301 rstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dt;
	    reg_au = reg_au - 2;
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4600 fff8
void m68kNotByteDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 133 nnrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluNotByte(reg_da[ry_index]);
	    updateNZVC();
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4610 fff8
void m68kNotByteAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndBytex(reg_dbin, 0xFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluNotByte(reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4618 fff8
void m68kNotByteAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndBytex(reg_alub, 0xFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluNotByte(reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4620 fff8
void m68kNotBytePaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndBytex(reg_alub, 0xFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluNotByte(reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4628 fff8
void m68kNotByteDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndBytex(reg_dbin, 0xFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluNotByte(reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4630 fff8
void m68kNotByteDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndBytex(reg_dbin, 0xFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluNotByte(reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4638 ffff
void m68kNotByteAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndBytex(reg_dbin, 0xFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluNotByte(reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4639 ffff
void m68kNotByteAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndBytex(reg_dbin, 0xFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluNotByte(reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4640 fff8
void m68kNotWordDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 133 nnrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluNot(reg_da[ry_index]);
	    updateNZVC();
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4650 fff8
void m68kNotWordAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndx(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluNot(reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4658 fff8
void m68kNotWordAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndx(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluNot(reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4660 fff8
void m68kNotWordPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndx(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluNot(reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4668 fff8
void m68kNotWordDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndx(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluNot(reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4670 fff8
void m68kNotWordDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndx(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluNot(reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4678 ffff
void m68kNotWordAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndx(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluNot(reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4679 ffff
void m68kNotWordAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndx(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b8 nnmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluNot(reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4680 fff8
void m68kNotLongDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 137 nnrl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluNot(reg_da[ry_index]);
	    updateNZVC();
	    // 15e nnrl2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    aluNot(high16(reg_da[ry_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4690 fff8
void m68kNotLongAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAndx(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluNot(reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    aluNot(reg_alub);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4698 fff8
void m68kNotLongAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAndx(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluNot(reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    aluNot(reg_alub);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 46a0 fff8
void m68kNotLongPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    aluAndx(reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluNot(reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    aluNot(reg_alub);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 46a8 fff8
void m68kNotLongDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAndx(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluNot(reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    aluNot(reg_alub);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 46b0 fff8
void m68kNotLongDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAndx(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluNot(reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    aluNot(reg_alub);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 46b8 ffff
void m68kNotLongAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAndx(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluNot(reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    aluNot(reg_alub);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 46b9 ffff
void m68kNotLongAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 00d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAndx(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2bc nnml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluNot(reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15d nnml2
	    reg_aob = reg_at;
	    reg_dbout = reg_aluo;
	    reg_au = reg_at - 2;
	    aluNot(reg_alub);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 46c0 fff8
void m68kMoveDsSrProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    if (!testbit(reg_sr, 13))
	    {
		setPriv();
		return;
	    }

	    // 301 rstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_da[ry_index];
	    reg_au = reg_au - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
	    updateSupervisor();
	    updateInterrupts();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 46d0 fff8
void m68kMoveAisSrProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    if (!testbit(reg_sr, 13))
	    {
		setPriv();
		return;
	    }

	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndx(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
	    updateSupervisor();
	    updateInterrupts();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 46d8 fff8
void m68kMoveAipsSrProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    if (!testbit(reg_sr, 13))
	    {
		setPriv();
		return;
	    }

	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndx(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
	    updateSupervisor();
	    updateInterrupts();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 46e0 fff8
void m68kMovePaisSrProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    if (!testbit(reg_sr, 13))
	    {
		setPriv();
		return;
	    }

	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndx(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
	    updateSupervisor();
	    updateInterrupts();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 46e8 fff8
void m68kMoveDasSrProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    if (!testbit(reg_sr, 13))
	    {
		setPriv();
		return;
	    }

	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndx(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
	    updateSupervisor();
	    updateInterrupts();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 46f0 fff8
void m68kMoveDaisSrProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    if (!testbit(reg_sr, 13))
	    {
		setPriv();
		return;
	    }

	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndx(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
	    updateSupervisor();
	    updateInterrupts();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 46f8 ffff
void m68kMoveAdr16SrProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    if (!testbit(reg_sr, 13))
	    {
		setPriv();
		return;
	    }

	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndx(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
	    updateSupervisor();
	    updateInterrupts();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 46f9 ffff
void m68kMoveAdr32SrProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    if (!testbit(reg_sr, 13))
	    {
		setPriv();
		return;
	    }

	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndx(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
	    updateSupervisor();
	    updateInterrupts();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 46fa ffff
void m68kMoveDpcSrProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    if (!testbit(reg_sr, 13))
	    {
		setPriv();
		return;
	    }

	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndx(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
	    updateSupervisor();
	    updateInterrupts();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 46fb ffff
void m68kMoveDpciSrProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    if (!testbit(reg_sr, 13))
	    {
		setPriv();
		return;
	    }

	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndx(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 159 mstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au - 2;
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
	    updateSupervisor();
	    updateInterrupts();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 46fc ffff
void m68kMoveI16uSrProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    if (!testbit(reg_sr, 13))
	    {
		setPriv();
		return;
	    }

	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 301 rstw1
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dt;
	    reg_au = reg_au - 2;
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 321 stiw4
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
	    updateSupervisor();
	    updateInterrupts();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4800 fff8
void m68kNbcdByteDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 13b nbcr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluSbcdByte(reg_da[ry_index], 0x0000);
	    updateXNZVCU();
	    // 117 nbcr2
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4810 fff8
void m68kNbcdByteAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 15c nbcm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    aluSbcdByte(reg_dbin, 0x0000);
	    updateXNZVCU();
	    // 113 asbb6
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4818 fff8
void m68kNbcdByteAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 15c nbcm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    aluSbcdByte(reg_dbin, 0x0000);
	    updateXNZVCU();
	    // 113 asbb6
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4820 fff8
void m68kNbcdBytePaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 15c nbcm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    aluSbcdByte(reg_dbin, 0x0000);
	    updateXNZVCU();
	    // 113 asbb6
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4828 fff8
void m68kNbcdByteDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 15c nbcm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    aluSbcdByte(reg_dbin, 0x0000);
	    updateXNZVCU();
	    // 113 asbb6
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4830 fff8
void m68kNbcdByteDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 15c nbcm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    aluSbcdByte(reg_dbin, 0x0000);
	    updateXNZVCU();
	    // 113 asbb6
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4838 ffff
void m68kNbcdByteAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 15c nbcm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    aluSbcdByte(reg_dbin, 0x0000);
	    updateXNZVCU();
	    // 113 asbb6
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4839 ffff
void m68kNbcdByteAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 15c nbcm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    aluSbcdByte(reg_dbin, 0x0000);
	    updateXNZVCU();
	    // 113 asbb6
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4840 fff8
void m68kSwapDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 341 swap1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[ry_index];
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_da[ry_index]);
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    updateNZVC();
	    // 342 swap2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[ry_index] = merge32(high16(reg_at), reg_aluo);
	    reg_au = reg_au + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4850 fff8
void m68kPeaAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 17c peaa1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = merge32(high16(reg_da[rx_index]), 0) - 4;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 106 peax6
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_at);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4868 fff8
void m68kPeaDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 17d pead1
	    reg_aob = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 17e pead2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_at;
	    // 17f pead3
	    reg_at = reg_au;
	    aluAnd(reg_au, 0xFFFF);
	    reg_au = merge32(high16(reg_da[rx_index]), 0) - 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 106 peax6
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_at);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4870 fff8
void m68kPeaDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1ff peax0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3ee peax1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto peax3;
	    }
	    else
	    {
		goto peax2;
	    }
	peax2:
	    // 134 peax2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto peax4;
	peax3:
	    // 1f4 peax3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto peax4;
	peax4:
	    // 218 peax4
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_at = reg_au;
	    aluAnd(reg_au, 0xFFFF);
	    reg_au = reg_pc + 4;
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 219 peax5
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = merge32(high16(reg_da[rx_index]), 0) - 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 106 peax6
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_at);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4878 ffff
void m68kPeaAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 178 paaw1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    reg_au = merge32(high16(reg_da[rx_index]), 0) - 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 10a paaw2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_at);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4879 ffff
void m68kPeaAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1fa paal1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 15f paal2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_da[rx_index]), 0) - 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 10a paaw2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_at);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 348 mawl3
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    setTrace();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 487a ffff
void m68kPeaDpcProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 17d pead1
	    reg_aob = reg_au;
	    reg_at = reg_pc;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 17e pead2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_aluo) + reg_at;
	    // 17f pead3
	    reg_at = reg_au;
	    aluAnd(reg_au, 0xFFFF);
	    reg_au = merge32(high16(reg_da[rx_index]), 0) - 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 106 peax6
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_at);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 487b ffff
void m68kPeaDpciProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1ff peax0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3ee peax1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto peax3;
	    }
	    else
	    {
		goto peax2;
	    }
	peax2:
	    // 134 peax2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto peax4;
	peax3:
	    // 1f4 peax3
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto peax4;
	peax4:
	    // 218 peax4
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_at = reg_au;
	    aluAnd(reg_au, 0xFFFF);
	    reg_au = reg_pc + 4;
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 219 peax5
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_au = merge32(high16(reg_da[rx_index]), 0) - 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 106 peax6
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_at);
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4880 fff8
void m68kExtWordDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 133 nnrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluExt(reg_da[ry_index]);
	    updateNZVC();
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4890 fff8
void m68kMovemWordListAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3a0 stmr1
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    // 323 stmr2
	    reg_t = (reg_movemr == 0);
	    reg_pc = reg_au;
	    reg_au = reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto mmrw2;
	    }
	    else
	    {
		goto stmr5;
	    }
	stmr5:
	    // 0a5 stmr5
	    reg_aob = reg_au;
	    reg_t = (reg_movemr == 0);
	    reg_dbout = reg_da[reg_movems];
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    stepMovem();
	    if (reg_t)
	    {
		goto mmrw2;
	    }
	    else
	    {
		goto stmr5;
	    }
	mmrw2:
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 48a0 fff8
void m68kMovemWordListpPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3a4 push1
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    // 21e push2
	    reg_t = (reg_movemr == 0);
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    stepMovemPredec();
	    if (reg_t)
	    {
		goto push3;
	    }
	    else
	    {
		goto push5;
	    }
	push5:
	    // 083 push5
	    reg_aob = reg_au;
	    reg_t = (reg_movemr == 0);
	    reg_dbout = reg_da[reg_movems];
	    reg_at = reg_au;
	    reg_au = reg_au - 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    stepMovemPredec();
	    if (reg_t)
	    {
		goto push3;
	    }
	    else
	    {
		goto push5;
	    }
	push3:
	    // 043 push3
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_da[ry_index] = reg_at;
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 48a8 fff8
void m68kMovemWordListDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1f1 stmd1
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 3c9 stmd2
	    reg_aob = reg_au;
	    reg_at = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    // 322 stmd3
	    reg_t = (reg_movemr == 0);
	    reg_pc = reg_au;
	    reg_au = reg_da[ry_index] + ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto mmrw2;
	    }
	    else
	    {
		goto stmr5;
	    }
	stmr5:
	    // 0a5 stmr5
	    reg_aob = reg_au;
	    reg_t = (reg_movemr == 0);
	    reg_dbout = reg_da[reg_movems];
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    stepMovem();
	    if (reg_t)
	    {
		goto mmrw2;
	    }
	    else
	    {
		goto stmr5;
	    }
	mmrw2:
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 48b0 fff8
void m68kMovemWordListDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 325 stmx1
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 326 stmx2
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = reg_au - 2;
	    aluExt(reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 02f stmx3
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto stmx5;
	    }
	    else
	    {
		goto stmx4;
	    }
	stmx4:
	    // 138 stmx4
	    reg_t = (reg_movemr == 0);
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto mmrw2;
	    }
	    else
	    {
		goto stmr5;
	    }
	stmx5:
	    // 1f8 stmx5
	    reg_t = (reg_movemr == 0);
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto mmrw2;
	    }
	    else
	    {
		goto stmr5;
	    }
	stmr5:
	    // 0a5 stmr5
	    reg_aob = reg_au;
	    reg_t = (reg_movemr == 0);
	    reg_dbout = reg_da[reg_movems];
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    stepMovem();
	    if (reg_t)
	    {
		goto mmrw2;
	    }
	    else
	    {
		goto stmr5;
	    }
	mmrw2:
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 48b8 ffff
void m68kMovemWordListAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1ed smaw1
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 3c1 smaw2
	    reg_aob = reg_au;
	    reg_at = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    // 04b smaw3
	    reg_t = (reg_movemr == 0);
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto mmrw2;
	    }
	    else
	    {
		goto stmr5;
	    }
	stmr5:
	    // 0a5 stmr5
	    reg_aob = reg_au;
	    reg_t = (reg_movemr == 0);
	    reg_dbout = reg_da[reg_movems];
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    stepMovem();
	    if (reg_t)
	    {
		goto mmrw2;
	    }
	    else
	    {
		goto stmr5;
	    }
	mmrw2:
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 48b9 ffff
void m68kMovemWordListAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e5 smal1
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 112 smal2
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 305 smal3
	    reg_aob = reg_au;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    // 04b smaw3
	    reg_t = (reg_movemr == 0);
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto mmrw2;
	    }
	    else
	    {
		goto stmr5;
	    }
	stmr5:
	    // 0a5 stmr5
	    reg_aob = reg_au;
	    reg_t = (reg_movemr == 0);
	    reg_dbout = reg_da[reg_movems];
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    stepMovem();
	    if (reg_t)
	    {
		goto mmrw2;
	    }
	    else
	    {
		goto stmr5;
	    }
	mmrw2:
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 48c0 fff8
void m68kExtLongDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 232 extr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    // 233 extr2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[ry_index] = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 48d0 fff8
void m68kMovemLongListAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3a0 stmr1
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    // 323 stmr2
	    reg_t = (reg_movemr == 0);
	    reg_pc = reg_au;
	    reg_au = reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto mmrw2;
	    }
	    else
	    {
		goto stmr4;
	    }
	stmr4:
	    // 0e5 stmr4
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_da[reg_movems]);
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ad stmr6
	    reg_aob = reg_au;
	    reg_t = (reg_movemr == 0);
	    reg_dbout = reg_da[reg_movems];
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    stepMovem();
	    if (reg_t)
	    {
		goto mmrw2;
	    }
	    else
	    {
		goto stmr4;
	    }
	mmrw2:
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 48e0 fff8
void m68kMovemLongListpPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3a4 push1
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    // 21e push2
	    reg_t = (reg_movemr == 0);
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] - 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    stepMovemPredec();
	    if (reg_t)
	    {
		goto push3;
	    }
	    else
	    {
		goto push4;
	    }
	push4:
	    // 0c3 push4
	    reg_aob = reg_au;
	    reg_dbout = reg_da[reg_movems];
	    reg_at = reg_au;
	    reg_au = reg_au - 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 21f push5
	    reg_aob = reg_au;
	    reg_t = (reg_movemr == 0);
	    reg_dbout = high16(reg_da[reg_movems]);
	    reg_at = reg_au;
	    reg_au = reg_au - 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    stepMovemPredec();
	    if (reg_t)
	    {
		goto push3;
	    }
	    else
	    {
		goto push4;
	    }
	push3:
	    // 043 push3
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_da[ry_index] = reg_at;
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 48e8 fff8
void m68kMovemLongListDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1f1 stmd1
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 3c9 stmd2
	    reg_aob = reg_au;
	    reg_at = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    // 322 stmd3
	    reg_t = (reg_movemr == 0);
	    reg_pc = reg_au;
	    reg_au = reg_da[ry_index] + ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto mmrw2;
	    }
	    else
	    {
		goto stmr4;
	    }
	stmr4:
	    // 0e5 stmr4
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_da[reg_movems]);
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ad stmr6
	    reg_aob = reg_au;
	    reg_t = (reg_movemr == 0);
	    reg_dbout = reg_da[reg_movems];
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    stepMovem();
	    if (reg_t)
	    {
		goto mmrw2;
	    }
	    else
	    {
		goto stmr4;
	    }
	mmrw2:
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 48f0 fff8
void m68kMovemLongListDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 325 stmx1
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 326 stmx2
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = reg_au - 2;
	    aluExt(reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 02f stmx3
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto stmx5;
	    }
	    else
	    {
		goto stmx4;
	    }
	stmx4:
	    // 138 stmx4
	    reg_t = (reg_movemr == 0);
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto mmrw2;
	    }
	    else
	    {
		goto stmr4;
	    }
	stmx5:
	    // 1f8 stmx5
	    reg_t = (reg_movemr == 0);
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto mmrw2;
	    }
	    else
	    {
		goto stmr4;
	    }
	stmr4:
	    // 0e5 stmr4
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_da[reg_movems]);
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ad stmr6
	    reg_aob = reg_au;
	    reg_t = (reg_movemr == 0);
	    reg_dbout = reg_da[reg_movems];
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    stepMovem();
	    if (reg_t)
	    {
		goto mmrw2;
	    }
	    else
	    {
		goto stmr4;
	    }
	mmrw2:
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 48f8 ffff
void m68kMovemLongListAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1ed smaw1
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 3c1 smaw2
	    reg_aob = reg_au;
	    reg_at = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    // 04b smaw3
	    reg_t = (reg_movemr == 0);
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto mmrw2;
	    }
	    else
	    {
		goto stmr4;
	    }
	stmr4:
	    // 0e5 stmr4
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_da[reg_movems]);
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ad stmr6
	    reg_aob = reg_au;
	    reg_t = (reg_movemr == 0);
	    reg_dbout = reg_da[reg_movems];
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    stepMovem();
	    if (reg_t)
	    {
		goto mmrw2;
	    }
	    else
	    {
		goto stmr4;
	    }
	mmrw2:
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 48f9 ffff
void m68kMovemLongListAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e5 smal1
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 112 smal2
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 305 smal3
	    reg_aob = reg_au;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    // 04b smaw3
	    reg_t = (reg_movemr == 0);
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto mmrw2;
	    }
	    else
	    {
		goto stmr4;
	    }
	stmr4:
	    // 0e5 stmr4
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_da[reg_movems]);
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ad stmr6
	    reg_aob = reg_au;
	    reg_t = (reg_movemr == 0);
	    reg_dbout = reg_da[reg_movems];
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    stepMovem();
	    if (reg_t)
	    {
		goto mmrw2;
	    }
	    else
	    {
		goto stmr4;
	    }
	mmrw2:
	    // 025 mmrw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4a00 fff8
void m68kTstByteDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 12d tsrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    aluAndByte(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4a10 fff8
void m68kTstByteAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4a18 fff8
void m68kTstByteAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_da[reg_movems], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4a20 fff8
void m68kTstBytePaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_da[reg_movems], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4a28 fff8
void m68kTstByteDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4a30 fff8
void m68kTstByteDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4a38 ffff
void m68kTstByteAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluOrByte(reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4a39 ffff
void m68kTstByteAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluOrByte(reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4a40 fff8
void m68kTstWordDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 12d tsrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4a50 fff8
void m68kTstWordAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4a58 fff8
void m68kTstWordAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluOr(reg_da[reg_movems], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4a60 fff8
void m68kTstWordPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - 2;
	    aluOr(reg_da[reg_movems], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4a68 fff8
void m68kTstWordDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4a70 fff8
void m68kTstWordDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4a78 ffff
void m68kTstWordAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluOr(reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4a79 ffff
void m68kTstWordAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluOr(reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c3 tsmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4a80 fff8
void m68kTstLongDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 125 tsrl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    // 362 tsrl2
	    reg_ird = reg_ir;
	    setIntState();
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    updateNZU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4a90 fff8
void m68kTstLongAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3cb tsml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 361 tsml2
	    reg_ird = reg_ir;
	    setIntState();
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4a98 fff8
void m68kTstLongAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3cb tsml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 361 tsml2
	    reg_ird = reg_ir;
	    setIntState();
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4aa0 fff8
void m68kTstLongPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3cb tsml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 361 tsml2
	    reg_ird = reg_ir;
	    setIntState();
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4aa8 fff8
void m68kTstLongDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3cb tsml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 361 tsml2
	    reg_ird = reg_ir;
	    setIntState();
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4ab0 fff8
void m68kTstLongDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3cb tsml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 361 tsml2
	    reg_ird = reg_ir;
	    setIntState();
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4ab8 ffff
void m68kTstLongAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluOr(reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3cb tsml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 361 tsml2
	    reg_ird = reg_ir;
	    setIntState();
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4ab9 ffff
void m68kTstLongAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 00d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluOr(reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3cb tsml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 361 tsml2
	    reg_ird = reg_ir;
	    setIntState();
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4ac0 fff8
void m68kTasDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 345 tasr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[ry_index];
	    reg_pc = reg_au;
	    aluOrByte(reg_ftu, reg_da[ry_index]);
	    // 346 tasr2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_au + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4ad0 fff8
void m68kTasAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readRMC();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 343 tasm1
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOrByte(reg_ftu, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 344 tasm2
	    reg_aob = reg_au;
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc;
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeRMC();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4ad8 fff8
void m68kTasAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_da[reg_movems], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readRMC();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 343 tasm1
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOrByte(reg_ftu, reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 344 tasm2
	    reg_aob = reg_au;
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc;
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeRMC();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4ae0 fff8
void m68kTasPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_da[reg_movems], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readRMC();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 343 tasm1
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOrByte(reg_ftu, reg_dbin);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 344 tasm2
	    reg_aob = reg_au;
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc;
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeRMC();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4ae8 fff8
void m68kTasDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readRMC();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 343 tasm1
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOrByte(reg_ftu, reg_dbin);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 344 tasm2
	    reg_aob = reg_au;
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc;
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeRMC();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4af0 fff8
void m68kTasDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[reg_movems];
	    setFC(true, false, true, false, false);
	    readRMC();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 343 tasm1
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOrByte(reg_ftu, reg_dbin);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 344 tasm2
	    reg_aob = reg_au;
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc;
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeRMC();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4af8 ffff
void m68kTasAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluOrByte(reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readRMC();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 343 tasm1
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOrByte(reg_ftu, reg_dbin);
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 344 tasm2
	    reg_aob = reg_au;
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc;
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeRMC();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4af9 ffff
void m68kTasAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[reg_movems];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluOrByte(reg_da[reg_movems], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readRMC();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 343 tasm1
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOrByte(reg_ftu, reg_dbin);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 344 tasm2
	    reg_aob = reg_au;
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc;
	    aluAndByte(reg_dbin, 0xFFFF);
	    updateNZVC();
	    setFC(true, false, false, false, false);
	    writeRMC();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4c90 fff8
void m68kMovemWordAisListProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 127 ldmr1
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 111 ldmr2
	    reg_aob = reg_da[ry_index];
	    reg_t = (reg_movemr == 0);
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto mmaw2;
	    }
	    else
	    {
		goto ldmr4;
	    }
	ldmr4:
	    // 3a8 ldmr4
	    reg_aob = reg_au;
	    reg_t = (reg_movemr == 0);
	    reg_at = reg_au;
	    reg_da[reg_movems] = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto mmaw2;
	    }
	    else
	    {
		goto ldmr4;
	    }
	mmaw2:
	    // 328 mmaw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4c98 fff8
void m68kMovemWordAipsListProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 123 popm1
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 115 popm2
	    reg_aob = reg_da[ry_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_movemr == 0);
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto popm6;
	    }
	    else
	    {
		goto popm4;
	    }
	popm4:
	    // 3ac popm4
	    reg_aob = reg_au;
	    reg_t = (reg_movemr == 0);
	    reg_at = reg_au;
	    reg_da[reg_movems] = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto popm6;
	    }
	    else
	    {
		goto popm4;
	    }
	popm6:
	    // 32c popm6
	    reg_aob = reg_pc;
	    reg_da[ry_index] = reg_at;
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4ca8 fff8
void m68kMovemWordDasListProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1fd ldmd1
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2f6 ldmd2
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    // 276 ldmd3
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 237 ldmd4
	    reg_aob = reg_at;
	    reg_t = (reg_movemr == 0);
	    reg_pc = reg_au;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto mmaw2;
	    }
	    else
	    {
		goto ldmr4;
	    }
	ldmr4:
	    // 3a8 ldmr4
	    reg_aob = reg_au;
	    reg_t = (reg_movemr == 0);
	    reg_at = reg_au;
	    reg_da[reg_movems] = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto mmaw2;
	    }
	    else
	    {
		goto ldmr4;
	    }
	mmaw2:
	    // 328 mmaw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4cb0 fff8
void m68kMovemWordDaisListProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1f5 ldmx0
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 027 ldmx1
	    aluExt(reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 02b ldmx2
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto ldmx4;
	    }
	    else
	    {
		goto ldmx3;
	    }
	ldmx3:
	    // 021 ldmx3
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto ldmx5;
	ldmx4:
	    // 0e1 ldmx4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto ldmx5;
	ldmx5:
	    // 02e ldmx5
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 277 ldmx6
	    reg_t = (reg_movemr == 0);
	    reg_pc = reg_au;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto mmaw2;
	    }
	    else
	    {
		goto ldmr4;
	    }
	ldmr4:
	    // 3a8 ldmr4
	    reg_aob = reg_au;
	    reg_t = (reg_movemr == 0);
	    reg_at = reg_au;
	    reg_da[reg_movems] = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto mmaw2;
	    }
	    else
	    {
		goto ldmr4;
	    }
	mmaw2:
	    // 328 mmaw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4cb8 ffff
void m68kMovemWordAdr16ListProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1f9 lmaw1
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 30e lmaw2
	    reg_aob = reg_au;
	    reg_dt = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 111 ldmr2
	    reg_aob = reg_dt;
	    reg_t = (reg_movemr == 0);
	    reg_pc = reg_au;
	    reg_at = reg_dt;
	    reg_au = reg_dt + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto mmaw2;
	    }
	    else
	    {
		goto ldmr4;
	    }
	ldmr4:
	    // 3a8 ldmr4
	    reg_aob = reg_au;
	    reg_t = (reg_movemr == 0);
	    reg_at = reg_au;
	    reg_da[reg_movems] = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto mmaw2;
	    }
	    else
	    {
		goto ldmr4;
	    }
	mmaw2:
	    // 328 mmaw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4cb9 ffff
void m68kMovemWordAdr32ListProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e9 lmal1
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 0af lmal2
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 0ee lmal3
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 111 ldmr2
	    reg_aob = reg_dt;
	    reg_t = (reg_movemr == 0);
	    reg_pc = reg_au;
	    reg_at = reg_dt;
	    reg_au = reg_dt + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto mmaw2;
	    }
	    else
	    {
		goto ldmr4;
	    }
	ldmr4:
	    // 3a8 ldmr4
	    reg_aob = reg_au;
	    reg_t = (reg_movemr == 0);
	    reg_at = reg_au;
	    reg_da[reg_movems] = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto mmaw2;
	    }
	    else
	    {
		goto ldmr4;
	    }
	mmaw2:
	    // 328 mmaw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4cba ffff
void m68kMovemWordDpcListProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1fd ldmd1
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2f6 ldmd2
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    // 276 ldmd3
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 237 ldmd4
	    reg_aob = reg_at;
	    reg_t = (reg_movemr == 0);
	    reg_pc = reg_au;
	    reg_au = reg_at + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto mmaw2;
	    }
	    else
	    {
		goto ldmr4;
	    }
	ldmr4:
	    // 3a8 ldmr4
	    reg_aob = reg_au;
	    reg_t = (reg_movemr == 0);
	    reg_at = reg_au;
	    reg_da[reg_movems] = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto mmaw2;
	    }
	    else
	    {
		goto ldmr4;
	    }
	mmaw2:
	    // 328 mmaw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4cbb ffff
void m68kMovemWordDpciListProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1f5 ldmx0
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 027 ldmx1
	    aluExt(reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 02b ldmx2
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto ldmx4;
	    }
	    else
	    {
		goto ldmx3;
	    }
	ldmx3:
	    // 021 ldmx3
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto ldmx5;
	ldmx4:
	    // 0e1 ldmx4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto ldmx5;
	ldmx5:
	    // 02e ldmx5
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 277 ldmx6
	    reg_t = (reg_movemr == 0);
	    reg_pc = reg_au;
	    reg_au = reg_at + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto mmaw2;
	    }
	    else
	    {
		goto ldmr4;
	    }
	ldmr4:
	    // 3a8 ldmr4
	    reg_aob = reg_au;
	    reg_t = (reg_movemr == 0);
	    reg_at = reg_au;
	    reg_da[reg_movems] = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto mmaw2;
	    }
	    else
	    {
		goto ldmr4;
	    }
	mmaw2:
	    // 328 mmaw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4cd0 fff8
void m68kMovemLongAisListProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 127 ldmr1
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 111 ldmr2
	    reg_aob = reg_da[ry_index];
	    reg_t = (reg_movemr == 0);
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto mmaw2;
	    }
	    else
	    {
		goto ldmr3;
	    }
	ldmr3:
	    // 3e8 ldmr3
	    reg_aob = reg_au;
	    setReg16High(reg_da[reg_movems], reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f0 ldmr5
	    reg_aob = reg_au;
	    reg_t = (reg_movemr == 0);
	    reg_at = reg_au;
	    setReg16Low(reg_da[reg_movems], reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto mmaw2;
	    }
	    else
	    {
		goto ldmr3;
	    }
	mmaw2:
	    // 328 mmaw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4cd8 fff8
void m68kMovemLongAipsListProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 123 popm1
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 115 popm2
	    reg_aob = reg_da[ry_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_movemr == 0);
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto popm6;
	    }
	    else
	    {
		goto popm3;
	    }
	popm3:
	    // 3ec popm3
	    reg_aob = reg_au;
	    setReg16High(reg_da[reg_movems], reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f4 popm5
	    reg_aob = reg_au;
	    reg_t = (reg_movemr == 0);
	    reg_at = reg_au;
	    setReg16Low(reg_da[reg_movems], reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto popm6;
	    }
	    else
	    {
		goto popm3;
	    }
	popm6:
	    // 32c popm6
	    reg_aob = reg_pc;
	    reg_da[ry_index] = reg_at;
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4ce8 fff8
void m68kMovemLongDasListProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1fd ldmd1
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2f6 ldmd2
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    // 276 ldmd3
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 237 ldmd4
	    reg_aob = reg_at;
	    reg_t = (reg_movemr == 0);
	    reg_pc = reg_au;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto mmaw2;
	    }
	    else
	    {
		goto ldmr3;
	    }
	ldmr3:
	    // 3e8 ldmr3
	    reg_aob = reg_au;
	    setReg16High(reg_da[reg_movems], reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f0 ldmr5
	    reg_aob = reg_au;
	    reg_t = (reg_movemr == 0);
	    reg_at = reg_au;
	    setReg16Low(reg_da[reg_movems], reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto mmaw2;
	    }
	    else
	    {
		goto ldmr3;
	    }
	mmaw2:
	    // 328 mmaw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4cf0 fff8
void m68kMovemLongDaisListProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1f5 ldmx0
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 027 ldmx1
	    aluExt(reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 02b ldmx2
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto ldmx4;
	    }
	    else
	    {
		goto ldmx3;
	    }
	ldmx3:
	    // 021 ldmx3
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto ldmx5;
	ldmx4:
	    // 0e1 ldmx4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto ldmx5;
	ldmx5:
	    // 02e ldmx5
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 277 ldmx6
	    reg_t = (reg_movemr == 0);
	    reg_pc = reg_au;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto mmaw2;
	    }
	    else
	    {
		goto ldmr3;
	    }
	ldmr3:
	    // 3e8 ldmr3
	    reg_aob = reg_au;
	    setReg16High(reg_da[reg_movems], reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f0 ldmr5
	    reg_aob = reg_au;
	    reg_t = (reg_movemr == 0);
	    reg_at = reg_au;
	    setReg16Low(reg_da[reg_movems], reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto mmaw2;
	    }
	    else
	    {
		goto ldmr3;
	    }
	mmaw2:
	    // 328 mmaw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4cf8 ffff
void m68kMovemLongAdr16ListProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1f9 lmaw1
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 30e lmaw2
	    reg_aob = reg_au;
	    reg_dt = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 111 ldmr2
	    reg_aob = reg_dt;
	    reg_t = (reg_movemr == 0);
	    reg_pc = reg_au;
	    reg_at = reg_dt;
	    reg_au = reg_dt + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto mmaw2;
	    }
	    else
	    {
		goto ldmr3;
	    }
	ldmr3:
	    // 3e8 ldmr3
	    reg_aob = reg_au;
	    setReg16High(reg_da[reg_movems], reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f0 ldmr5
	    reg_aob = reg_au;
	    reg_t = (reg_movemr == 0);
	    reg_at = reg_au;
	    setReg16Low(reg_da[reg_movems], reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto mmaw2;
	    }
	    else
	    {
		goto ldmr3;
	    }
	mmaw2:
	    // 328 mmaw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4cf9 ffff
void m68kMovemLongAdr32ListProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e9 lmal1
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 0af lmal2
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 0ee lmal3
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 111 ldmr2
	    reg_aob = reg_dt;
	    reg_t = (reg_movemr == 0);
	    reg_pc = reg_au;
	    reg_at = reg_dt;
	    reg_au = reg_dt + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto mmaw2;
	    }
	    else
	    {
		goto ldmr3;
	    }
	ldmr3:
	    // 3e8 ldmr3
	    reg_aob = reg_au;
	    setReg16High(reg_da[reg_movems], reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f0 ldmr5
	    reg_aob = reg_au;
	    reg_t = (reg_movemr == 0);
	    reg_at = reg_au;
	    setReg16Low(reg_da[reg_movems], reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto mmaw2;
	    }
	    else
	    {
		goto ldmr3;
	    }
	mmaw2:
	    // 328 mmaw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4cfa ffff
void m68kMovemLongDpcListProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1fd ldmd1
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 2f6 ldmd2
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    // 276 ldmd3
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 237 ldmd4
	    reg_aob = reg_at;
	    reg_t = (reg_movemr == 0);
	    reg_pc = reg_au;
	    reg_au = reg_at + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto mmaw2;
	    }
	    else
	    {
		goto ldmr3;
	    }
	ldmr3:
	    // 3e8 ldmr3
	    reg_aob = reg_au;
	    setReg16High(reg_da[reg_movems], reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f0 ldmr5
	    reg_aob = reg_au;
	    reg_t = (reg_movemr == 0);
	    reg_at = reg_au;
	    setReg16Low(reg_da[reg_movems], reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto mmaw2;
	    }
	    else
	    {
		goto ldmr3;
	    }
	mmaw2:
	    // 328 mmaw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4cfb ffff
void m68kMovemLongDpciListProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1f5 ldmx0
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 027 ldmx1
	    aluExt(reg_dbin);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 02b ldmx2
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto ldmx4;
	    }
	    else
	    {
		goto ldmx3;
	    }
	ldmx3:
	    // 021 ldmx3
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto ldmx5;
	ldmx4:
	    // 0e1 ldmx4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    goto ldmx5;
	ldmx5:
	    // 02e ldmx5
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 277 ldmx6
	    reg_t = (reg_movemr == 0);
	    reg_pc = reg_au;
	    reg_au = reg_at + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto mmaw2;
	    }
	    else
	    {
		goto ldmr3;
	    }
	ldmr3:
	    // 3e8 ldmr3
	    reg_aob = reg_au;
	    setReg16High(reg_da[reg_movems], reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f0 ldmr5
	    reg_aob = reg_au;
	    reg_t = (reg_movemr == 0);
	    reg_at = reg_au;
	    setReg16Low(reg_da[reg_movems], reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    stepMovem();
	    if (reg_t)
	    {
		goto mmaw2;
	    }
	    else
	    {
		goto ldmr3;
	    }
	mmaw2:
	    // 328 mmaw2
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4e40 fff0
void m68kTrapImm4Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1d0 trap1
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 347 trap2
	    initST();
	    reg_au = reg_da[16] - 2;
	    aluAnd(reg_pc, 0xFFFF);
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x80 | ((reg_ird & 0xF) << 2));
	    reg_da[16] = reg_au;
	    reg_ftu = 0x80 | ((reg_ird & 0xF) << 2);
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4e50 fff8
void m68kLinkAsImm16Program()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 30b link1
	    reg_aob = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_au + 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    // 2b5 link2
	    reg_pc = reg_au;
	    reg_au = reg_da[reg_sp] - 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 30c link3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = high16(reg_at);
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 30d link4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 349 mmiw2
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[reg_sp] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4e58 fff8
void m68kUnlkAsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 119 unlk1
	    reg_aob = reg_da[ry_index];
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    stepMovem();
	    // 1fe unlk2
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 27c unlk3
	    reg_aob = reg_pc;
	    reg_da[reg_sp] = reg_au;
	    reg_au = reg_pc + 2;
	    // 27d unlk4
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[ry_index] = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4e60 fff8
void m68kMoveAsUspProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    if (!testbit(reg_sr, 13))
	    {
		setPriv();
		return;
	    }

	    // 2f5 lusp1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_at = reg_da[ry_index];
	    reg_ftu = reg_dbin;
	    // 066 leaa2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[15] = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4e68 fff8
void m68kMoveUspAsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    if (!testbit(reg_sr, 13))
	    {
		setPriv();
		return;
	    }

	    // 230 susp1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dcr = reg_da[15];
	    reg_at = reg_da[15];
	    reg_au = reg_da[ry_index];
	    // 233 extr2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[ry_index] = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4e70 ffff
void m68kResetProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    if (!testbit(reg_sr, 13))
	    {
		setPriv();
		return;
	    }

	    // 3a6 rset1
	    reg_ird = reg_ir;
	    setIntState();
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0x0000);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 27b rset2
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = ext32(reg_aluo) - 2;
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    goto rset3;
	rset3:
	    // 0e4 rset3
	    reg_au = reg_au - 2;
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 114 rset4
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (reg_t)
	    {
		goto rset5;
	    }
	    else
	    {
		goto rset3;
	    }
	rset5:
	    // 064 rset5
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4e71 ffff
void m68kNopProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4e72 ffff
void m68kStopI16uProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    if (!testbit(reg_sr, 13))
	    {
		setPriv();
		return;
	    }

	    // 3a2 stop1
	    reg_ird = reg_ir;
	    setIntState();
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0x0000);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 327 aaa01
	    reg_ird = reg_ir;
	    setIntState();
	    reg_pc = reg_au;
	    reg_sr = reg_isr = (reg_ftu & 0xA71F);
	    updateSupervisor();
	    updateInterrupts();
	    reg_au = reg_au - 2;
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    nextInst();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4e73 ffff
void m68kRteProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    if (!testbit(reg_sr, 13))
	    {
		setPriv();
		return;
	    }

	    // 12a rtr1
	    reg_aob = reg_da[reg_sp];
	    reg_au = reg_da[reg_sp] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 12b rtr2
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 3c5 rtr3
	    reg_aob = reg_au;
	    reg_at = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    // 302 rtr4
	    setReg16High(reg_at, reg_dbin);
	    reg_da[reg_sp] = reg_au;
	    reg_new_sr = reg_isr = (reg_ftu & 0xA71F);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_sr = reg_new_sr;
	    updateSupervisor();
	    updateInterrupts();
	    reg_dbin = reg_edb;
	    // 2b3 jmal2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4e75 ffff
void m68kRtsProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 126 rts1
	    reg_aob = reg_da[reg_sp];
	    reg_au = reg_da[reg_sp] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 116 rts2
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 303 rts3
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_da[reg_sp] = reg_au;
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4e76 ffff
void m68kTrapvProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 06d trpv1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_isr & SrOverflow) ? 1 : 0;
	    reg_alub = reg_dbin;
	    reg_ftu = reg_sr;
	    if (reg_t)
	    {
		goto trpv3;
	    }
	    else
	    {
		goto trpv2;
	    }
	trpv2:
	    // 0e2 trpv2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	trpv3:
	    // 022 trpv3
	    initST();
	    reg_au = reg_da[16] - 2;
	    aluAnd(reg_pc, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x07);
	    reg_da[16] = reg_au;
	    reg_ftu = 0x001c;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4e77 ffff
void m68kRtrProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 12a rtr1
	    reg_aob = reg_da[reg_sp];
	    reg_au = reg_da[reg_sp] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 12b rtr2
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 3c5 rtr3
	    reg_aob = reg_au;
	    reg_at = ext32(reg_dbin);
	    reg_au = reg_au + 2;
	    // 302 rtr4
	    setReg16High(reg_at, reg_dbin);
	    reg_da[reg_sp] = reg_au;
	    reg_sr = reg_isr = ((reg_ftu & 0x1F) | (reg_sr & 0xA700));
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b3 jmal2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4e90 fff8
void m68kJsrAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 273 jsra1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[reg_sp] - 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 271 jsaw2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_pc);
	    reg_da[reg_sp] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 272 jsaw3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_pc;
	    reg_au = reg_at + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4ea8 fff8
void m68kJsrDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b0 jsrd1
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 274 jsrd2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    // 2b1 jsrd3
	    reg_pc = reg_au;
	    reg_au = reg_da[reg_sp] - 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 271 jsaw2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_pc);
	    reg_da[reg_sp] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 272 jsaw3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_pc;
	    reg_au = reg_at + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4eb0 fff8
void m68kJsrDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1f3 jsrx0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 2b2 jsrx1
	    reg_t = testbit(reg_irc, 11);
	    reg_au = ext32(reg_aluo) + reg_da[ry_index];
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto jsrx3;
	    }
	    else
	    {
		goto jsrx2;
	    }
	jsrx2:
	    // 029 jsrx2
	    reg_au = reg_au + ext32(reg_da[mapSP(reg_irc >> 12)]);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    goto jsrd2;
	jsrx3:
	    // 0e9 jsrx3
	    reg_au = reg_au + reg_da[mapSP(reg_irc >> 12)];
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    goto jsrd2;
	jsrd2:
	    // 274 jsrd2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    // 2b1 jsrd3
	    reg_pc = reg_au;
	    reg_au = reg_da[reg_sp] - 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 271 jsaw2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_pc);
	    reg_da[reg_sp] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 272 jsaw3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_pc;
	    reg_au = reg_at + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4eb8 ffff
void m68kJsrAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 293 jsaw0
	    reg_at = ext32(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 270 jsaw1
	    reg_aob = reg_at;
	    reg_pc = reg_au;
	    reg_au = reg_da[reg_sp] - 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 271 jsaw2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_pc);
	    reg_da[reg_sp] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 272 jsaw3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_pc;
	    reg_au = reg_at + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4eb9 ffff
void m68kJsrAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1f2 jsal1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 256 jsal2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_pc = reg_au;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = reg_da[reg_sp] - 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 271 jsaw2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_pc);
	    reg_da[reg_sp] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 272 jsaw3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_pc;
	    reg_au = reg_at + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4eba ffff
void m68kJsrDpcProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b0 jsrd1
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 274 jsrd2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    // 2b1 jsrd3
	    reg_pc = reg_au;
	    reg_au = reg_da[reg_sp] - 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 271 jsaw2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_pc);
	    reg_da[reg_sp] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 272 jsaw3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_pc;
	    reg_au = reg_at + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4ebb ffff
void m68kJsrDpciProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1f3 jsrx0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 2b2 jsrx1
	    reg_t = testbit(reg_irc, 11);
	    reg_au = ext32(reg_aluo) + reg_pc;
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto jsrx3;
	    }
	    else
	    {
		goto jsrx2;
	    }
	jsrx2:
	    // 029 jsrx2
	    reg_au = reg_au + ext32(reg_da[mapSP(reg_irc >> 12)]);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    goto jsrd2;
	jsrx3:
	    // 0e9 jsrx3
	    reg_au = reg_au + reg_da[mapSP(reg_irc >> 12)];
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    goto jsrd2;
	jsrd2:
	    // 274 jsrd2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    // 2b1 jsrd3
	    reg_pc = reg_au;
	    reg_au = reg_da[reg_sp] - 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 271 jsaw2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_pc);
	    reg_da[reg_sp] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 272 jsaw3
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_pc;
	    reg_au = reg_at + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4ed0 fff8
void m68kJmpAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 255 jmpa1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4ee8 fff8
void m68kJmpDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b4 jmpd1
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4ef0 fff8
void m68kJmpDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1f7 jmpx0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 2b6 jmpx1
	    reg_t = testbit(reg_irc, 11);
	    reg_au = ext32(reg_aluo) + reg_da[ry_index];
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto jmpx3;
	    }
	    else
	    {
		goto jmpx2;
	    }
	jmpx2:
	    // 02d jmpx2
	    reg_au = reg_au + ext32(reg_da[mapSP(reg_irc >> 12)]);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    goto bbci3;
	jmpx3:
	    // 0ed jmpx3
	    reg_au = reg_au + reg_da[mapSP(reg_irc >> 12)];
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    goto bbci3;
	bbci3:
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4ef8 ffff
void m68kJmpAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 297 jmaw1
	    reg_at = ext32(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 2b3 jmal2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4ef9 ffff
void m68kJmpAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1f6 jmal1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b3 jmal2
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4efa ffff
void m68kJmpDpcProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2b4 jmpd1
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 4efb ffff
void m68kJmpDpciProgram()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1f7 jmpx0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 2b6 jmpx1
	    reg_t = testbit(reg_irc, 11);
	    reg_au = ext32(reg_aluo) + reg_pc;
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto jmpx3;
	    }
	    else
	    {
		goto jmpx2;
	    }
	jmpx2:
	    // 02d jmpx2
	    reg_au = reg_au + ext32(reg_da[mapSP(reg_irc >> 12)]);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    goto bbci3;
	jmpx3:
	    // 0ed jmpx3
	    reg_au = reg_au + reg_da[mapSP(reg_irc >> 12)];
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    goto bbci3;
	bbci3:
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5000 f1f8
void m68kAddqByteImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2d8 raqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    aluAddByte(reg_ftu, reg_da[ry_index]);
	    updateXNZVC();
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5010 f1f8
void m68kAddqByteImm3AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluAddByte(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5018 f1f8
void m68kAddqByteImm3AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluAddByte(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5020 f1f8
void m68kAddqByteImm3PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluAddByte(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5028 f1f8
void m68kAddqByteImm3DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluAddByte(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5030 f1f8
void m68kAddqByteImm3DaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluAddByte(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5038 f1ff
void m68kAddqByteImm3Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluAddByte(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5039 f1ff
void m68kAddqByteImm3Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluAddByte(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5040 f1f8
void m68kAddqWordImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2d8 raqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    aluAdd(reg_ftu, reg_da[ry_index]);
	    updateXNZVC();
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5048 f1f8
void m68kAddqWordImm3AsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2dc raql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    aluAdd(reg_ftu, reg_da[ry_index]);
	    // 259 roal2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25a roal3
	    aluAddc(high16(reg_dt), high16(reg_da[ry_index]));
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5050 f1f8
void m68kAddqWordImm3AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluAdd(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5058 f1f8
void m68kAddqWordImm3AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluAdd(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5060 f1f8
void m68kAddqWordImm3PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluAdd(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5068 f1f8
void m68kAddqWordImm3DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluAdd(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5070 f1f8
void m68kAddqWordImm3DaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluAdd(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5078 f1ff
void m68kAddqWordImm3Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluAdd(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5079 f1ff
void m68kAddqWordImm3Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluAdd(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5080 f1f8
void m68kAddqLongImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2dc raql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    aluAdd(reg_ftu, reg_da[ry_index]);
	    updateXNZVC();
	    // 259 roal2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25a roal3
	    aluAddc(high16(reg_dt), high16(reg_da[ry_index]));
	    updateXNZVCU();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5088 f1f8
void m68kAddqLongImm3AsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2dc raql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    aluAdd(reg_ftu, reg_da[ry_index]);
	    // 259 roal2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25a roal3
	    aluAddc(high16(reg_dt), high16(reg_da[ry_index]));
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5090 f1f8
void m68kAddqLongImm3AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluAdd(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAddc(high16(reg_dt), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5098 f1f8
void m68kAddqLongImm3AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluAdd(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAddc(high16(reg_dt), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 50a0 f1f8
void m68kAddqLongImm3PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluAdd(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAddc(high16(reg_dt), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 50a8 f1f8
void m68kAddqLongImm3DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluAdd(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAddc(high16(reg_dt), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 50b0 f1f8
void m68kAddqLongImm3DaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluAdd(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAddc(high16(reg_dt), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 50b8 f1ff
void m68kAddqLongImm3Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluAdd(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAddc(high16(reg_dt), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 50b9 f1ff
void m68kAddqLongImm3Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 00d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluAdd(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAddc(high16(reg_dt), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 50c0 fff8
void m68kStDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 384 sccr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 1;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccr2;
	    }
	    else
	    {
		goto roaw2;
	    }
	roaw2:
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	sccr2:
	    // 0cb sccr2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 50c8 fff8
void m68kDbtDsRel16Program()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 06c dbcc1
	    reg_t = 1;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto dbcc6;
	    }
	    else
	    {
		goto dbcc2;
	    }
	dbcc2:
	    // 046 dbcc2
	    reg_aob = reg_au;
	    reg_alub = reg_da[ry_index];
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    // 175 dbcc3
	    reg_t = (reg_isr & SrZero) ? 1 : 0;
	    reg_pc = reg_au;
	    reg_au = reg_at + 2;
	    aluAdd(reg_alub, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    if (reg_t)
	    {
		goto dbcc5;
	    }
	    else
	    {
		goto dbcc4;
	    }
	dbcc6:
	    // 0c6 dbcc6
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setTrace();
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dbcc4:
	    // 0c7 dbcc4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dbcc5:
	    // 007 dbcc5
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    setTrace();
	    goto dbcc4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 50d0 fff8
void m68kStAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 1;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 50d8 fff8
void m68kStAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 1;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 50e0 fff8
void m68kStPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_dt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 1;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 50e8 fff8
void m68kStDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 1;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 50f0 fff8
void m68kStDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 1;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 50f8 ffff
void m68kStAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluOrByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 1;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 50f9 ffff
void m68kStAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluOrByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 1;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5100 f1f8
void m68kSubqByteImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2d8 raqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    aluSubByte(reg_ftu, reg_da[ry_index]);
	    updateXNZVC();
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5110 f1f8
void m68kSubqByteImm3AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluSubByte(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5118 f1f8
void m68kSubqByteImm3AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluSubByte(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5120 f1f8
void m68kSubqByteImm3PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluSubByte(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5128 f1f8
void m68kSubqByteImm3DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluSubByte(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5130 f1f8
void m68kSubqByteImm3DaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluSubByte(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5138 f1ff
void m68kSubqByteImm3Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluSubByte(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5139 f1ff
void m68kSubqByteImm3Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluSubByte(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5140 f1f8
void m68kSubqWordImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2d8 raqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    aluSub(reg_ftu, reg_da[ry_index]);
	    updateXNZVC();
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5148 f1f8
void m68kSubqWordImm3AsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2dc raql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    aluSub(reg_ftu, reg_da[ry_index]);
	    // 259 roal2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25a roal3
	    aluSubc(high16(reg_dt), high16(reg_da[ry_index]));
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5150 f1f8
void m68kSubqWordImm3AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluSub(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5158 f1f8
void m68kSubqWordImm3AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluSub(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5160 f1f8
void m68kSubqWordImm3PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluSub(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5168 f1f8
void m68kSubqWordImm3DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluSub(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5170 f1f8
void m68kSubqWordImm3DaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluSub(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5178 f1ff
void m68kSubqWordImm3Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluSub(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5179 f1ff
void m68kSubqWordImm3Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f3 maqw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluSub(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5180 f1f8
void m68kSubqLongImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2dc raql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    aluSub(reg_ftu, reg_da[ry_index]);
	    updateXNZVC();
	    // 259 roal2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25a roal3
	    aluSubc(high16(reg_dt), high16(reg_da[ry_index]));
	    updateXNZVCU();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5188 f1f8
void m68kSubqLongImm3AsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 2dc raql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    aluSub(reg_ftu, reg_da[ry_index]);
	    // 259 roal2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25a roal3
	    aluSubc(high16(reg_dt), high16(reg_da[ry_index]));
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5190 f1f8
void m68kSubqLongImm3AisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluSub(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluSubc(high16(reg_dt), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5198 f1f8
void m68kSubqLongImm3AipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluSub(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluSubc(high16(reg_dt), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 51a0 f1f8
void m68kSubqLongImm3PaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluSub(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluSubc(high16(reg_dt), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 51a8 f1f8
void m68kSubqLongImm3DasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluSub(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluSubc(high16(reg_dt), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 51b0 f1f8
void m68kSubqLongImm3DaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluSub(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluSubc(high16(reg_dt), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 51b8 f1ff
void m68kSubqLongImm3Adr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluSub(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluSubc(high16(reg_dt), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 51b9 f1ff
void m68kSubqLongImm3Adr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 00d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2f7 maql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dt = ext32(reg_ftu);
	    reg_au = reg_at;
	    aluSub(reg_ftu, reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluSubc(high16(reg_dt), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 51c0 fff8
void m68kSfDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 384 sccr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccr2;
	    }
	    else
	    {
		goto roaw2;
	    }
	roaw2:
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	sccr2:
	    // 0cb sccr2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 51c8 fff8
void m68kDbraDsRel16Program()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 06c dbcc1
	    reg_t = 0;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto dbcc6;
	    }
	    else
	    {
		goto dbcc2;
	    }
	dbcc2:
	    // 046 dbcc2
	    reg_aob = reg_au;
	    reg_alub = reg_da[ry_index];
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    // 175 dbcc3
	    reg_t = (reg_isr & SrZero) ? 1 : 0;
	    reg_pc = reg_au;
	    reg_au = reg_at + 2;
	    aluAdd(reg_alub, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    if (reg_t)
	    {
		goto dbcc5;
	    }
	    else
	    {
		goto dbcc4;
	    }
	dbcc6:
	    // 0c6 dbcc6
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setTrace();
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dbcc4:
	    // 0c7 dbcc4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dbcc5:
	    // 007 dbcc5
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    setTrace();
	    goto dbcc4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 51d0 fff8
void m68kSfAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 51d8 fff8
void m68kSfAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 51e0 fff8
void m68kSfPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_dt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 51e8 fff8
void m68kSfDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 51f0 fff8
void m68kSfDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 51f8 ffff
void m68kSfAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluOrByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 51f9 ffff
void m68kSfAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluOrByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 52c0 fff8
void m68kShiDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 384 sccr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = ((reg_sr & (SrCarry | SrZero)) == 0) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccr2;
	    }
	    else
	    {
		goto roaw2;
	    }
	roaw2:
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	sccr2:
	    // 0cb sccr2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 52c8 fff8
void m68kDbhiDsRel16Program()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 06c dbcc1
	    reg_t = ((reg_sr & (SrCarry | SrZero)) == 0) ? 1 : 0;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto dbcc6;
	    }
	    else
	    {
		goto dbcc2;
	    }
	dbcc2:
	    // 046 dbcc2
	    reg_aob = reg_au;
	    reg_alub = reg_da[ry_index];
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    // 175 dbcc3
	    reg_t = (reg_isr & SrZero) ? 1 : 0;
	    reg_pc = reg_au;
	    reg_au = reg_at + 2;
	    aluAdd(reg_alub, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    if (reg_t)
	    {
		goto dbcc5;
	    }
	    else
	    {
		goto dbcc4;
	    }
	dbcc6:
	    // 0c6 dbcc6
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setTrace();
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dbcc4:
	    // 0c7 dbcc4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dbcc5:
	    // 007 dbcc5
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    setTrace();
	    goto dbcc4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 52d0 fff8
void m68kShiAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = ((reg_sr & (SrCarry | SrZero)) == 0) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 52d8 fff8
void m68kShiAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = ((reg_sr & (SrCarry | SrZero)) == 0) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 52e0 fff8
void m68kShiPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_dt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = ((reg_sr & (SrCarry | SrZero)) == 0) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 52e8 fff8
void m68kShiDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = ((reg_sr & (SrCarry | SrZero)) == 0) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 52f0 fff8
void m68kShiDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = ((reg_sr & (SrCarry | SrZero)) == 0) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 52f8 ffff
void m68kShiAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluOrByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = ((reg_sr & (SrCarry | SrZero)) == 0) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 52f9 ffff
void m68kShiAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluOrByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = ((reg_sr & (SrCarry | SrZero)) == 0) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 53c0 fff8
void m68kSlsDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 384 sccr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = ((reg_sr & (SrCarry | SrZero)) != 0) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccr2;
	    }
	    else
	    {
		goto roaw2;
	    }
	roaw2:
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	sccr2:
	    // 0cb sccr2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 53c8 fff8
void m68kDblsDsRel16Program()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 06c dbcc1
	    reg_t = ((reg_sr & (SrCarry | SrZero)) != 0) ? 1 : 0;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto dbcc6;
	    }
	    else
	    {
		goto dbcc2;
	    }
	dbcc2:
	    // 046 dbcc2
	    reg_aob = reg_au;
	    reg_alub = reg_da[ry_index];
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    // 175 dbcc3
	    reg_t = (reg_isr & SrZero) ? 1 : 0;
	    reg_pc = reg_au;
	    reg_au = reg_at + 2;
	    aluAdd(reg_alub, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    if (reg_t)
	    {
		goto dbcc5;
	    }
	    else
	    {
		goto dbcc4;
	    }
	dbcc6:
	    // 0c6 dbcc6
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setTrace();
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dbcc4:
	    // 0c7 dbcc4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dbcc5:
	    // 007 dbcc5
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    setTrace();
	    goto dbcc4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 53d0 fff8
void m68kSlsAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = ((reg_sr & (SrCarry | SrZero)) != 0) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 53d8 fff8
void m68kSlsAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = ((reg_sr & (SrCarry | SrZero)) != 0) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 53e0 fff8
void m68kSlsPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_dt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = ((reg_sr & (SrCarry | SrZero)) != 0) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 53e8 fff8
void m68kSlsDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = ((reg_sr & (SrCarry | SrZero)) != 0) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 53f0 fff8
void m68kSlsDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = ((reg_sr & (SrCarry | SrZero)) != 0) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 53f8 ffff
void m68kSlsAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluOrByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = ((reg_sr & (SrCarry | SrZero)) != 0) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 53f9 ffff
void m68kSlsAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluOrByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = ((reg_sr & (SrCarry | SrZero)) != 0) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 54c0 fff8
void m68kSccDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 384 sccr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrCarry) ? 0 : 1;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccr2;
	    }
	    else
	    {
		goto roaw2;
	    }
	roaw2:
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	sccr2:
	    // 0cb sccr2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 54c8 fff8
void m68kDbccDsRel16Program()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 06c dbcc1
	    reg_t = (reg_sr & SrCarry) ? 0 : 1;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto dbcc6;
	    }
	    else
	    {
		goto dbcc2;
	    }
	dbcc2:
	    // 046 dbcc2
	    reg_aob = reg_au;
	    reg_alub = reg_da[ry_index];
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    // 175 dbcc3
	    reg_t = (reg_isr & SrZero) ? 1 : 0;
	    reg_pc = reg_au;
	    reg_au = reg_at + 2;
	    aluAdd(reg_alub, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    if (reg_t)
	    {
		goto dbcc5;
	    }
	    else
	    {
		goto dbcc4;
	    }
	dbcc6:
	    // 0c6 dbcc6
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setTrace();
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dbcc4:
	    // 0c7 dbcc4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dbcc5:
	    // 007 dbcc5
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    setTrace();
	    goto dbcc4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 54d0 fff8
void m68kSccAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrCarry) ? 0 : 1;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 54d8 fff8
void m68kSccAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrCarry) ? 0 : 1;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 54e0 fff8
void m68kSccPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_dt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrCarry) ? 0 : 1;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 54e8 fff8
void m68kSccDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrCarry) ? 0 : 1;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 54f0 fff8
void m68kSccDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrCarry) ? 0 : 1;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 54f8 ffff
void m68kSccAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluOrByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrCarry) ? 0 : 1;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 54f9 ffff
void m68kSccAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluOrByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrCarry) ? 0 : 1;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 55c0 fff8
void m68kScsDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 384 sccr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrCarry) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccr2;
	    }
	    else
	    {
		goto roaw2;
	    }
	roaw2:
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	sccr2:
	    // 0cb sccr2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 55c8 fff8
void m68kDbcsDsRel16Program()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 06c dbcc1
	    reg_t = (reg_sr & SrCarry) ? 1 : 0;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto dbcc6;
	    }
	    else
	    {
		goto dbcc2;
	    }
	dbcc2:
	    // 046 dbcc2
	    reg_aob = reg_au;
	    reg_alub = reg_da[ry_index];
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    // 175 dbcc3
	    reg_t = (reg_isr & SrZero) ? 1 : 0;
	    reg_pc = reg_au;
	    reg_au = reg_at + 2;
	    aluAdd(reg_alub, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    if (reg_t)
	    {
		goto dbcc5;
	    }
	    else
	    {
		goto dbcc4;
	    }
	dbcc6:
	    // 0c6 dbcc6
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setTrace();
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dbcc4:
	    // 0c7 dbcc4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dbcc5:
	    // 007 dbcc5
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    setTrace();
	    goto dbcc4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 55d0 fff8
void m68kScsAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrCarry) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 55d8 fff8
void m68kScsAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrCarry) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 55e0 fff8
void m68kScsPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_dt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrCarry) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 55e8 fff8
void m68kScsDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrCarry) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 55f0 fff8
void m68kScsDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrCarry) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 55f8 ffff
void m68kScsAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluOrByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrCarry) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 55f9 ffff
void m68kScsAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluOrByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrCarry) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 56c0 fff8
void m68kSneDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 384 sccr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrZero) ? 0 : 1;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccr2;
	    }
	    else
	    {
		goto roaw2;
	    }
	roaw2:
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	sccr2:
	    // 0cb sccr2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 56c8 fff8
void m68kDbneDsRel16Program()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 06c dbcc1
	    reg_t = (reg_sr & SrZero) ? 0 : 1;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto dbcc6;
	    }
	    else
	    {
		goto dbcc2;
	    }
	dbcc2:
	    // 046 dbcc2
	    reg_aob = reg_au;
	    reg_alub = reg_da[ry_index];
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    // 175 dbcc3
	    reg_t = (reg_isr & SrZero) ? 1 : 0;
	    reg_pc = reg_au;
	    reg_au = reg_at + 2;
	    aluAdd(reg_alub, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    if (reg_t)
	    {
		goto dbcc5;
	    }
	    else
	    {
		goto dbcc4;
	    }
	dbcc6:
	    // 0c6 dbcc6
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setTrace();
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dbcc4:
	    // 0c7 dbcc4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dbcc5:
	    // 007 dbcc5
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    setTrace();
	    goto dbcc4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 56d0 fff8
void m68kSneAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrZero) ? 0 : 1;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 56d8 fff8
void m68kSneAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrZero) ? 0 : 1;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 56e0 fff8
void m68kSnePaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_dt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrZero) ? 0 : 1;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 56e8 fff8
void m68kSneDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrZero) ? 0 : 1;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 56f0 fff8
void m68kSneDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrZero) ? 0 : 1;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 56f8 ffff
void m68kSneAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluOrByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrZero) ? 0 : 1;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 56f9 ffff
void m68kSneAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluOrByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrZero) ? 0 : 1;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 57c0 fff8
void m68kSeqDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 384 sccr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrZero) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccr2;
	    }
	    else
	    {
		goto roaw2;
	    }
	roaw2:
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	sccr2:
	    // 0cb sccr2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 57c8 fff8
void m68kDbeqDsRel16Program()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 06c dbcc1
	    reg_t = (reg_sr & SrZero) ? 1 : 0;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto dbcc6;
	    }
	    else
	    {
		goto dbcc2;
	    }
	dbcc2:
	    // 046 dbcc2
	    reg_aob = reg_au;
	    reg_alub = reg_da[ry_index];
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    // 175 dbcc3
	    reg_t = (reg_isr & SrZero) ? 1 : 0;
	    reg_pc = reg_au;
	    reg_au = reg_at + 2;
	    aluAdd(reg_alub, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    if (reg_t)
	    {
		goto dbcc5;
	    }
	    else
	    {
		goto dbcc4;
	    }
	dbcc6:
	    // 0c6 dbcc6
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setTrace();
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dbcc4:
	    // 0c7 dbcc4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dbcc5:
	    // 007 dbcc5
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    setTrace();
	    goto dbcc4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 57d0 fff8
void m68kSeqAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrZero) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 57d8 fff8
void m68kSeqAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrZero) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 57e0 fff8
void m68kSeqPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_dt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrZero) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 57e8 fff8
void m68kSeqDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrZero) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 57f0 fff8
void m68kSeqDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrZero) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 57f8 ffff
void m68kSeqAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluOrByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrZero) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 57f9 ffff
void m68kSeqAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluOrByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrZero) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 58c0 fff8
void m68kSvcDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 384 sccr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrOverflow) ? 0 : 1;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccr2;
	    }
	    else
	    {
		goto roaw2;
	    }
	roaw2:
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	sccr2:
	    // 0cb sccr2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 58c8 fff8
void m68kDbvcDsRel16Program()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 06c dbcc1
	    reg_t = (reg_sr & SrOverflow) ? 0 : 1;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto dbcc6;
	    }
	    else
	    {
		goto dbcc2;
	    }
	dbcc2:
	    // 046 dbcc2
	    reg_aob = reg_au;
	    reg_alub = reg_da[ry_index];
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    // 175 dbcc3
	    reg_t = (reg_isr & SrZero) ? 1 : 0;
	    reg_pc = reg_au;
	    reg_au = reg_at + 2;
	    aluAdd(reg_alub, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    if (reg_t)
	    {
		goto dbcc5;
	    }
	    else
	    {
		goto dbcc4;
	    }
	dbcc6:
	    // 0c6 dbcc6
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setTrace();
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dbcc4:
	    // 0c7 dbcc4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dbcc5:
	    // 007 dbcc5
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    setTrace();
	    goto dbcc4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 58d0 fff8
void m68kSvcAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrOverflow) ? 0 : 1;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 58d8 fff8
void m68kSvcAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrOverflow) ? 0 : 1;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 58e0 fff8
void m68kSvcPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_dt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrOverflow) ? 0 : 1;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 58e8 fff8
void m68kSvcDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrOverflow) ? 0 : 1;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 58f0 fff8
void m68kSvcDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrOverflow) ? 0 : 1;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 58f8 ffff
void m68kSvcAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluOrByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrOverflow) ? 0 : 1;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 58f9 ffff
void m68kSvcAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluOrByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrOverflow) ? 0 : 1;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 59c0 fff8
void m68kSvsDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 384 sccr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrOverflow) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccr2;
	    }
	    else
	    {
		goto roaw2;
	    }
	roaw2:
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	sccr2:
	    // 0cb sccr2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 59c8 fff8
void m68kDbvsDsRel16Program()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 06c dbcc1
	    reg_t = (reg_sr & SrOverflow) ? 1 : 0;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto dbcc6;
	    }
	    else
	    {
		goto dbcc2;
	    }
	dbcc2:
	    // 046 dbcc2
	    reg_aob = reg_au;
	    reg_alub = reg_da[ry_index];
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    // 175 dbcc3
	    reg_t = (reg_isr & SrZero) ? 1 : 0;
	    reg_pc = reg_au;
	    reg_au = reg_at + 2;
	    aluAdd(reg_alub, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    if (reg_t)
	    {
		goto dbcc5;
	    }
	    else
	    {
		goto dbcc4;
	    }
	dbcc6:
	    // 0c6 dbcc6
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setTrace();
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dbcc4:
	    // 0c7 dbcc4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dbcc5:
	    // 007 dbcc5
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    setTrace();
	    goto dbcc4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 59d0 fff8
void m68kSvsAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrOverflow) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 59d8 fff8
void m68kSvsAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrOverflow) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 59e0 fff8
void m68kSvsPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_dt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrOverflow) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 59e8 fff8
void m68kSvsDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrOverflow) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 59f0 fff8
void m68kSvsDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrOverflow) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 59f8 ffff
void m68kSvsAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluOrByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrOverflow) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 59f9 ffff
void m68kSvsAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluOrByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrOverflow) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5ac0 fff8
void m68kSplDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 384 sccr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrSign) ? 0 : 1;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccr2;
	    }
	    else
	    {
		goto roaw2;
	    }
	roaw2:
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	sccr2:
	    // 0cb sccr2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5ac8 fff8
void m68kDbplDsRel16Program()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 06c dbcc1
	    reg_t = (reg_sr & SrSign) ? 0 : 1;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto dbcc6;
	    }
	    else
	    {
		goto dbcc2;
	    }
	dbcc2:
	    // 046 dbcc2
	    reg_aob = reg_au;
	    reg_alub = reg_da[ry_index];
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    // 175 dbcc3
	    reg_t = (reg_isr & SrZero) ? 1 : 0;
	    reg_pc = reg_au;
	    reg_au = reg_at + 2;
	    aluAdd(reg_alub, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    if (reg_t)
	    {
		goto dbcc5;
	    }
	    else
	    {
		goto dbcc4;
	    }
	dbcc6:
	    // 0c6 dbcc6
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setTrace();
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dbcc4:
	    // 0c7 dbcc4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dbcc5:
	    // 007 dbcc5
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    setTrace();
	    goto dbcc4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5ad0 fff8
void m68kSplAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrSign) ? 0 : 1;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5ad8 fff8
void m68kSplAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrSign) ? 0 : 1;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5ae0 fff8
void m68kSplPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_dt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrSign) ? 0 : 1;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5ae8 fff8
void m68kSplDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrSign) ? 0 : 1;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5af0 fff8
void m68kSplDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrSign) ? 0 : 1;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5af8 ffff
void m68kSplAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluOrByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrSign) ? 0 : 1;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5af9 ffff
void m68kSplAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluOrByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrSign) ? 0 : 1;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5bc0 fff8
void m68kSmiDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 384 sccr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrSign) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccr2;
	    }
	    else
	    {
		goto roaw2;
	    }
	roaw2:
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	sccr2:
	    // 0cb sccr2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5bc8 fff8
void m68kDbmiDsRel16Program()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 06c dbcc1
	    reg_t = (reg_sr & SrSign) ? 1 : 0;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto dbcc6;
	    }
	    else
	    {
		goto dbcc2;
	    }
	dbcc2:
	    // 046 dbcc2
	    reg_aob = reg_au;
	    reg_alub = reg_da[ry_index];
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    // 175 dbcc3
	    reg_t = (reg_isr & SrZero) ? 1 : 0;
	    reg_pc = reg_au;
	    reg_au = reg_at + 2;
	    aluAdd(reg_alub, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    if (reg_t)
	    {
		goto dbcc5;
	    }
	    else
	    {
		goto dbcc4;
	    }
	dbcc6:
	    // 0c6 dbcc6
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setTrace();
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dbcc4:
	    // 0c7 dbcc4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dbcc5:
	    // 007 dbcc5
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    setTrace();
	    goto dbcc4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5bd0 fff8
void m68kSmiAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrSign) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5bd8 fff8
void m68kSmiAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrSign) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5be0 fff8
void m68kSmiPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_dt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrSign) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5be8 fff8
void m68kSmiDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrSign) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5bf0 fff8
void m68kSmiDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrSign) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5bf8 ffff
void m68kSmiAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluOrByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrSign) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5bf9 ffff
void m68kSmiAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluOrByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_sr & SrSign) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5cc0 fff8
void m68kSgeDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 384 sccr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (((reg_sr & (SrSign | SrOverflow)) == (SrSign | SrOverflow)) || ((reg_sr & (SrSign | SrOverflow)) == 0)) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccr2;
	    }
	    else
	    {
		goto roaw2;
	    }
	roaw2:
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	sccr2:
	    // 0cb sccr2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5cc8 fff8
void m68kDbgeDsRel16Program()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 06c dbcc1
	    reg_t = (((reg_sr & (SrSign | SrOverflow)) == (SrSign | SrOverflow)) || ((reg_sr & (SrSign | SrOverflow)) == 0)) ? 1 : 0;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto dbcc6;
	    }
	    else
	    {
		goto dbcc2;
	    }
	dbcc2:
	    // 046 dbcc2
	    reg_aob = reg_au;
	    reg_alub = reg_da[ry_index];
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    // 175 dbcc3
	    reg_t = (reg_isr & SrZero) ? 1 : 0;
	    reg_pc = reg_au;
	    reg_au = reg_at + 2;
	    aluAdd(reg_alub, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    if (reg_t)
	    {
		goto dbcc5;
	    }
	    else
	    {
		goto dbcc4;
	    }
	dbcc6:
	    // 0c6 dbcc6
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setTrace();
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dbcc4:
	    // 0c7 dbcc4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dbcc5:
	    // 007 dbcc5
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    setTrace();
	    goto dbcc4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5cd0 fff8
void m68kSgeAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (((reg_sr & (SrSign | SrOverflow)) == (SrSign | SrOverflow)) || ((reg_sr & (SrSign | SrOverflow)) == 0)) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5cd8 fff8
void m68kSgeAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (((reg_sr & (SrSign | SrOverflow)) == (SrSign | SrOverflow)) || ((reg_sr & (SrSign | SrOverflow)) == 0)) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5ce0 fff8
void m68kSgePaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_dt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (((reg_sr & (SrSign | SrOverflow)) == (SrSign | SrOverflow)) || ((reg_sr & (SrSign | SrOverflow)) == 0)) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5ce8 fff8
void m68kSgeDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (((reg_sr & (SrSign | SrOverflow)) == (SrSign | SrOverflow)) || ((reg_sr & (SrSign | SrOverflow)) == 0)) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5cf0 fff8
void m68kSgeDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (((reg_sr & (SrSign | SrOverflow)) == (SrSign | SrOverflow)) || ((reg_sr & (SrSign | SrOverflow)) == 0)) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5cf8 ffff
void m68kSgeAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluOrByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (((reg_sr & (SrSign | SrOverflow)) == (SrSign | SrOverflow)) || ((reg_sr & (SrSign | SrOverflow)) == 0)) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5cf9 ffff
void m68kSgeAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluOrByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (((reg_sr & (SrSign | SrOverflow)) == (SrSign | SrOverflow)) || ((reg_sr & (SrSign | SrOverflow)) == 0)) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5dc0 fff8
void m68kSltDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 384 sccr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (((reg_sr & (SrSign | SrOverflow)) == SrSign) || ((reg_sr & SrOverflow) == 0)) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccr2;
	    }
	    else
	    {
		goto roaw2;
	    }
	roaw2:
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	sccr2:
	    // 0cb sccr2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5dc8 fff8
void m68kDbltDsRel16Program()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 06c dbcc1
	    reg_t = (((reg_sr & (SrSign | SrOverflow)) == SrSign) || ((reg_sr & SrOverflow) == 0)) ? 1 : 0;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto dbcc6;
	    }
	    else
	    {
		goto dbcc2;
	    }
	dbcc2:
	    // 046 dbcc2
	    reg_aob = reg_au;
	    reg_alub = reg_da[ry_index];
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    // 175 dbcc3
	    reg_t = (reg_isr & SrZero) ? 1 : 0;
	    reg_pc = reg_au;
	    reg_au = reg_at + 2;
	    aluAdd(reg_alub, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    if (reg_t)
	    {
		goto dbcc5;
	    }
	    else
	    {
		goto dbcc4;
	    }
	dbcc6:
	    // 0c6 dbcc6
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setTrace();
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dbcc4:
	    // 0c7 dbcc4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dbcc5:
	    // 007 dbcc5
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    setTrace();
	    goto dbcc4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5dd0 fff8
void m68kSltAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (((reg_sr & (SrSign | SrOverflow)) == SrSign) || ((reg_sr & SrOverflow) == 0)) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5dd8 fff8
void m68kSltAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (((reg_sr & (SrSign | SrOverflow)) == SrSign) || ((reg_sr & SrOverflow) == 0)) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5de0 fff8
void m68kSltPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_dt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (((reg_sr & (SrSign | SrOverflow)) == SrSign) || ((reg_sr & SrOverflow) == 0)) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5de8 fff8
void m68kSltDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (((reg_sr & (SrSign | SrOverflow)) == SrSign) || ((reg_sr & SrOverflow) == 0)) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5df0 fff8
void m68kSltDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (((reg_sr & (SrSign | SrOverflow)) == SrSign) || ((reg_sr & SrOverflow) == 0)) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5df8 ffff
void m68kSltAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluOrByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (((reg_sr & (SrSign | SrOverflow)) == SrSign) || ((reg_sr & SrOverflow) == 0)) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5df9 ffff
void m68kSltAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluOrByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (((reg_sr & (SrSign | SrOverflow)) == SrSign) || ((reg_sr & SrOverflow) == 0)) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5ec0 fff8
void m68kSgtDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 384 sccr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (((reg_sr & (SrSign | SrOverflow | SrZero)) == (SrSign | SrOverflow)) || ((reg_sr & (SrSign | SrOverflow | SrZero)) == 0)) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccr2;
	    }
	    else
	    {
		goto roaw2;
	    }
	roaw2:
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	sccr2:
	    // 0cb sccr2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5ec8 fff8
void m68kDbgtDsRel16Program()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 06c dbcc1
	    reg_t = (((reg_sr & (SrSign | SrOverflow | SrZero)) == (SrSign | SrOverflow)) || ((reg_sr & (SrSign | SrOverflow | SrZero)) == 0)) ? 1 : 0;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto dbcc6;
	    }
	    else
	    {
		goto dbcc2;
	    }
	dbcc2:
	    // 046 dbcc2
	    reg_aob = reg_au;
	    reg_alub = reg_da[ry_index];
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    // 175 dbcc3
	    reg_t = (reg_isr & SrZero) ? 1 : 0;
	    reg_pc = reg_au;
	    reg_au = reg_at + 2;
	    aluAdd(reg_alub, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    if (reg_t)
	    {
		goto dbcc5;
	    }
	    else
	    {
		goto dbcc4;
	    }
	dbcc6:
	    // 0c6 dbcc6
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setTrace();
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dbcc4:
	    // 0c7 dbcc4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dbcc5:
	    // 007 dbcc5
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    setTrace();
	    goto dbcc4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5ed0 fff8
void m68kSgtAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (((reg_sr & (SrSign | SrOverflow | SrZero)) == (SrSign | SrOverflow)) || ((reg_sr & (SrSign | SrOverflow | SrZero)) == 0)) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5ed8 fff8
void m68kSgtAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (((reg_sr & (SrSign | SrOverflow | SrZero)) == (SrSign | SrOverflow)) || ((reg_sr & (SrSign | SrOverflow | SrZero)) == 0)) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5ee0 fff8
void m68kSgtPaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_dt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (((reg_sr & (SrSign | SrOverflow | SrZero)) == (SrSign | SrOverflow)) || ((reg_sr & (SrSign | SrOverflow | SrZero)) == 0)) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5ee8 fff8
void m68kSgtDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (((reg_sr & (SrSign | SrOverflow | SrZero)) == (SrSign | SrOverflow)) || ((reg_sr & (SrSign | SrOverflow | SrZero)) == 0)) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5ef0 fff8
void m68kSgtDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (((reg_sr & (SrSign | SrOverflow | SrZero)) == (SrSign | SrOverflow)) || ((reg_sr & (SrSign | SrOverflow | SrZero)) == 0)) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5ef8 ffff
void m68kSgtAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluOrByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (((reg_sr & (SrSign | SrOverflow | SrZero)) == (SrSign | SrOverflow)) || ((reg_sr & (SrSign | SrOverflow | SrZero)) == 0)) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5ef9 ffff
void m68kSgtAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluOrByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (((reg_sr & (SrSign | SrOverflow | SrZero)) == (SrSign | SrOverflow)) || ((reg_sr & (SrSign | SrOverflow | SrZero)) == 0)) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5fc0 fff8
void m68kSleDsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 384 sccr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (((reg_sr & SrZero) != 0) || ((reg_sr & (SrSign | SrOverflow)) == SrSign) || ((reg_sr & (SrSign | SrOverflow)) == SrOverflow)) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccr2;
	    }
	    else
	    {
		goto roaw2;
	    }
	roaw2:
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	sccr2:
	    // 0cb sccr2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5fc8 fff8
void m68kDbleDsRel16Program()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 06c dbcc1
	    reg_t = (((reg_sr & SrZero) != 0) || ((reg_sr & (SrSign | SrOverflow)) == SrSign) || ((reg_sr & (SrSign | SrOverflow)) == SrOverflow)) ? 1 : 0;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto dbcc6;
	    }
	    else
	    {
		goto dbcc2;
	    }
	dbcc2:
	    // 046 dbcc2
	    reg_aob = reg_au;
	    reg_alub = reg_da[ry_index];
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    // 175 dbcc3
	    reg_t = (reg_isr & SrZero) ? 1 : 0;
	    reg_pc = reg_au;
	    reg_au = reg_at + 2;
	    aluAdd(reg_alub, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    if (reg_t)
	    {
		goto dbcc5;
	    }
	    else
	    {
		goto dbcc4;
	    }
	dbcc6:
	    // 0c6 dbcc6
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    setTrace();
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dbcc4:
	    // 0c7 dbcc4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dbcc5:
	    // 007 dbcc5
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    setTrace();
	    goto dbcc4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5fd0 fff8
void m68kSleAisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (((reg_sr & SrZero) != 0) || ((reg_sr & (SrSign | SrOverflow)) == SrSign) || ((reg_sr & (SrSign | SrOverflow)) == SrOverflow)) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5fd8 fff8
void m68kSleAipsProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_dt;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_dt, reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (((reg_sr & SrZero) != 0) || ((reg_sr & (SrSign | SrOverflow)) == SrSign) || ((reg_sr & (SrSign | SrOverflow)) == SrOverflow)) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5fe0 fff8
void m68kSlePaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_dt, reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (((reg_sr & SrZero) != 0) || ((reg_sr & (SrSign | SrOverflow)) == SrSign) || ((reg_sr & (SrSign | SrOverflow)) == SrOverflow)) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5fe8 fff8
void m68kSleDasProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (((reg_sr & SrZero) != 0) || ((reg_sr & (SrSign | SrOverflow)) == SrSign) || ((reg_sr & (SrSign | SrOverflow)) == SrOverflow)) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5ff0 fff8
void m68kSleDaisProgram()
{
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_dt;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (((reg_sr & SrZero) != 0) || ((reg_sr & (SrSign | SrOverflow)) == SrSign) || ((reg_sr & (SrSign | SrOverflow)) == SrOverflow)) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5ff8 ffff
void m68kSleAdr16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluOrByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (((reg_sr & SrZero) != 0) || ((reg_sr & (SrSign | SrOverflow)) == SrSign) || ((reg_sr & (SrSign | SrOverflow)) == SrOverflow)) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 5ff9 ffff
void m68kSleAdr32Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_dt;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluOrByte(reg_dt, reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 380 sccb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (((reg_sr & SrZero) != 0) || ((reg_sr & (SrSign | SrOverflow)) == SrSign) || ((reg_sr & (SrSign | SrOverflow)) == SrOverflow)) ? 1 : 0;
	    reg_pc = reg_au;
	    aluAndByte(0x0000, 0x0000);
	    if (reg_t)
	    {
		goto sccb2;
	    }
	    else
	    {
		goto sccb3;
	    }
	sccb3:
	    // 04f sccb3
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto morw2;
	sccb2:
	    // 0cf sccb2
	    reg_au = reg_at;
	    aluOrByte(reg_aluo, 0xFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto morw2;
	morw2:
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 6000 ffff
void m68kBraRel16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 068 bbcw1
	    reg_t = 1;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto bbci3;
	    }
	    else
	    {
		goto bbcw3;
	    }
	bbcw3:
	    // 085 bbcw3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setTrace();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	bbci3:
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	b:
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 6000 ff00
void m68kBraRel8Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 308 bbci1
	    reg_t = 1;
	    reg_au = reg_pc + ext32(reg_ftu);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto bbci3;
	    }
	    else
	    {
		goto bbci2;
	    }
	bbci2:
	    // 045 bbci2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setTrace();
	    goto b;
	bbci3:
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	b:
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 6100 ffff
void m68kBsrRel16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0a9 bsrw1
	    reg_at = reg_au;
	    aluAnd(reg_au, 0xFFFF);
	    reg_au = reg_da[reg_sp] - 4;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 10e bsrw2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_at);
	    reg_da[reg_sp] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0aa bsrw3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 6100 ff00
void m68kBsrRel8Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 089 bsri1
	    reg_at = reg_pc;
	    reg_au = reg_da[reg_sp] - 4;
	    aluAnd(reg_pc, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 102 bsri2
	    reg_aob = reg_au;
	    reg_dbout = high16(reg_at);
	    reg_da[reg_sp] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0a8 bsri3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = ext32(reg_ftu) + reg_pc;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 6200 ffff
void m68kBhiRel16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 068 bbcw1
	    reg_t = ((reg_sr & (SrCarry | SrZero)) == 0) ? 1 : 0;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto bbci3;
	    }
	    else
	    {
		goto bbcw3;
	    }
	bbcw3:
	    // 085 bbcw3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setTrace();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	bbci3:
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	b:
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 6200 ff00
void m68kBhiRel8Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 308 bbci1
	    reg_t = ((reg_sr & (SrCarry | SrZero)) == 0) ? 1 : 0;
	    reg_au = reg_pc + ext32(reg_ftu);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto bbci3;
	    }
	    else
	    {
		goto bbci2;
	    }
	bbci2:
	    // 045 bbci2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setTrace();
	    goto b;
	bbci3:
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	b:
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 6300 ffff
void m68kBlsRel16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 068 bbcw1
	    reg_t = ((reg_sr & (SrCarry | SrZero)) != 0) ? 1 : 0;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto bbci3;
	    }
	    else
	    {
		goto bbcw3;
	    }
	bbcw3:
	    // 085 bbcw3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setTrace();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	bbci3:
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	b:
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 6300 ff00
void m68kBlsRel8Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 308 bbci1
	    reg_t = ((reg_sr & (SrCarry | SrZero)) != 0) ? 1 : 0;
	    reg_au = reg_pc + ext32(reg_ftu);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto bbci3;
	    }
	    else
	    {
		goto bbci2;
	    }
	bbci2:
	    // 045 bbci2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setTrace();
	    goto b;
	bbci3:
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	b:
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 6400 ffff
void m68kBccRel16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 068 bbcw1
	    reg_t = (reg_sr & SrCarry) ? 0 : 1;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto bbci3;
	    }
	    else
	    {
		goto bbcw3;
	    }
	bbcw3:
	    // 085 bbcw3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setTrace();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	bbci3:
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	b:
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 6400 ff00
void m68kBccRel8Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 308 bbci1
	    reg_t = (reg_sr & SrCarry) ? 0 : 1;
	    reg_au = reg_pc + ext32(reg_ftu);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto bbci3;
	    }
	    else
	    {
		goto bbci2;
	    }
	bbci2:
	    // 045 bbci2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setTrace();
	    goto b;
	bbci3:
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	b:
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 6500 ffff
void m68kBcsRel16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 068 bbcw1
	    reg_t = (reg_sr & SrCarry) ? 1 : 0;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto bbci3;
	    }
	    else
	    {
		goto bbcw3;
	    }
	bbcw3:
	    // 085 bbcw3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setTrace();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	bbci3:
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	b:
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 6500 ff00
void m68kBcsRel8Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 308 bbci1
	    reg_t = (reg_sr & SrCarry) ? 1 : 0;
	    reg_au = reg_pc + ext32(reg_ftu);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto bbci3;
	    }
	    else
	    {
		goto bbci2;
	    }
	bbci2:
	    // 045 bbci2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setTrace();
	    goto b;
	bbci3:
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	b:
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 6600 ffff
void m68kBneRel16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 068 bbcw1
	    reg_t = (reg_sr & SrZero) ? 0 : 1;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto bbci3;
	    }
	    else
	    {
		goto bbcw3;
	    }
	bbcw3:
	    // 085 bbcw3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setTrace();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	bbci3:
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	b:
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 6600 ff00
void m68kBneRel8Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 308 bbci1
	    reg_t = (reg_sr & SrZero) ? 0 : 1;
	    reg_au = reg_pc + ext32(reg_ftu);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto bbci3;
	    }
	    else
	    {
		goto bbci2;
	    }
	bbci2:
	    // 045 bbci2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setTrace();
	    goto b;
	bbci3:
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	b:
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 6700 ffff
void m68kBeqRel16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 068 bbcw1
	    reg_t = (reg_sr & SrZero) ? 1 : 0;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto bbci3;
	    }
	    else
	    {
		goto bbcw3;
	    }
	bbcw3:
	    // 085 bbcw3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setTrace();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	bbci3:
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	b:
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 6700 ff00
void m68kBeqRel8Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 308 bbci1
	    reg_t = (reg_sr & SrZero) ? 1 : 0;
	    reg_au = reg_pc + ext32(reg_ftu);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto bbci3;
	    }
	    else
	    {
		goto bbci2;
	    }
	bbci2:
	    // 045 bbci2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setTrace();
	    goto b;
	bbci3:
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	b:
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 6800 ffff
void m68kBvcRel16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 068 bbcw1
	    reg_t = (reg_sr & SrOverflow) ? 0 : 1;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto bbci3;
	    }
	    else
	    {
		goto bbcw3;
	    }
	bbcw3:
	    // 085 bbcw3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setTrace();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	bbci3:
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	b:
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 6800 ff00
void m68kBvcRel8Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 308 bbci1
	    reg_t = (reg_sr & SrOverflow) ? 0 : 1;
	    reg_au = reg_pc + ext32(reg_ftu);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto bbci3;
	    }
	    else
	    {
		goto bbci2;
	    }
	bbci2:
	    // 045 bbci2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setTrace();
	    goto b;
	bbci3:
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	b:
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 6900 ffff
void m68kBvsRel16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 068 bbcw1
	    reg_t = (reg_sr & SrOverflow) ? 1 : 0;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto bbci3;
	    }
	    else
	    {
		goto bbcw3;
	    }
	bbcw3:
	    // 085 bbcw3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setTrace();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	bbci3:
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	b:
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 6900 ff00
void m68kBvsRel8Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 308 bbci1
	    reg_t = (reg_sr & SrOverflow) ? 1 : 0;
	    reg_au = reg_pc + ext32(reg_ftu);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto bbci3;
	    }
	    else
	    {
		goto bbci2;
	    }
	bbci2:
	    // 045 bbci2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setTrace();
	    goto b;
	bbci3:
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	b:
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 6a00 ffff
void m68kBplRel16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 068 bbcw1
	    reg_t = (reg_sr & SrSign) ? 0 : 1;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto bbci3;
	    }
	    else
	    {
		goto bbcw3;
	    }
	bbcw3:
	    // 085 bbcw3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setTrace();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	bbci3:
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	b:
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 6a00 ff00
void m68kBplRel8Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 308 bbci1
	    reg_t = (reg_sr & SrSign) ? 0 : 1;
	    reg_au = reg_pc + ext32(reg_ftu);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto bbci3;
	    }
	    else
	    {
		goto bbci2;
	    }
	bbci2:
	    // 045 bbci2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setTrace();
	    goto b;
	bbci3:
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	b:
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 6b00 ffff
void m68kBmiRel16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 068 bbcw1
	    reg_t = (reg_sr & SrSign) ? 1 : 0;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto bbci3;
	    }
	    else
	    {
		goto bbcw3;
	    }
	bbcw3:
	    // 085 bbcw3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setTrace();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	bbci3:
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	b:
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 6b00 ff00
void m68kBmiRel8Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 308 bbci1
	    reg_t = (reg_sr & SrSign) ? 1 : 0;
	    reg_au = reg_pc + ext32(reg_ftu);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto bbci3;
	    }
	    else
	    {
		goto bbci2;
	    }
	bbci2:
	    // 045 bbci2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setTrace();
	    goto b;
	bbci3:
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	b:
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 6c00 ffff
void m68kBgeRel16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 068 bbcw1
	    reg_t = (((reg_sr & (SrSign | SrOverflow)) == (SrSign | SrOverflow)) || ((reg_sr & (SrSign | SrOverflow)) == 0)) ? 1 : 0;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto bbci3;
	    }
	    else
	    {
		goto bbcw3;
	    }
	bbcw3:
	    // 085 bbcw3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setTrace();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	bbci3:
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	b:
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 6c00 ff00
void m68kBgeRel8Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 308 bbci1
	    reg_t = (((reg_sr & (SrSign | SrOverflow)) == (SrSign | SrOverflow)) || ((reg_sr & (SrSign | SrOverflow)) == 0)) ? 1 : 0;
	    reg_au = reg_pc + ext32(reg_ftu);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto bbci3;
	    }
	    else
	    {
		goto bbci2;
	    }
	bbci2:
	    // 045 bbci2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setTrace();
	    goto b;
	bbci3:
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	b:
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 6d00 ffff
void m68kBltRel16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 068 bbcw1
	    reg_t = (((reg_sr & (SrSign | SrOverflow)) == SrSign) || ((reg_sr & SrOverflow) == 0)) ? 1 : 0;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto bbci3;
	    }
	    else
	    {
		goto bbcw3;
	    }
	bbcw3:
	    // 085 bbcw3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setTrace();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	bbci3:
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	b:
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 6d00 ff00
void m68kBltRel8Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 308 bbci1
	    reg_t = (((reg_sr & (SrSign | SrOverflow)) == SrSign) || ((reg_sr & SrOverflow) == 0)) ? 1 : 0;
	    reg_au = reg_pc + ext32(reg_ftu);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto bbci3;
	    }
	    else
	    {
		goto bbci2;
	    }
	bbci2:
	    // 045 bbci2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setTrace();
	    goto b;
	bbci3:
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	b:
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 6e00 ffff
void m68kBgtRel16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 068 bbcw1
	    reg_t = (((reg_sr & (SrSign | SrOverflow | SrZero)) == (SrSign | SrOverflow)) || ((reg_sr & (SrSign | SrOverflow | SrZero)) == 0)) ? 1 : 0;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto bbci3;
	    }
	    else
	    {
		goto bbcw3;
	    }
	bbcw3:
	    // 085 bbcw3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setTrace();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	bbci3:
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	b:
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 6e00 ff00
void m68kBgtRel8Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 308 bbci1
	    reg_t = (((reg_sr & (SrSign | SrOverflow | SrZero)) == (SrSign | SrOverflow)) || ((reg_sr & (SrSign | SrOverflow | SrZero)) == 0)) ? 1 : 0;
	    reg_au = reg_pc + ext32(reg_ftu);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto bbci3;
	    }
	    else
	    {
		goto bbci2;
	    }
	bbci2:
	    // 045 bbci2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setTrace();
	    goto b;
	bbci3:
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	b:
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 6f00 ffff
void m68kBleRel16Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 068 bbcw1
	    reg_t = (((reg_sr & SrZero) != 0) || ((reg_sr & (SrSign | SrOverflow)) == SrSign) || ((reg_sr & (SrSign | SrOverflow)) == SrOverflow)) ? 1 : 0;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto bbci3;
	    }
	    else
	    {
		goto bbcw3;
	    }
	bbcw3:
	    // 085 bbcw3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setTrace();
	    // 1e1 malw3
	    reg_aob = reg_au;
	    reg_movemr = reg_dbin;
	    reg_pc = reg_au;
	    reg_ftu = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	bbci3:
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	b:
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 6f00 ff00
void m68kBleRel8Program()
{
    switch (inst_cycle)
    {
	case 0:
	{
	    // 308 bbci1
	    reg_t = (((reg_sr & SrZero) != 0) || ((reg_sr & (SrSign | SrOverflow)) == SrSign) || ((reg_sr & (SrSign | SrOverflow)) == SrOverflow)) ? 1 : 0;
	    reg_au = reg_pc + ext32(reg_ftu);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (reg_t)
	    {
		goto bbci3;
	    }
	    else
	    {
		goto bbci2;
	    }
	bbci2:
	    // 045 bbci2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    setTrace();
	    goto b;
	bbci3:
	    // 0c5 bbci3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    goto b;
	b:
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 7000 f100
void m68kMoveqImm8oDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 23b rlql1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_da[rx_index] = ext32(reg_ftu);
	    reg_au = reg_au + 2;
	    aluAnd(reg_ftu, 0xFFFF);
	    updateNZVC();
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 8000 f1f8
void m68kOrByteDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluOrByte(reg_da[ry_index], reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 8010 f1f8
void m68kOrByteAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluOrByte(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 8018 f1f8
void m68kOrByteAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluOrByte(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 8020 f1f8
void m68kOrBytePaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_da[rx_index], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluOrByte(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 8028 f1f8
void m68kOrByteDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluOrByte(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 8030 f1f8
void m68kOrByteDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluOrByte(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 8038 f1ff
void m68kOrByteAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluOrByte(reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluOrByte(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 8039 f1ff
void m68kOrByteAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluOrByte(reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluOrByte(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 803a f1ff
void m68kOrByteDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluOrByte(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 803b f1ff
void m68kOrByteDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluOrByte(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 803c f1ff
void m68kOrByteImm8DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    aluOrByte(reg_dt, reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 8040 f1f8
void m68kOrWordDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluOr(reg_da[ry_index], reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 8050 f1f8
void m68kOrWordAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluOr(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 8058 f1f8
void m68kOrWordAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluOr(reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluOr(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 8060 f1f8
void m68kOrWordPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    aluOr(reg_da[rx_index], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluOr(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 8068 f1f8
void m68kOrWordDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluOr(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 8070 f1f8
void m68kOrWordDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluOr(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 8078 f1ff
void m68kOrWordAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluOr(reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluOr(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 8079 f1ff
void m68kOrWordAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluOr(reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluOr(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 807a f1ff
void m68kOrWordDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluOr(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 807b f1ff
void m68kOrWordDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluOr(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 807c f1ff
void m68kOrWordImm16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    aluOr(reg_dt, reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 8080 f1f8
void m68kOrLongDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluOr(reg_da[ry_index], reg_da[rx_index]);
	    updateNZVC();
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    aluOr(high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    updateNZVCU();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 8090 f1f8
void m68kOrLongAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluOr(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluOr(reg_alub, high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 8098 f1f8
void m68kOrLongAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluOr(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluOr(reg_alub, high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 80a0 f1f8
void m68kOrLongPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluOr(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluOr(reg_alub, high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 80a8 f1f8
void m68kOrLongDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluOr(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluOr(reg_alub, high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 80b0 f1f8
void m68kOrLongDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluOr(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluOr(reg_alub, high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 80b8 f1ff
void m68kOrLongAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluOr(reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluOr(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluOr(reg_alub, high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 80b9 f1ff
void m68kOrLongAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 00d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluOr(reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluOr(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluOr(reg_alub, high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 80ba f1ff
void m68kOrLongDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluOr(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluOr(reg_alub, high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 80bb f1ff
void m68kOrLongDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluOr(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluOr(reg_alub, high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 80bc f1ff
void m68kOrLongImm32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    aluOr(reg_dt, reg_da[rx_index]);
	    updateNZVC();
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    aluOr(high16(reg_dt), high16(reg_da[rx_index]));
	    updateNZVCU();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 80c0 f1f8
void m68kDivuWordDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0a6 dvur1
	    reg_alub = reg_da[ry_index];
	    reg_alue = reg_da[rx_index];
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_da[ry_index]);
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 213 dvum2
	    reg_t = (reg_isr & SrZero) ? 1 : 0;
	    aluSub(reg_alub, high16(reg_da[rx_index]));
	    updateNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto dvur2;
	    }
	    else
	    {
		goto dvum3;
	    }
	dvum3:
	    // 023 dvum3
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    setReg16Low(reg_at, high16(reg_da[rx_index]));
	    reg_au = merge32(0, reg_ftu) + 1;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (reg_t)
	    {
		goto dvum5;
	    }
	    else
	    {
		goto dvum4;
	    }
	dvur2:
	    // 0e3 dvur2
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 24;
	}
	break;
	case 24:
	{
	    inst_cycle = 25;
	}
	break;
	case 25:
	{
	    // 217 dvur3
	    initST();
	    reg_pc = reg_au;
	    aluAnd(reg_au, 0xFFFF);
	    reg_au = reg_da[16] - 2;
	    inst_cycle = 26;
	}
	break;
	case 26:
	{
	    inst_cycle = 27;
	}
	break;
	case 27:
	{
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 28;
	}
	break;
	case 28:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x05);
	    reg_da[16] = reg_au;
	    reg_ftu = 0x0014;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 29;
	}
	break;
	case 29:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 30;
	}
	break;
	case 30:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 31;
	}
	break;
	case 31:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 32;
	}
	break;
	case 32:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 33;
	}
	break;
	case 33:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 34;
	}
	break;
	case 34:
	{
	    inst_cycle = 35;
	}
	break;
	case 35:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 36;
	}
	break;
	case 36:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvum4:
	    // 2d1 dvum4
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 0e6 dvuma
	    reg_ird = reg_ir;
	    setIntState();
	    aluOver(0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvum5:
	    // 291 dvum5
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_au = reg_au - 1;
	    aluSla0(reg_aluo);
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (reg_t)
	    {
		goto dvum7;
	    }
	    else
	    {
		goto dvum8;
	    }
	dvum8:
	    // 252 dvum8
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (reg_t)
	    {
		goto dvumc;
	    }
	    else
	    {
		goto dvumb;
	    }
	dvum7:
	    // 2d2 dvum7
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 15;
	}
	break;
	case 15:
	{
	    inst_cycle = 16;
	}
	break;
	case 16:
	{
	    if (reg_t)
	    {
		goto dvum9;
	    }
	    else
	    {
		goto dvum6;
	    }
	dvumb:
	    // 3e9 dvumb
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    if (reg_t)
	    {
		goto dvume;
	    }
	    else
	    {
		goto dvum6;
	    }
	dvumc:
	    // 369 dvumc
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    setReg16High(reg_da[rx_index], reg_aluo);
	    aluAnd(reg_aluo, 0x0000);
	    inst_cycle = 22;
	}
	break;
	case 22:
	{
	    inst_cycle = 23;
	}
	break;
	case 23:
	{
	    if (reg_t)
	    {
		goto dvumf;
	    }
	    else
	    {
		goto dvumd;
	    }
	dvum6:
	    // 2d0 dvum6
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_au = reg_au - 1;
	    aluSla1(reg_aluo);
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    inst_cycle = 14;
	}
	break;
	case 14:
	{
	    if (reg_t)
	    {
		goto dvum7;
	    }
	    else
	    {
		goto dvum8;
	    }
	dvum9:
	    // 250 dvum9
	    setReg16High(reg_da[rx_index], reg_aluo);
	    aluAnd(reg_aluo, 0x0000);
	    inst_cycle = 17;
	}
	break;
	case 17:
	{
	    inst_cycle = 18;
	}
	break;
	case 18:
	{
	    goto dvumd;
	dvume:
	    // 290 dvume
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 20;
	}
	break;
	case 20:
	{
	    inst_cycle = 21;
	}
	break;
	case 21:
	{
	    goto dvum5;
	dvumd:
	    // 0c0 dvumd
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_aluo;
	    reg_au = reg_pc + 2;
	    aluSla1(reg_aluo);
	    goto dvum0;
	dvumf:
	    // 080 dvumf
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_aluo;
	    setReg16High(reg_da[rx_index], reg_at);
	    reg_au = reg_pc + 2;
	    aluSla0(reg_aluo);
	    goto dvum0;
	dvum0:
	    // 212 dvum0
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_alue);
	    aluSub(reg_alub, reg_alue);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 19;
	}
	break;
	case 19:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 80d0 f1f8
void m68kDivuWordAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 0a4 dvum1
	    reg_alub = reg_dbin;
	    reg_alue = reg_da[rx_index];
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 213 dvum2
	    reg_t = (reg_isr & SrZero) ? 1 : 0;
	    aluSub(reg_alub, high16(reg_da[rx_index]));
	    updateNZVC();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (reg_t)
	    {
		goto dvur2;
	    }
	    else
	    {
		goto dvum3;
	    }
	dvum3:
	    // 023 dvum3
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    setReg16Low(reg_at, high16(reg_da[rx_index]));
	    reg_au = merge32(0, reg_ftu) + 1;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (reg_t)
	    {
		goto dvum5;
	    }
	    else
	    {
		goto dvum4;
	    }
	dvur2:
	    // 0e3 dvur2
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 26;
	}
	break;
	case 26:
	{
	    inst_cycle = 27;
	}
	break;
	case 27:
	{
	    // 217 dvur3
	    initST();
	    reg_pc = reg_au;
	    aluAnd(reg_au, 0xFFFF);
	    reg_au = reg_da[16] - 2;
	    inst_cycle = 28;
	}
	break;
	case 28:
	{
	    inst_cycle = 29;
	}
	break;
	case 29:
	{
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 30;
	}
	break;
	case 30:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x05);
	    reg_da[16] = reg_au;
	    reg_ftu = 0x0014;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 31;
	}
	break;
	case 31:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 32;
	}
	break;
	case 32:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 33;
	}
	break;
	case 33:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 34;
	}
	break;
	case 34:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 35;
	}
	break;
	case 35:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 36;
	}
	break;
	case 36:
	{
	    inst_cycle = 37;
	}
	break;
	case 37:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 38;
	}
	break;
	case 38:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvum4:
	    // 2d1 dvum4
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 0e6 dvuma
	    reg_ird = reg_ir;
	    setIntState();
	    aluOver(0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvum5:
	    // 291 dvum5
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_au = reg_au - 1;
	    aluSla0(reg_aluo);
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (reg_t)
	    {
		goto dvum7;
	    }
	    else
	    {
		goto dvum8;
	    }
	dvum8:
	    // 252 dvum8
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    if (reg_t)
	    {
		goto dvumc;
	    }
	    else
	    {
		goto dvumb;
	    }
	dvum7:
	    // 2d2 dvum7
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 17;
	}
	break;
	case 17:
	{
	    inst_cycle = 18;
	}
	break;
	case 18:
	{
	    if (reg_t)
	    {
		goto dvum9;
	    }
	    else
	    {
		goto dvum6;
	    }
	dvumb:
	    // 3e9 dvumb
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    inst_cycle = 14;
	}
	break;
	case 14:
	{
	    if (reg_t)
	    {
		goto dvume;
	    }
	    else
	    {
		goto dvum6;
	    }
	dvumc:
	    // 369 dvumc
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    setReg16High(reg_da[rx_index], reg_aluo);
	    aluAnd(reg_aluo, 0x0000);
	    inst_cycle = 24;
	}
	break;
	case 24:
	{
	    inst_cycle = 25;
	}
	break;
	case 25:
	{
	    if (reg_t)
	    {
		goto dvumf;
	    }
	    else
	    {
		goto dvumd;
	    }
	dvum6:
	    // 2d0 dvum6
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_au = reg_au - 1;
	    aluSla1(reg_aluo);
	    inst_cycle = 15;
	}
	break;
	case 15:
	{
	    inst_cycle = 16;
	}
	break;
	case 16:
	{
	    if (reg_t)
	    {
		goto dvum7;
	    }
	    else
	    {
		goto dvum8;
	    }
	dvum9:
	    // 250 dvum9
	    setReg16High(reg_da[rx_index], reg_aluo);
	    aluAnd(reg_aluo, 0x0000);
	    inst_cycle = 19;
	}
	break;
	case 19:
	{
	    inst_cycle = 20;
	}
	break;
	case 20:
	{
	    goto dvumd;
	dvume:
	    // 290 dvume
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 22;
	}
	break;
	case 22:
	{
	    inst_cycle = 23;
	}
	break;
	case 23:
	{
	    goto dvum5;
	dvumd:
	    // 0c0 dvumd
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_aluo;
	    reg_au = reg_pc + 2;
	    aluSla1(reg_aluo);
	    goto dvum0;
	dvumf:
	    // 080 dvumf
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_aluo;
	    setReg16High(reg_da[rx_index], reg_at);
	    reg_au = reg_pc + 2;
	    aluSla0(reg_aluo);
	    goto dvum0;
	dvum0:
	    // 212 dvum0
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_alue);
	    aluSub(reg_alub, reg_alue);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 21;
	}
	break;
	case 21:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 80d8 f1f8
void m68kDivuWordAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 0a4 dvum1
	    reg_alub = reg_dbin;
	    reg_alue = reg_da[rx_index];
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 213 dvum2
	    reg_t = (reg_isr & SrZero) ? 1 : 0;
	    aluSub(reg_alub, high16(reg_da[rx_index]));
	    updateNZVC();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (reg_t)
	    {
		goto dvur2;
	    }
	    else
	    {
		goto dvum3;
	    }
	dvum3:
	    // 023 dvum3
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    setReg16Low(reg_at, high16(reg_da[rx_index]));
	    reg_au = merge32(0, reg_ftu) + 1;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (reg_t)
	    {
		goto dvum5;
	    }
	    else
	    {
		goto dvum4;
	    }
	dvur2:
	    // 0e3 dvur2
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 26;
	}
	break;
	case 26:
	{
	    inst_cycle = 27;
	}
	break;
	case 27:
	{
	    // 217 dvur3
	    initST();
	    reg_pc = reg_au;
	    aluAnd(reg_au, 0xFFFF);
	    reg_au = reg_da[16] - 2;
	    inst_cycle = 28;
	}
	break;
	case 28:
	{
	    inst_cycle = 29;
	}
	break;
	case 29:
	{
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 30;
	}
	break;
	case 30:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x05);
	    reg_da[16] = reg_au;
	    reg_ftu = 0x0014;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 31;
	}
	break;
	case 31:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 32;
	}
	break;
	case 32:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 33;
	}
	break;
	case 33:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 34;
	}
	break;
	case 34:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 35;
	}
	break;
	case 35:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 36;
	}
	break;
	case 36:
	{
	    inst_cycle = 37;
	}
	break;
	case 37:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 38;
	}
	break;
	case 38:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvum4:
	    // 2d1 dvum4
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 0e6 dvuma
	    reg_ird = reg_ir;
	    setIntState();
	    aluOver(0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvum5:
	    // 291 dvum5
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_au = reg_au - 1;
	    aluSla0(reg_aluo);
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (reg_t)
	    {
		goto dvum7;
	    }
	    else
	    {
		goto dvum8;
	    }
	dvum8:
	    // 252 dvum8
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    if (reg_t)
	    {
		goto dvumc;
	    }
	    else
	    {
		goto dvumb;
	    }
	dvum7:
	    // 2d2 dvum7
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 17;
	}
	break;
	case 17:
	{
	    inst_cycle = 18;
	}
	break;
	case 18:
	{
	    if (reg_t)
	    {
		goto dvum9;
	    }
	    else
	    {
		goto dvum6;
	    }
	dvumb:
	    // 3e9 dvumb
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    inst_cycle = 14;
	}
	break;
	case 14:
	{
	    if (reg_t)
	    {
		goto dvume;
	    }
	    else
	    {
		goto dvum6;
	    }
	dvumc:
	    // 369 dvumc
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    setReg16High(reg_da[rx_index], reg_aluo);
	    aluAnd(reg_aluo, 0x0000);
	    inst_cycle = 24;
	}
	break;
	case 24:
	{
	    inst_cycle = 25;
	}
	break;
	case 25:
	{
	    if (reg_t)
	    {
		goto dvumf;
	    }
	    else
	    {
		goto dvumd;
	    }
	dvum6:
	    // 2d0 dvum6
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_au = reg_au - 1;
	    aluSla1(reg_aluo);
	    inst_cycle = 15;
	}
	break;
	case 15:
	{
	    inst_cycle = 16;
	}
	break;
	case 16:
	{
	    if (reg_t)
	    {
		goto dvum7;
	    }
	    else
	    {
		goto dvum8;
	    }
	dvum9:
	    // 250 dvum9
	    setReg16High(reg_da[rx_index], reg_aluo);
	    aluAnd(reg_aluo, 0x0000);
	    inst_cycle = 19;
	}
	break;
	case 19:
	{
	    inst_cycle = 20;
	}
	break;
	case 20:
	{
	    goto dvumd;
	dvume:
	    // 290 dvume
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 22;
	}
	break;
	case 22:
	{
	    inst_cycle = 23;
	}
	break;
	case 23:
	{
	    goto dvum5;
	dvumd:
	    // 0c0 dvumd
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_aluo;
	    reg_au = reg_pc + 2;
	    aluSla1(reg_aluo);
	    goto dvum0;
	dvumf:
	    // 080 dvumf
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_aluo;
	    setReg16High(reg_da[rx_index], reg_at);
	    reg_au = reg_pc + 2;
	    aluSla0(reg_aluo);
	    goto dvum0;
	dvum0:
	    // 212 dvum0
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_alue);
	    aluSub(reg_alub, reg_alue);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 21;
	}
	break;
	case 21:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 80e0 f1f8
void m68kDivuWordPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 0a4 dvum1
	    reg_alub = reg_dbin;
	    reg_alue = reg_da[rx_index];
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 213 dvum2
	    reg_t = (reg_isr & SrZero) ? 1 : 0;
	    aluSub(reg_alub, high16(reg_da[rx_index]));
	    updateNZVC();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (reg_t)
	    {
		goto dvur2;
	    }
	    else
	    {
		goto dvum3;
	    }
	dvum3:
	    // 023 dvum3
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    setReg16Low(reg_at, high16(reg_da[rx_index]));
	    reg_au = merge32(0, reg_ftu) + 1;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (reg_t)
	    {
		goto dvum5;
	    }
	    else
	    {
		goto dvum4;
	    }
	dvur2:
	    // 0e3 dvur2
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 27;
	}
	break;
	case 27:
	{
	    inst_cycle = 28;
	}
	break;
	case 28:
	{
	    // 217 dvur3
	    initST();
	    reg_pc = reg_au;
	    aluAnd(reg_au, 0xFFFF);
	    reg_au = reg_da[16] - 2;
	    inst_cycle = 29;
	}
	break;
	case 29:
	{
	    inst_cycle = 30;
	}
	break;
	case 30:
	{
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 31;
	}
	break;
	case 31:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x05);
	    reg_da[16] = reg_au;
	    reg_ftu = 0x0014;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 32;
	}
	break;
	case 32:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 33;
	}
	break;
	case 33:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 34;
	}
	break;
	case 34:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 35;
	}
	break;
	case 35:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 36;
	}
	break;
	case 36:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 37;
	}
	break;
	case 37:
	{
	    inst_cycle = 38;
	}
	break;
	case 38:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 39;
	}
	break;
	case 39:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvum4:
	    // 2d1 dvum4
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 0e6 dvuma
	    reg_ird = reg_ir;
	    setIntState();
	    aluOver(0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvum5:
	    // 291 dvum5
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_au = reg_au - 1;
	    aluSla0(reg_aluo);
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    if (reg_t)
	    {
		goto dvum7;
	    }
	    else
	    {
		goto dvum8;
	    }
	dvum8:
	    // 252 dvum8
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    if (reg_t)
	    {
		goto dvumc;
	    }
	    else
	    {
		goto dvumb;
	    }
	dvum7:
	    // 2d2 dvum7
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 18;
	}
	break;
	case 18:
	{
	    inst_cycle = 19;
	}
	break;
	case 19:
	{
	    if (reg_t)
	    {
		goto dvum9;
	    }
	    else
	    {
		goto dvum6;
	    }
	dvumb:
	    // 3e9 dvumb
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    inst_cycle = 14;
	}
	break;
	case 14:
	{
	    inst_cycle = 15;
	}
	break;
	case 15:
	{
	    if (reg_t)
	    {
		goto dvume;
	    }
	    else
	    {
		goto dvum6;
	    }
	dvumc:
	    // 369 dvumc
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    setReg16High(reg_da[rx_index], reg_aluo);
	    aluAnd(reg_aluo, 0x0000);
	    inst_cycle = 25;
	}
	break;
	case 25:
	{
	    inst_cycle = 26;
	}
	break;
	case 26:
	{
	    if (reg_t)
	    {
		goto dvumf;
	    }
	    else
	    {
		goto dvumd;
	    }
	dvum6:
	    // 2d0 dvum6
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_au = reg_au - 1;
	    aluSla1(reg_aluo);
	    inst_cycle = 16;
	}
	break;
	case 16:
	{
	    inst_cycle = 17;
	}
	break;
	case 17:
	{
	    if (reg_t)
	    {
		goto dvum7;
	    }
	    else
	    {
		goto dvum8;
	    }
	dvum9:
	    // 250 dvum9
	    setReg16High(reg_da[rx_index], reg_aluo);
	    aluAnd(reg_aluo, 0x0000);
	    inst_cycle = 20;
	}
	break;
	case 20:
	{
	    inst_cycle = 21;
	}
	break;
	case 21:
	{
	    goto dvumd;
	dvume:
	    // 290 dvume
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 23;
	}
	break;
	case 23:
	{
	    inst_cycle = 24;
	}
	break;
	case 24:
	{
	    goto dvum5;
	dvumd:
	    // 0c0 dvumd
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_aluo;
	    reg_au = reg_pc + 2;
	    aluSla1(reg_aluo);
	    goto dvum0;
	dvumf:
	    // 080 dvumf
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_aluo;
	    setReg16High(reg_da[rx_index], reg_at);
	    reg_au = reg_pc + 2;
	    aluSla0(reg_aluo);
	    goto dvum0;
	dvum0:
	    // 212 dvum0
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_alue);
	    aluSub(reg_alub, reg_alue);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 22;
	}
	break;
	case 22:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 80e8 f1f8
void m68kDivuWordDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 0a4 dvum1
	    reg_alub = reg_dbin;
	    reg_alue = reg_da[rx_index];
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 213 dvum2
	    reg_t = (reg_isr & SrZero) ? 1 : 0;
	    aluSub(reg_alub, high16(reg_da[rx_index]));
	    updateNZVC();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (reg_t)
	    {
		goto dvur2;
	    }
	    else
	    {
		goto dvum3;
	    }
	dvum3:
	    // 023 dvum3
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    setReg16Low(reg_at, high16(reg_da[rx_index]));
	    reg_au = merge32(0, reg_ftu) + 1;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (reg_t)
	    {
		goto dvum5;
	    }
	    else
	    {
		goto dvum4;
	    }
	dvur2:
	    // 0e3 dvur2
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 27;
	}
	break;
	case 27:
	{
	    inst_cycle = 28;
	}
	break;
	case 28:
	{
	    // 217 dvur3
	    initST();
	    reg_pc = reg_au;
	    aluAnd(reg_au, 0xFFFF);
	    reg_au = reg_da[16] - 2;
	    inst_cycle = 29;
	}
	break;
	case 29:
	{
	    inst_cycle = 30;
	}
	break;
	case 30:
	{
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 31;
	}
	break;
	case 31:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x05);
	    reg_da[16] = reg_au;
	    reg_ftu = 0x0014;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 32;
	}
	break;
	case 32:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 33;
	}
	break;
	case 33:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 34;
	}
	break;
	case 34:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 35;
	}
	break;
	case 35:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 36;
	}
	break;
	case 36:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 37;
	}
	break;
	case 37:
	{
	    inst_cycle = 38;
	}
	break;
	case 38:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 39;
	}
	break;
	case 39:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvum4:
	    // 2d1 dvum4
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 0e6 dvuma
	    reg_ird = reg_ir;
	    setIntState();
	    aluOver(0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvum5:
	    // 291 dvum5
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_au = reg_au - 1;
	    aluSla0(reg_aluo);
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    if (reg_t)
	    {
		goto dvum7;
	    }
	    else
	    {
		goto dvum8;
	    }
	dvum8:
	    // 252 dvum8
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    if (reg_t)
	    {
		goto dvumc;
	    }
	    else
	    {
		goto dvumb;
	    }
	dvum7:
	    // 2d2 dvum7
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 18;
	}
	break;
	case 18:
	{
	    inst_cycle = 19;
	}
	break;
	case 19:
	{
	    if (reg_t)
	    {
		goto dvum9;
	    }
	    else
	    {
		goto dvum6;
	    }
	dvumb:
	    // 3e9 dvumb
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    inst_cycle = 14;
	}
	break;
	case 14:
	{
	    inst_cycle = 15;
	}
	break;
	case 15:
	{
	    if (reg_t)
	    {
		goto dvume;
	    }
	    else
	    {
		goto dvum6;
	    }
	dvumc:
	    // 369 dvumc
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    setReg16High(reg_da[rx_index], reg_aluo);
	    aluAnd(reg_aluo, 0x0000);
	    inst_cycle = 25;
	}
	break;
	case 25:
	{
	    inst_cycle = 26;
	}
	break;
	case 26:
	{
	    if (reg_t)
	    {
		goto dvumf;
	    }
	    else
	    {
		goto dvumd;
	    }
	dvum6:
	    // 2d0 dvum6
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_au = reg_au - 1;
	    aluSla1(reg_aluo);
	    inst_cycle = 16;
	}
	break;
	case 16:
	{
	    inst_cycle = 17;
	}
	break;
	case 17:
	{
	    if (reg_t)
	    {
		goto dvum7;
	    }
	    else
	    {
		goto dvum8;
	    }
	dvum9:
	    // 250 dvum9
	    setReg16High(reg_da[rx_index], reg_aluo);
	    aluAnd(reg_aluo, 0x0000);
	    inst_cycle = 20;
	}
	break;
	case 20:
	{
	    inst_cycle = 21;
	}
	break;
	case 21:
	{
	    goto dvumd;
	dvume:
	    // 290 dvume
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 23;
	}
	break;
	case 23:
	{
	    inst_cycle = 24;
	}
	break;
	case 24:
	{
	    goto dvum5;
	dvumd:
	    // 0c0 dvumd
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_aluo;
	    reg_au = reg_pc + 2;
	    aluSla1(reg_aluo);
	    goto dvum0;
	dvumf:
	    // 080 dvumf
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_aluo;
	    setReg16High(reg_da[rx_index], reg_at);
	    reg_au = reg_pc + 2;
	    aluSla0(reg_aluo);
	    goto dvum0;
	dvum0:
	    // 212 dvum0
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_alue);
	    aluSub(reg_alub, reg_alue);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 22;
	}
	break;
	case 22:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 80f0 f1f8
void m68kDivuWordDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluOver(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 41;
	}
	break;
	case 41:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 0a4 dvum1
	    reg_alub = reg_dbin;
	    reg_alue = reg_da[rx_index];
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 213 dvum2
	    reg_t = (reg_isr & SrZero) ? 1 : 0;
	    aluSub(reg_alub, high16(reg_da[rx_index]));
	    updateNZVC();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (reg_t)
	    {
		goto dvur2;
	    }
	    else
	    {
		goto dvum3;
	    }
	dvum3:
	    // 023 dvum3
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    setReg16Low(reg_at, high16(reg_da[rx_index]));
	    reg_au = merge32(0, reg_ftu) + 1;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (reg_t)
	    {
		goto dvum5;
	    }
	    else
	    {
		goto dvum4;
	    }
	dvur2:
	    // 0e3 dvur2
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 28;
	}
	break;
	case 28:
	{
	    inst_cycle = 29;
	}
	break;
	case 29:
	{
	    // 217 dvur3
	    initST();
	    reg_pc = reg_au;
	    aluAnd(reg_au, 0xFFFF);
	    reg_au = reg_da[16] - 2;
	    inst_cycle = 30;
	}
	break;
	case 30:
	{
	    inst_cycle = 31;
	}
	break;
	case 31:
	{
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 32;
	}
	break;
	case 32:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x05);
	    reg_da[16] = reg_au;
	    reg_ftu = 0x0014;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 33;
	}
	break;
	case 33:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 34;
	}
	break;
	case 34:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 35;
	}
	break;
	case 35:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 36;
	}
	break;
	case 36:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 37;
	}
	break;
	case 37:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 38;
	}
	break;
	case 38:
	{
	    inst_cycle = 39;
	}
	break;
	case 39:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 40;
	}
	break;
	case 40:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvum4:
	    // 2d1 dvum4
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 0e6 dvuma
	    reg_ird = reg_ir;
	    setIntState();
	    aluOver(0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvum5:
	    // 291 dvum5
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_au = reg_au - 1;
	    aluSla0(reg_aluo);
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    if (reg_t)
	    {
		goto dvum7;
	    }
	    else
	    {
		goto dvum8;
	    }
	dvum8:
	    // 252 dvum8
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    inst_cycle = 14;
	}
	break;
	case 14:
	{
	    if (reg_t)
	    {
		goto dvumc;
	    }
	    else
	    {
		goto dvumb;
	    }
	dvum7:
	    // 2d2 dvum7
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 19;
	}
	break;
	case 19:
	{
	    inst_cycle = 20;
	}
	break;
	case 20:
	{
	    if (reg_t)
	    {
		goto dvum9;
	    }
	    else
	    {
		goto dvum6;
	    }
	dvumb:
	    // 3e9 dvumb
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    inst_cycle = 15;
	}
	break;
	case 15:
	{
	    inst_cycle = 16;
	}
	break;
	case 16:
	{
	    if (reg_t)
	    {
		goto dvume;
	    }
	    else
	    {
		goto dvum6;
	    }
	dvumc:
	    // 369 dvumc
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    setReg16High(reg_da[rx_index], reg_aluo);
	    aluAnd(reg_aluo, 0x0000);
	    inst_cycle = 26;
	}
	break;
	case 26:
	{
	    inst_cycle = 27;
	}
	break;
	case 27:
	{
	    if (reg_t)
	    {
		goto dvumf;
	    }
	    else
	    {
		goto dvumd;
	    }
	dvum6:
	    // 2d0 dvum6
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_au = reg_au - 1;
	    aluSla1(reg_aluo);
	    inst_cycle = 17;
	}
	break;
	case 17:
	{
	    inst_cycle = 18;
	}
	break;
	case 18:
	{
	    if (reg_t)
	    {
		goto dvum7;
	    }
	    else
	    {
		goto dvum8;
	    }
	dvum9:
	    // 250 dvum9
	    setReg16High(reg_da[rx_index], reg_aluo);
	    aluAnd(reg_aluo, 0x0000);
	    inst_cycle = 21;
	}
	break;
	case 21:
	{
	    inst_cycle = 22;
	}
	break;
	case 22:
	{
	    goto dvumd;
	dvume:
	    // 290 dvume
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 24;
	}
	break;
	case 24:
	{
	    inst_cycle = 25;
	}
	break;
	case 25:
	{
	    goto dvum5;
	dvumd:
	    // 0c0 dvumd
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_aluo;
	    reg_au = reg_pc + 2;
	    aluSla1(reg_aluo);
	    goto dvum0;
	dvumf:
	    // 080 dvumf
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_aluo;
	    setReg16High(reg_da[rx_index], reg_at);
	    reg_au = reg_pc + 2;
	    aluSla0(reg_aluo);
	    goto dvum0;
	dvum0:
	    // 212 dvum0
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_alue);
	    aluSub(reg_alub, reg_alue);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 23;
	}
	break;
	case 23:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 80f8 f1ff
void m68kDivuWordAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 0a4 dvum1
	    reg_alub = reg_dbin;
	    reg_alue = reg_da[rx_index];
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 213 dvum2
	    reg_t = (reg_isr & SrZero) ? 1 : 0;
	    aluSub(reg_alub, high16(reg_da[rx_index]));
	    updateNZVC();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (reg_t)
	    {
		goto dvur2;
	    }
	    else
	    {
		goto dvum3;
	    }
	dvum3:
	    // 023 dvum3
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    setReg16Low(reg_at, high16(reg_da[rx_index]));
	    reg_au = merge32(0, reg_ftu) + 1;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (reg_t)
	    {
		goto dvum5;
	    }
	    else
	    {
		goto dvum4;
	    }
	dvur2:
	    // 0e3 dvur2
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 27;
	}
	break;
	case 27:
	{
	    inst_cycle = 28;
	}
	break;
	case 28:
	{
	    // 217 dvur3
	    initST();
	    reg_pc = reg_au;
	    aluAnd(reg_au, 0xFFFF);
	    reg_au = reg_da[16] - 2;
	    inst_cycle = 29;
	}
	break;
	case 29:
	{
	    inst_cycle = 30;
	}
	break;
	case 30:
	{
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 31;
	}
	break;
	case 31:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x05);
	    reg_da[16] = reg_au;
	    reg_ftu = 0x0014;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 32;
	}
	break;
	case 32:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 33;
	}
	break;
	case 33:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 34;
	}
	break;
	case 34:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 35;
	}
	break;
	case 35:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 36;
	}
	break;
	case 36:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 37;
	}
	break;
	case 37:
	{
	    inst_cycle = 38;
	}
	break;
	case 38:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 39;
	}
	break;
	case 39:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvum4:
	    // 2d1 dvum4
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 0e6 dvuma
	    reg_ird = reg_ir;
	    setIntState();
	    aluOver(0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvum5:
	    // 291 dvum5
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_au = reg_au - 1;
	    aluSla0(reg_aluo);
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    if (reg_t)
	    {
		goto dvum7;
	    }
	    else
	    {
		goto dvum8;
	    }
	dvum8:
	    // 252 dvum8
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    if (reg_t)
	    {
		goto dvumc;
	    }
	    else
	    {
		goto dvumb;
	    }
	dvum7:
	    // 2d2 dvum7
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 18;
	}
	break;
	case 18:
	{
	    inst_cycle = 19;
	}
	break;
	case 19:
	{
	    if (reg_t)
	    {
		goto dvum9;
	    }
	    else
	    {
		goto dvum6;
	    }
	dvumb:
	    // 3e9 dvumb
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    inst_cycle = 14;
	}
	break;
	case 14:
	{
	    inst_cycle = 15;
	}
	break;
	case 15:
	{
	    if (reg_t)
	    {
		goto dvume;
	    }
	    else
	    {
		goto dvum6;
	    }
	dvumc:
	    // 369 dvumc
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    setReg16High(reg_da[rx_index], reg_aluo);
	    aluAnd(reg_aluo, 0x0000);
	    inst_cycle = 25;
	}
	break;
	case 25:
	{
	    inst_cycle = 26;
	}
	break;
	case 26:
	{
	    if (reg_t)
	    {
		goto dvumf;
	    }
	    else
	    {
		goto dvumd;
	    }
	dvum6:
	    // 2d0 dvum6
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_au = reg_au - 1;
	    aluSla1(reg_aluo);
	    inst_cycle = 16;
	}
	break;
	case 16:
	{
	    inst_cycle = 17;
	}
	break;
	case 17:
	{
	    if (reg_t)
	    {
		goto dvum7;
	    }
	    else
	    {
		goto dvum8;
	    }
	dvum9:
	    // 250 dvum9
	    setReg16High(reg_da[rx_index], reg_aluo);
	    aluAnd(reg_aluo, 0x0000);
	    inst_cycle = 20;
	}
	break;
	case 20:
	{
	    inst_cycle = 21;
	}
	break;
	case 21:
	{
	    goto dvumd;
	dvume:
	    // 290 dvume
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 23;
	}
	break;
	case 23:
	{
	    inst_cycle = 24;
	}
	break;
	case 24:
	{
	    goto dvum5;
	dvumd:
	    // 0c0 dvumd
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_aluo;
	    reg_au = reg_pc + 2;
	    aluSla1(reg_aluo);
	    goto dvum0;
	dvumf:
	    // 080 dvumf
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_aluo;
	    setReg16High(reg_da[rx_index], reg_at);
	    reg_au = reg_pc + 2;
	    aluSla0(reg_aluo);
	    goto dvum0;
	dvum0:
	    // 212 dvum0
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_alue);
	    aluSub(reg_alub, reg_alue);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 22;
	}
	break;
	case 22:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 80f9 f1ff
void m68kDivuWordAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 0a4 dvum1
	    reg_alub = reg_dbin;
	    reg_alue = reg_da[rx_index];
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 213 dvum2
	    reg_t = (reg_isr & SrZero) ? 1 : 0;
	    aluSub(reg_alub, high16(reg_da[rx_index]));
	    updateNZVC();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (reg_t)
	    {
		goto dvur2;
	    }
	    else
	    {
		goto dvum3;
	    }
	dvum3:
	    // 023 dvum3
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    setReg16Low(reg_at, high16(reg_da[rx_index]));
	    reg_au = merge32(0, reg_ftu) + 1;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (reg_t)
	    {
		goto dvum5;
	    }
	    else
	    {
		goto dvum4;
	    }
	dvur2:
	    // 0e3 dvur2
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 28;
	}
	break;
	case 28:
	{
	    inst_cycle = 29;
	}
	break;
	case 29:
	{
	    // 217 dvur3
	    initST();
	    reg_pc = reg_au;
	    aluAnd(reg_au, 0xFFFF);
	    reg_au = reg_da[16] - 2;
	    inst_cycle = 30;
	}
	break;
	case 30:
	{
	    inst_cycle = 31;
	}
	break;
	case 31:
	{
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 32;
	}
	break;
	case 32:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x05);
	    reg_da[16] = reg_au;
	    reg_ftu = 0x0014;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 33;
	}
	break;
	case 33:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 34;
	}
	break;
	case 34:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 35;
	}
	break;
	case 35:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 36;
	}
	break;
	case 36:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 37;
	}
	break;
	case 37:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 38;
	}
	break;
	case 38:
	{
	    inst_cycle = 39;
	}
	break;
	case 39:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 40;
	}
	break;
	case 40:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvum4:
	    // 2d1 dvum4
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 0e6 dvuma
	    reg_ird = reg_ir;
	    setIntState();
	    aluOver(0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvum5:
	    // 291 dvum5
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_au = reg_au - 1;
	    aluSla0(reg_aluo);
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    if (reg_t)
	    {
		goto dvum7;
	    }
	    else
	    {
		goto dvum8;
	    }
	dvum8:
	    // 252 dvum8
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    inst_cycle = 14;
	}
	break;
	case 14:
	{
	    if (reg_t)
	    {
		goto dvumc;
	    }
	    else
	    {
		goto dvumb;
	    }
	dvum7:
	    // 2d2 dvum7
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 19;
	}
	break;
	case 19:
	{
	    inst_cycle = 20;
	}
	break;
	case 20:
	{
	    if (reg_t)
	    {
		goto dvum9;
	    }
	    else
	    {
		goto dvum6;
	    }
	dvumb:
	    // 3e9 dvumb
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    inst_cycle = 15;
	}
	break;
	case 15:
	{
	    inst_cycle = 16;
	}
	break;
	case 16:
	{
	    if (reg_t)
	    {
		goto dvume;
	    }
	    else
	    {
		goto dvum6;
	    }
	dvumc:
	    // 369 dvumc
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    setReg16High(reg_da[rx_index], reg_aluo);
	    aluAnd(reg_aluo, 0x0000);
	    inst_cycle = 26;
	}
	break;
	case 26:
	{
	    inst_cycle = 27;
	}
	break;
	case 27:
	{
	    if (reg_t)
	    {
		goto dvumf;
	    }
	    else
	    {
		goto dvumd;
	    }
	dvum6:
	    // 2d0 dvum6
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_au = reg_au - 1;
	    aluSla1(reg_aluo);
	    inst_cycle = 17;
	}
	break;
	case 17:
	{
	    inst_cycle = 18;
	}
	break;
	case 18:
	{
	    if (reg_t)
	    {
		goto dvum7;
	    }
	    else
	    {
		goto dvum8;
	    }
	dvum9:
	    // 250 dvum9
	    setReg16High(reg_da[rx_index], reg_aluo);
	    aluAnd(reg_aluo, 0x0000);
	    inst_cycle = 21;
	}
	break;
	case 21:
	{
	    inst_cycle = 22;
	}
	break;
	case 22:
	{
	    goto dvumd;
	dvume:
	    // 290 dvume
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 24;
	}
	break;
	case 24:
	{
	    inst_cycle = 25;
	}
	break;
	case 25:
	{
	    goto dvum5;
	dvumd:
	    // 0c0 dvumd
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_aluo;
	    reg_au = reg_pc + 2;
	    aluSla1(reg_aluo);
	    goto dvum0;
	dvumf:
	    // 080 dvumf
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_aluo;
	    setReg16High(reg_da[rx_index], reg_at);
	    reg_au = reg_pc + 2;
	    aluSla0(reg_aluo);
	    goto dvum0;
	dvum0:
	    // 212 dvum0
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_alue);
	    aluSub(reg_alub, reg_alue);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 23;
	}
	break;
	case 23:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 80fa f1ff
void m68kDivuWordDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 0a4 dvum1
	    reg_alub = reg_dbin;
	    reg_alue = reg_da[rx_index];
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 213 dvum2
	    reg_t = (reg_isr & SrZero) ? 1 : 0;
	    aluSub(reg_alub, high16(reg_da[rx_index]));
	    updateNZVC();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (reg_t)
	    {
		goto dvur2;
	    }
	    else
	    {
		goto dvum3;
	    }
	dvum3:
	    // 023 dvum3
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    setReg16Low(reg_at, high16(reg_da[rx_index]));
	    reg_au = merge32(0, reg_ftu) + 1;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (reg_t)
	    {
		goto dvum5;
	    }
	    else
	    {
		goto dvum4;
	    }
	dvur2:
	    // 0e3 dvur2
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 27;
	}
	break;
	case 27:
	{
	    inst_cycle = 28;
	}
	break;
	case 28:
	{
	    // 217 dvur3
	    initST();
	    reg_pc = reg_au;
	    aluAnd(reg_au, 0xFFFF);
	    reg_au = reg_da[16] - 2;
	    inst_cycle = 29;
	}
	break;
	case 29:
	{
	    inst_cycle = 30;
	}
	break;
	case 30:
	{
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 31;
	}
	break;
	case 31:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x05);
	    reg_da[16] = reg_au;
	    reg_ftu = 0x0014;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 32;
	}
	break;
	case 32:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 33;
	}
	break;
	case 33:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 34;
	}
	break;
	case 34:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 35;
	}
	break;
	case 35:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 36;
	}
	break;
	case 36:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 37;
	}
	break;
	case 37:
	{
	    inst_cycle = 38;
	}
	break;
	case 38:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 39;
	}
	break;
	case 39:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvum4:
	    // 2d1 dvum4
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 0e6 dvuma
	    reg_ird = reg_ir;
	    setIntState();
	    aluOver(0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvum5:
	    // 291 dvum5
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_au = reg_au - 1;
	    aluSla0(reg_aluo);
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    if (reg_t)
	    {
		goto dvum7;
	    }
	    else
	    {
		goto dvum8;
	    }
	dvum8:
	    // 252 dvum8
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    if (reg_t)
	    {
		goto dvumc;
	    }
	    else
	    {
		goto dvumb;
	    }
	dvum7:
	    // 2d2 dvum7
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 18;
	}
	break;
	case 18:
	{
	    inst_cycle = 19;
	}
	break;
	case 19:
	{
	    if (reg_t)
	    {
		goto dvum9;
	    }
	    else
	    {
		goto dvum6;
	    }
	dvumb:
	    // 3e9 dvumb
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    inst_cycle = 14;
	}
	break;
	case 14:
	{
	    inst_cycle = 15;
	}
	break;
	case 15:
	{
	    if (reg_t)
	    {
		goto dvume;
	    }
	    else
	    {
		goto dvum6;
	    }
	dvumc:
	    // 369 dvumc
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    setReg16High(reg_da[rx_index], reg_aluo);
	    aluAnd(reg_aluo, 0x0000);
	    inst_cycle = 25;
	}
	break;
	case 25:
	{
	    inst_cycle = 26;
	}
	break;
	case 26:
	{
	    if (reg_t)
	    {
		goto dvumf;
	    }
	    else
	    {
		goto dvumd;
	    }
	dvum6:
	    // 2d0 dvum6
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_au = reg_au - 1;
	    aluSla1(reg_aluo);
	    inst_cycle = 16;
	}
	break;
	case 16:
	{
	    inst_cycle = 17;
	}
	break;
	case 17:
	{
	    if (reg_t)
	    {
		goto dvum7;
	    }
	    else
	    {
		goto dvum8;
	    }
	dvum9:
	    // 250 dvum9
	    setReg16High(reg_da[rx_index], reg_aluo);
	    aluAnd(reg_aluo, 0x0000);
	    inst_cycle = 20;
	}
	break;
	case 20:
	{
	    inst_cycle = 21;
	}
	break;
	case 21:
	{
	    goto dvumd;
	dvume:
	    // 290 dvume
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 23;
	}
	break;
	case 23:
	{
	    inst_cycle = 24;
	}
	break;
	case 24:
	{
	    goto dvum5;
	dvumd:
	    // 0c0 dvumd
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_aluo;
	    reg_au = reg_pc + 2;
	    aluSla1(reg_aluo);
	    goto dvum0;
	dvumf:
	    // 080 dvumf
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_aluo;
	    setReg16High(reg_da[rx_index], reg_at);
	    reg_au = reg_pc + 2;
	    aluSla0(reg_aluo);
	    goto dvum0;
	dvum0:
	    // 212 dvum0
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_alue);
	    aluSub(reg_alub, reg_alue);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 22;
	}
	break;
	case 22:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 80fb f1ff
void m68kDivuWordDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluOver(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 41;
	}
	break;
	case 41:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 0a4 dvum1
	    reg_alub = reg_dbin;
	    reg_alue = reg_da[rx_index];
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 213 dvum2
	    reg_t = (reg_isr & SrZero) ? 1 : 0;
	    aluSub(reg_alub, high16(reg_da[rx_index]));
	    updateNZVC();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (reg_t)
	    {
		goto dvur2;
	    }
	    else
	    {
		goto dvum3;
	    }
	dvum3:
	    // 023 dvum3
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    setReg16Low(reg_at, high16(reg_da[rx_index]));
	    reg_au = merge32(0, reg_ftu) + 1;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (reg_t)
	    {
		goto dvum5;
	    }
	    else
	    {
		goto dvum4;
	    }
	dvur2:
	    // 0e3 dvur2
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 28;
	}
	break;
	case 28:
	{
	    inst_cycle = 29;
	}
	break;
	case 29:
	{
	    // 217 dvur3
	    initST();
	    reg_pc = reg_au;
	    aluAnd(reg_au, 0xFFFF);
	    reg_au = reg_da[16] - 2;
	    inst_cycle = 30;
	}
	break;
	case 30:
	{
	    inst_cycle = 31;
	}
	break;
	case 31:
	{
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 32;
	}
	break;
	case 32:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x05);
	    reg_da[16] = reg_au;
	    reg_ftu = 0x0014;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 33;
	}
	break;
	case 33:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 34;
	}
	break;
	case 34:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 35;
	}
	break;
	case 35:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 36;
	}
	break;
	case 36:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 37;
	}
	break;
	case 37:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 38;
	}
	break;
	case 38:
	{
	    inst_cycle = 39;
	}
	break;
	case 39:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 40;
	}
	break;
	case 40:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvum4:
	    // 2d1 dvum4
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 0e6 dvuma
	    reg_ird = reg_ir;
	    setIntState();
	    aluOver(0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvum5:
	    // 291 dvum5
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_au = reg_au - 1;
	    aluSla0(reg_aluo);
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    if (reg_t)
	    {
		goto dvum7;
	    }
	    else
	    {
		goto dvum8;
	    }
	dvum8:
	    // 252 dvum8
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    inst_cycle = 14;
	}
	break;
	case 14:
	{
	    if (reg_t)
	    {
		goto dvumc;
	    }
	    else
	    {
		goto dvumb;
	    }
	dvum7:
	    // 2d2 dvum7
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 19;
	}
	break;
	case 19:
	{
	    inst_cycle = 20;
	}
	break;
	case 20:
	{
	    if (reg_t)
	    {
		goto dvum9;
	    }
	    else
	    {
		goto dvum6;
	    }
	dvumb:
	    // 3e9 dvumb
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    inst_cycle = 15;
	}
	break;
	case 15:
	{
	    inst_cycle = 16;
	}
	break;
	case 16:
	{
	    if (reg_t)
	    {
		goto dvume;
	    }
	    else
	    {
		goto dvum6;
	    }
	dvumc:
	    // 369 dvumc
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    setReg16High(reg_da[rx_index], reg_aluo);
	    aluAnd(reg_aluo, 0x0000);
	    inst_cycle = 26;
	}
	break;
	case 26:
	{
	    inst_cycle = 27;
	}
	break;
	case 27:
	{
	    if (reg_t)
	    {
		goto dvumf;
	    }
	    else
	    {
		goto dvumd;
	    }
	dvum6:
	    // 2d0 dvum6
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_au = reg_au - 1;
	    aluSla1(reg_aluo);
	    inst_cycle = 17;
	}
	break;
	case 17:
	{
	    inst_cycle = 18;
	}
	break;
	case 18:
	{
	    if (reg_t)
	    {
		goto dvum7;
	    }
	    else
	    {
		goto dvum8;
	    }
	dvum9:
	    // 250 dvum9
	    setReg16High(reg_da[rx_index], reg_aluo);
	    aluAnd(reg_aluo, 0x0000);
	    inst_cycle = 21;
	}
	break;
	case 21:
	{
	    inst_cycle = 22;
	}
	break;
	case 22:
	{
	    goto dvumd;
	dvume:
	    // 290 dvume
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 24;
	}
	break;
	case 24:
	{
	    inst_cycle = 25;
	}
	break;
	case 25:
	{
	    goto dvum5;
	dvumd:
	    // 0c0 dvumd
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_aluo;
	    reg_au = reg_pc + 2;
	    aluSla1(reg_aluo);
	    goto dvum0;
	dvumf:
	    // 080 dvumf
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_aluo;
	    setReg16High(reg_da[rx_index], reg_at);
	    reg_au = reg_pc + 2;
	    aluSla0(reg_aluo);
	    goto dvum0;
	dvum0:
	    // 212 dvum0
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_alue);
	    aluSub(reg_alub, reg_alue);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 23;
	}
	break;
	case 23:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 80fc f1ff
void m68kDivuWordImm16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 0a6 dvur1
	    reg_alub = reg_dt;
	    reg_alue = reg_da[rx_index];
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dt);
	    aluAnd(reg_dt, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 213 dvum2
	    reg_t = (reg_isr & SrZero) ? 1 : 0;
	    aluSub(reg_alub, high16(reg_da[rx_index]));
	    updateNZVC();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (reg_t)
	    {
		goto dvur2;
	    }
	    else
	    {
		goto dvum3;
	    }
	dvum3:
	    // 023 dvum3
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    setReg16Low(reg_at, high16(reg_da[rx_index]));
	    reg_au = merge32(0, reg_ftu) + 1;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (reg_t)
	    {
		goto dvum5;
	    }
	    else
	    {
		goto dvum4;
	    }
	dvur2:
	    // 0e3 dvur2
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 26;
	}
	break;
	case 26:
	{
	    inst_cycle = 27;
	}
	break;
	case 27:
	{
	    // 217 dvur3
	    initST();
	    reg_pc = reg_au;
	    aluAnd(reg_au, 0xFFFF);
	    reg_au = reg_da[16] - 2;
	    inst_cycle = 28;
	}
	break;
	case 28:
	{
	    inst_cycle = 29;
	}
	break;
	case 29:
	{
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 30;
	}
	break;
	case 30:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x05);
	    reg_da[16] = reg_au;
	    reg_ftu = 0x0014;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 31;
	}
	break;
	case 31:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 32;
	}
	break;
	case 32:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 33;
	}
	break;
	case 33:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 34;
	}
	break;
	case 34:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 35;
	}
	break;
	case 35:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 36;
	}
	break;
	case 36:
	{
	    inst_cycle = 37;
	}
	break;
	case 37:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 38;
	}
	break;
	case 38:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvum4:
	    // 2d1 dvum4
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    // 0e6 dvuma
	    reg_ird = reg_ir;
	    setIntState();
	    aluOver(0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvum5:
	    // 291 dvum5
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_au = reg_au - 1;
	    aluSla0(reg_aluo);
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (reg_t)
	    {
		goto dvum7;
	    }
	    else
	    {
		goto dvum8;
	    }
	dvum8:
	    // 252 dvum8
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    if (reg_t)
	    {
		goto dvumc;
	    }
	    else
	    {
		goto dvumb;
	    }
	dvum7:
	    // 2d2 dvum7
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 17;
	}
	break;
	case 17:
	{
	    inst_cycle = 18;
	}
	break;
	case 18:
	{
	    if (reg_t)
	    {
		goto dvum9;
	    }
	    else
	    {
		goto dvum6;
	    }
	dvumb:
	    // 3e9 dvumb
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    inst_cycle = 14;
	}
	break;
	case 14:
	{
	    if (reg_t)
	    {
		goto dvume;
	    }
	    else
	    {
		goto dvum6;
	    }
	dvumc:
	    // 369 dvumc
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    setReg16High(reg_da[rx_index], reg_aluo);
	    aluAnd(reg_aluo, 0x0000);
	    inst_cycle = 24;
	}
	break;
	case 24:
	{
	    inst_cycle = 25;
	}
	break;
	case 25:
	{
	    if (reg_t)
	    {
		goto dvumf;
	    }
	    else
	    {
		goto dvumd;
	    }
	dvum6:
	    // 2d0 dvum6
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_au = reg_au - 1;
	    aluSla1(reg_aluo);
	    inst_cycle = 15;
	}
	break;
	case 15:
	{
	    inst_cycle = 16;
	}
	break;
	case 16:
	{
	    if (reg_t)
	    {
		goto dvum7;
	    }
	    else
	    {
		goto dvum8;
	    }
	dvum9:
	    // 250 dvum9
	    setReg16High(reg_da[rx_index], reg_aluo);
	    aluAnd(reg_aluo, 0x0000);
	    inst_cycle = 19;
	}
	break;
	case 19:
	{
	    inst_cycle = 20;
	}
	break;
	case 20:
	{
	    goto dvumd;
	dvume:
	    // 290 dvume
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 22;
	}
	break;
	case 22:
	{
	    inst_cycle = 23;
	}
	break;
	case 23:
	{
	    goto dvum5;
	dvumd:
	    // 0c0 dvumd
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_aluo;
	    reg_au = reg_pc + 2;
	    aluSla1(reg_aluo);
	    goto dvum0;
	dvumf:
	    // 080 dvumf
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_aluo;
	    setReg16High(reg_da[rx_index], reg_at);
	    reg_au = reg_pc + 2;
	    aluSla0(reg_aluo);
	    goto dvum0;
	dvum0:
	    // 212 dvum0
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_alue);
	    aluSub(reg_alub, reg_alue);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 21;
	}
	break;
	case 21:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 8100 f1f8
void m68kSbcdDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1cd rbrb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluSbcdByte(reg_da[ry_index], reg_da[rx_index]);
	    updateXNZVCU();
	    // 11b rbrb2
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 238 rbrb3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 8108 f1f8
void m68kSbcdPaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 107 asbb1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 135 asbb2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 136 asbb3
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 04e asbb4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_at = reg_au;
	    reg_da[rx_index] = reg_au;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 040 asbb5
	    reg_aob = reg_pc;
	    aluSbcdByte(reg_alub, reg_dbin);
	    updateXNZVCU();
	    // 113 asbb6
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 8110 f1f8
void m68kOrByteDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOrByte(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 8118 f1f8
void m68kOrByteDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOrByte(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 8120 f1f8
void m68kOrByteDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    aluOrByte(reg_da[rx_index], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOrByte(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 8128 f1f8
void m68kOrByteDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOrByte(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 8130 f1f8
void m68kOrByteDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOrByte(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 8138 f1ff
void m68kOrByteDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluOrByte(reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOrByte(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 8139 f1ff
void m68kOrByteDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluOrByte(reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOrByte(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 8150 f1f8
void m68kOrWordDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOr(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 8158 f1f8
void m68kOrWordDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluOr(reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOr(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 8160 f1f8
void m68kOrWordDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    aluOr(reg_da[rx_index], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOr(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 8168 f1f8
void m68kOrWordDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOr(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 8170 f1f8
void m68kOrWordDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOr(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 8178 f1ff
void m68kOrWordDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluOr(reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOr(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 8179 f1ff
void m68kOrWordDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluOr(reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOr(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 8190 f1f8
void m68kOrLongDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOr(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluOr(high16(reg_da[rx_index]), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 8198 f1f8
void m68kOrLongDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOr(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluOr(high16(reg_da[rx_index]), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 81a0 f1f8
void m68kOrLongDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOr(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluOr(high16(reg_da[rx_index]), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 81a8 f1f8
void m68kOrLongDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOr(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluOr(high16(reg_da[rx_index]), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 81b0 f1f8
void m68kOrLongDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOr(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluOr(high16(reg_da[rx_index]), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 81b8 f1ff
void m68kOrLongDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluOr(reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOr(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluOr(high16(reg_da[rx_index]), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 81b9 f1ff
void m68kOrLongDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 00d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluOr(reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluOr(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluOr(high16(reg_da[rx_index]), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 81c0 f1f8
void m68kDivsWordDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0ae dvs02
	    reg_alub = reg_da[ry_index];
	    reg_alue = reg_da[rx_index];
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_da[ry_index]);
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 0c9 dvs03
	    reg_t = (reg_isr & SrZero) ? 2 : (reg_isr & SrSign) ? 1 : 0;
	    aluSub(reg_alub, 0x0000);
	    updateNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t == 0)
	    {
		goto dvs04;
	    }
	    else if (reg_t == 1)
	    {
		goto dvs05;
	    }
	    else
	    {
		goto dvur2;
	    }
	dvs04:
	    // 0a3 dvs04
	    setReg16Low(reg_at, high16(reg_da[rx_index]));
	    reg_au = merge32(0, reg_ftu) + 1;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    goto dvs06;
	dvs05:
	    // 063 dvs05
	    reg_alub = reg_aluo;
	    setReg16Low(reg_at, high16(reg_da[rx_index]));
	    reg_au = merge32(0, reg_ftu) + 1;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 50;
	}
	break;
	case 50:
	{
	    inst_cycle = 51;
	}
	break;
	case 51:
	{
	    goto dvs06;
	dvur2:
	    // 0e3 dvur2
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 52;
	}
	break;
	case 52:
	{
	    inst_cycle = 53;
	}
	break;
	case 53:
	{
	    // 217 dvur3
	    initST();
	    reg_pc = reg_au;
	    aluAnd(reg_au, 0xFFFF);
	    reg_au = reg_da[16] - 2;
	    inst_cycle = 54;
	}
	break;
	case 54:
	{
	    inst_cycle = 55;
	}
	break;
	case 55:
	{
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 56;
	}
	break;
	case 56:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x05);
	    reg_da[16] = reg_au;
	    reg_ftu = 0x0014;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 57;
	}
	break;
	case 57:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 58;
	}
	break;
	case 58:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 59;
	}
	break;
	case 59:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 60;
	}
	break;
	case 60:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 61;
	}
	break;
	case 61:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 62;
	}
	break;
	case 62:
	{
	    inst_cycle = 63;
	}
	break;
	case 63:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 64;
	}
	break;
	case 64:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvs06:
	    // 176 dvs06
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    aluSub(reg_da[rx_index], 0x0000);
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (reg_t)
	    {
		goto dvs10;
	    }
	    else
	    {
		goto dvs07;
	    }
	dvs07:
	    // 042 dvs07
	    aluSub(reg_alub, reg_at);
	    updateNZVC();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    goto dvs08;
	dvs10:
	    // 0c2 dvs10
	    reg_alue = reg_aluo;
	    aluSubc(high16(reg_da[rx_index]), 0x0000);
	    inst_cycle = 46;
	}
	break;
	case 46:
	{
	    inst_cycle = 47;
	}
	break;
	case 47:
	{
	    // 177 dvs11
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 48;
	}
	break;
	case 48:
	{
	    inst_cycle = 49;
	}
	break;
	case 49:
	{
	    goto dvs08;
	dvs08:
	    // 216 dvs08
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    if (reg_t)
	    {
		goto dvs09;
	    }
	    else
	    {
		goto dvumz;
	    }
	dvumz:
	    // 2d5 dvumz
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    goto dvuma;
	dvs09:
	    // 295 dvs09
	    reg_au = reg_au - 1;
	    aluSla0(reg_aluo);
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    inst_cycle = 14;
	}
	break;
	case 14:
	{
	    goto dvs0c;
	dvuma:
	    // 0e6 dvuma
	    reg_ird = reg_ir;
	    setIntState();
	    aluOver(0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvs0c:
	    // 2d6 dvs0c
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 15;
	}
	break;
	case 15:
	{
	    inst_cycle = 16;
	}
	break;
	case 16:
	{
	    if (reg_t)
	    {
		goto dvs0e;
	    }
	    else
	    {
		goto dvs0d;
	    }
	dvs0d:
	    // 3ed dvs0d
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    inst_cycle = 17;
	}
	break;
	case 17:
	{
	    inst_cycle = 18;
	}
	break;
	case 18:
	{
	    if (reg_t)
	    {
		goto dvs0f;
	    }
	    else
	    {
		goto dvs0a;
	    }
	dvs0e:
	    // 32d dvs0e
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    inst_cycle = 23;
	}
	break;
	case 23:
	{
	    inst_cycle = 24;
	}
	break;
	case 24:
	{
	    if (reg_t)
	    {
		goto dvs12;
	    }
	    else
	    {
		goto dvs13;
	    }
	dvs0a:
	    // 2d4 dvs0a
	    reg_au = reg_au - 1;
	    aluSla1(reg_aluo);
	    inst_cycle = 19;
	}
	break;
	case 19:
	{
	    inst_cycle = 20;
	}
	break;
	case 20:
	{
	    goto dvs0c;
	dvs0f:
	    // 294 dvs0f
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 21;
	}
	break;
	case 21:
	{
	    inst_cycle = 22;
	}
	break;
	case 22:
	{
	    goto dvs09;
	dvs13:
	    // 254 dvs13
	    setReg16Low(reg_at, reg_aluo);
	    aluSla1(reg_aluo);
	    inst_cycle = 25;
	}
	break;
	case 25:
	{
	    inst_cycle = 26;
	}
	break;
	case 26:
	{
	    goto dvs14;
	dvs12:
	    // 214 dvs12
	    reg_au = reg_au - 1;
	    aluSla0(reg_aluo);
	    inst_cycle = 44;
	}
	break;
	case 44:
	{
	    inst_cycle = 45;
	}
	break;
	case 45:
	{
	    goto dvs14;
	dvs14:
	    // 210 dvs14
	    aluAnd(high16(reg_at), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 27;
	}
	break;
	case 27:
	{
	    inst_cycle = 28;
	}
	break;
	case 28:
	{
	    // 211 dvs15
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_alub = reg_alue;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 29;
	}
	break;
	case 29:
	{
	    inst_cycle = 30;
	}
	break;
	case 30:
	{
	    if (reg_t)
	    {
		goto dvs1d;
	    }
	    else
	    {
		goto dvs16;
	    }
	dvs16:
	    // 041 dvs16
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    setReg16High(reg_at, reg_at);
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 31;
	}
	break;
	case 31:
	{
	    inst_cycle = 32;
	}
	break;
	case 32:
	{
	    if (reg_t)
	    {
		goto dvs1a;
	    }
	    else
	    {
		goto dvs17;
	    }
	dvs1d:
	    // 0c1 dvs1d
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    setReg16High(reg_at, reg_at);
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 38;
	}
	break;
	case 38:
	{
	    inst_cycle = 39;
	}
	break;
	case 39:
	{
	    if (reg_t)
	    {
		goto dvs1e;
	    }
	    else
	    {
		goto dvs1f;
	    }
	dvs17:
	    // 04d dvs17
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_pc + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVC();
	    if (reg_t)
	    {
		goto dvuma;
	    }
	    else
	    {
		goto leaa2;
	    }
	dvs1a:
	    // 0cd dvs1a
	    aluSub(reg_alub, 0x0000);
	    updateNZVC();
	    inst_cycle = 34;
	}
	break;
	case 34:
	{
	    inst_cycle = 35;
	}
	break;
	case 35:
	{
	    // 0ce dvs1b
	    reg_t = (reg_isr & (SrZero | SrSign)) ? 1 : 0;
	    reg_alub = reg_aluo;
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(high16(reg_at), 0x0000);
	    inst_cycle = 36;
	}
	break;
	case 36:
	{
	    inst_cycle = 37;
	}
	break;
	case 37:
	{
	    if (reg_t)
	    {
		goto dvs1c;
	    }
	    else
	    {
		goto dvum4;
	    }
	dvs1f:
	    // 08a dvs1f
	    reg_ir = reg_irc;
	    updateIPL();
	    aluSub(reg_alub, 0x0000);
	    updateNZVC();
	    inst_cycle = 40;
	}
	break;
	case 40:
	{
	    inst_cycle = 41;
	}
	break;
	case 41:
	{
	    // 049 dvs20
	    reg_aob = reg_pc;
	    reg_t = (reg_isr & (SrZero | SrSign)) ? 1 : 0;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_pc + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVC();
	    if (reg_t)
	    {
		goto leaa2;
	    }
	    else
	    {
		goto dvuma;
	    }
	dvs1e:
	    // 0ca dvs1e
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_alub = reg_aluo;
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(high16(reg_at), 0x0000);
	    inst_cycle = 42;
	}
	break;
	case 42:
	{
	    inst_cycle = 43;
	}
	break;
	case 43:
	{
	    if (reg_t)
	    {
		goto dvum4;
	    }
	    else
	    {
		goto dvs1c;
	    }
	leaa2:
	    // 066 leaa2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 33;
	}
	break;
	case 33:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvum4:
	    // 2d1 dvum4
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    goto dvuma;
	dvs1c:
	    // 251 dvs1c
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg16High(reg_at, reg_aluo);
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    goto leaa2;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 81d0 f1f8
void m68kDivsWordAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 0ac dvs01
	    reg_alub = reg_dbin;
	    reg_alue = reg_da[rx_index];
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 0c9 dvs03
	    reg_t = (reg_isr & SrZero) ? 2 : (reg_isr & SrSign) ? 1 : 0;
	    aluSub(reg_alub, 0x0000);
	    updateNZVC();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (reg_t == 0)
	    {
		goto dvs04;
	    }
	    else if (reg_t == 1)
	    {
		goto dvs05;
	    }
	    else
	    {
		goto dvur2;
	    }
	dvs04:
	    // 0a3 dvs04
	    setReg16Low(reg_at, high16(reg_da[rx_index]));
	    reg_au = merge32(0, reg_ftu) + 1;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    goto dvs06;
	dvs05:
	    // 063 dvs05
	    reg_alub = reg_aluo;
	    setReg16Low(reg_at, high16(reg_da[rx_index]));
	    reg_au = merge32(0, reg_ftu) + 1;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 52;
	}
	break;
	case 52:
	{
	    inst_cycle = 53;
	}
	break;
	case 53:
	{
	    goto dvs06;
	dvur2:
	    // 0e3 dvur2
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 54;
	}
	break;
	case 54:
	{
	    inst_cycle = 55;
	}
	break;
	case 55:
	{
	    // 217 dvur3
	    initST();
	    reg_pc = reg_au;
	    aluAnd(reg_au, 0xFFFF);
	    reg_au = reg_da[16] - 2;
	    inst_cycle = 56;
	}
	break;
	case 56:
	{
	    inst_cycle = 57;
	}
	break;
	case 57:
	{
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 58;
	}
	break;
	case 58:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x05);
	    reg_da[16] = reg_au;
	    reg_ftu = 0x0014;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 59;
	}
	break;
	case 59:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 60;
	}
	break;
	case 60:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 61;
	}
	break;
	case 61:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 62;
	}
	break;
	case 62:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 63;
	}
	break;
	case 63:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 64;
	}
	break;
	case 64:
	{
	    inst_cycle = 65;
	}
	break;
	case 65:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 66;
	}
	break;
	case 66:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvs06:
	    // 176 dvs06
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    aluSub(reg_da[rx_index], 0x0000);
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (reg_t)
	    {
		goto dvs10;
	    }
	    else
	    {
		goto dvs07;
	    }
	dvs07:
	    // 042 dvs07
	    aluSub(reg_alub, reg_at);
	    updateNZVC();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    goto dvs08;
	dvs10:
	    // 0c2 dvs10
	    reg_alue = reg_aluo;
	    aluSubc(high16(reg_da[rx_index]), 0x0000);
	    inst_cycle = 48;
	}
	break;
	case 48:
	{
	    inst_cycle = 49;
	}
	break;
	case 49:
	{
	    // 177 dvs11
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 50;
	}
	break;
	case 50:
	{
	    inst_cycle = 51;
	}
	break;
	case 51:
	{
	    goto dvs08;
	dvs08:
	    // 216 dvs08
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    if (reg_t)
	    {
		goto dvs09;
	    }
	    else
	    {
		goto dvumz;
	    }
	dvumz:
	    // 2d5 dvumz
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    goto dvuma;
	dvs09:
	    // 295 dvs09
	    reg_au = reg_au - 1;
	    aluSla0(reg_aluo);
	    inst_cycle = 15;
	}
	break;
	case 15:
	{
	    inst_cycle = 16;
	}
	break;
	case 16:
	{
	    goto dvs0c;
	dvuma:
	    // 0e6 dvuma
	    reg_ird = reg_ir;
	    setIntState();
	    aluOver(0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 14;
	}
	break;
	case 14:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvs0c:
	    // 2d6 dvs0c
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 17;
	}
	break;
	case 17:
	{
	    inst_cycle = 18;
	}
	break;
	case 18:
	{
	    if (reg_t)
	    {
		goto dvs0e;
	    }
	    else
	    {
		goto dvs0d;
	    }
	dvs0d:
	    // 3ed dvs0d
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    inst_cycle = 19;
	}
	break;
	case 19:
	{
	    inst_cycle = 20;
	}
	break;
	case 20:
	{
	    if (reg_t)
	    {
		goto dvs0f;
	    }
	    else
	    {
		goto dvs0a;
	    }
	dvs0e:
	    // 32d dvs0e
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    inst_cycle = 25;
	}
	break;
	case 25:
	{
	    inst_cycle = 26;
	}
	break;
	case 26:
	{
	    if (reg_t)
	    {
		goto dvs12;
	    }
	    else
	    {
		goto dvs13;
	    }
	dvs0a:
	    // 2d4 dvs0a
	    reg_au = reg_au - 1;
	    aluSla1(reg_aluo);
	    inst_cycle = 21;
	}
	break;
	case 21:
	{
	    inst_cycle = 22;
	}
	break;
	case 22:
	{
	    goto dvs0c;
	dvs0f:
	    // 294 dvs0f
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 23;
	}
	break;
	case 23:
	{
	    inst_cycle = 24;
	}
	break;
	case 24:
	{
	    goto dvs09;
	dvs13:
	    // 254 dvs13
	    setReg16Low(reg_at, reg_aluo);
	    aluSla1(reg_aluo);
	    inst_cycle = 27;
	}
	break;
	case 27:
	{
	    inst_cycle = 28;
	}
	break;
	case 28:
	{
	    goto dvs14;
	dvs12:
	    // 214 dvs12
	    reg_au = reg_au - 1;
	    aluSla0(reg_aluo);
	    inst_cycle = 46;
	}
	break;
	case 46:
	{
	    inst_cycle = 47;
	}
	break;
	case 47:
	{
	    goto dvs14;
	dvs14:
	    // 210 dvs14
	    aluAnd(high16(reg_at), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 29;
	}
	break;
	case 29:
	{
	    inst_cycle = 30;
	}
	break;
	case 30:
	{
	    // 211 dvs15
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_alub = reg_alue;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 31;
	}
	break;
	case 31:
	{
	    inst_cycle = 32;
	}
	break;
	case 32:
	{
	    if (reg_t)
	    {
		goto dvs1d;
	    }
	    else
	    {
		goto dvs16;
	    }
	dvs16:
	    // 041 dvs16
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    setReg16High(reg_at, reg_at);
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 33;
	}
	break;
	case 33:
	{
	    inst_cycle = 34;
	}
	break;
	case 34:
	{
	    if (reg_t)
	    {
		goto dvs1a;
	    }
	    else
	    {
		goto dvs17;
	    }
	dvs1d:
	    // 0c1 dvs1d
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    setReg16High(reg_at, reg_at);
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 40;
	}
	break;
	case 40:
	{
	    inst_cycle = 41;
	}
	break;
	case 41:
	{
	    if (reg_t)
	    {
		goto dvs1e;
	    }
	    else
	    {
		goto dvs1f;
	    }
	dvs17:
	    // 04d dvs17
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_pc + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVC();
	    if (reg_t)
	    {
		goto dvuma;
	    }
	    else
	    {
		goto leaa2;
	    }
	dvs1a:
	    // 0cd dvs1a
	    aluSub(reg_alub, 0x0000);
	    updateNZVC();
	    inst_cycle = 36;
	}
	break;
	case 36:
	{
	    inst_cycle = 37;
	}
	break;
	case 37:
	{
	    // 0ce dvs1b
	    reg_t = (reg_isr & (SrZero | SrSign)) ? 1 : 0;
	    reg_alub = reg_aluo;
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(high16(reg_at), 0x0000);
	    inst_cycle = 38;
	}
	break;
	case 38:
	{
	    inst_cycle = 39;
	}
	break;
	case 39:
	{
	    if (reg_t)
	    {
		goto dvs1c;
	    }
	    else
	    {
		goto dvum4;
	    }
	dvs1f:
	    // 08a dvs1f
	    reg_ir = reg_irc;
	    updateIPL();
	    aluSub(reg_alub, 0x0000);
	    updateNZVC();
	    inst_cycle = 42;
	}
	break;
	case 42:
	{
	    inst_cycle = 43;
	}
	break;
	case 43:
	{
	    // 049 dvs20
	    reg_aob = reg_pc;
	    reg_t = (reg_isr & (SrZero | SrSign)) ? 1 : 0;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_pc + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVC();
	    if (reg_t)
	    {
		goto leaa2;
	    }
	    else
	    {
		goto dvuma;
	    }
	dvs1e:
	    // 0ca dvs1e
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_alub = reg_aluo;
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(high16(reg_at), 0x0000);
	    inst_cycle = 44;
	}
	break;
	case 44:
	{
	    inst_cycle = 45;
	}
	break;
	case 45:
	{
	    if (reg_t)
	    {
		goto dvum4;
	    }
	    else
	    {
		goto dvs1c;
	    }
	leaa2:
	    // 066 leaa2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 35;
	}
	break;
	case 35:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvum4:
	    // 2d1 dvum4
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    goto dvuma;
	dvs1c:
	    // 251 dvs1c
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg16High(reg_at, reg_aluo);
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    goto leaa2;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 81d8 f1f8
void m68kDivsWordAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 0ac dvs01
	    reg_alub = reg_dbin;
	    reg_alue = reg_da[rx_index];
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 0c9 dvs03
	    reg_t = (reg_isr & SrZero) ? 2 : (reg_isr & SrSign) ? 1 : 0;
	    aluSub(reg_alub, 0x0000);
	    updateNZVC();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (reg_t == 0)
	    {
		goto dvs04;
	    }
	    else if (reg_t == 1)
	    {
		goto dvs05;
	    }
	    else
	    {
		goto dvur2;
	    }
	dvs04:
	    // 0a3 dvs04
	    setReg16Low(reg_at, high16(reg_da[rx_index]));
	    reg_au = merge32(0, reg_ftu) + 1;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    goto dvs06;
	dvs05:
	    // 063 dvs05
	    reg_alub = reg_aluo;
	    setReg16Low(reg_at, high16(reg_da[rx_index]));
	    reg_au = merge32(0, reg_ftu) + 1;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 52;
	}
	break;
	case 52:
	{
	    inst_cycle = 53;
	}
	break;
	case 53:
	{
	    goto dvs06;
	dvur2:
	    // 0e3 dvur2
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 54;
	}
	break;
	case 54:
	{
	    inst_cycle = 55;
	}
	break;
	case 55:
	{
	    // 217 dvur3
	    initST();
	    reg_pc = reg_au;
	    aluAnd(reg_au, 0xFFFF);
	    reg_au = reg_da[16] - 2;
	    inst_cycle = 56;
	}
	break;
	case 56:
	{
	    inst_cycle = 57;
	}
	break;
	case 57:
	{
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 58;
	}
	break;
	case 58:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x05);
	    reg_da[16] = reg_au;
	    reg_ftu = 0x0014;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 59;
	}
	break;
	case 59:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 60;
	}
	break;
	case 60:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 61;
	}
	break;
	case 61:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 62;
	}
	break;
	case 62:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 63;
	}
	break;
	case 63:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 64;
	}
	break;
	case 64:
	{
	    inst_cycle = 65;
	}
	break;
	case 65:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 66;
	}
	break;
	case 66:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvs06:
	    // 176 dvs06
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    aluSub(reg_da[rx_index], 0x0000);
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (reg_t)
	    {
		goto dvs10;
	    }
	    else
	    {
		goto dvs07;
	    }
	dvs07:
	    // 042 dvs07
	    aluSub(reg_alub, reg_at);
	    updateNZVC();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    goto dvs08;
	dvs10:
	    // 0c2 dvs10
	    reg_alue = reg_aluo;
	    aluSubc(high16(reg_da[rx_index]), 0x0000);
	    inst_cycle = 48;
	}
	break;
	case 48:
	{
	    inst_cycle = 49;
	}
	break;
	case 49:
	{
	    // 177 dvs11
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 50;
	}
	break;
	case 50:
	{
	    inst_cycle = 51;
	}
	break;
	case 51:
	{
	    goto dvs08;
	dvs08:
	    // 216 dvs08
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    if (reg_t)
	    {
		goto dvs09;
	    }
	    else
	    {
		goto dvumz;
	    }
	dvumz:
	    // 2d5 dvumz
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    goto dvuma;
	dvs09:
	    // 295 dvs09
	    reg_au = reg_au - 1;
	    aluSla0(reg_aluo);
	    inst_cycle = 15;
	}
	break;
	case 15:
	{
	    inst_cycle = 16;
	}
	break;
	case 16:
	{
	    goto dvs0c;
	dvuma:
	    // 0e6 dvuma
	    reg_ird = reg_ir;
	    setIntState();
	    aluOver(0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 14;
	}
	break;
	case 14:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvs0c:
	    // 2d6 dvs0c
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 17;
	}
	break;
	case 17:
	{
	    inst_cycle = 18;
	}
	break;
	case 18:
	{
	    if (reg_t)
	    {
		goto dvs0e;
	    }
	    else
	    {
		goto dvs0d;
	    }
	dvs0d:
	    // 3ed dvs0d
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    inst_cycle = 19;
	}
	break;
	case 19:
	{
	    inst_cycle = 20;
	}
	break;
	case 20:
	{
	    if (reg_t)
	    {
		goto dvs0f;
	    }
	    else
	    {
		goto dvs0a;
	    }
	dvs0e:
	    // 32d dvs0e
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    inst_cycle = 25;
	}
	break;
	case 25:
	{
	    inst_cycle = 26;
	}
	break;
	case 26:
	{
	    if (reg_t)
	    {
		goto dvs12;
	    }
	    else
	    {
		goto dvs13;
	    }
	dvs0a:
	    // 2d4 dvs0a
	    reg_au = reg_au - 1;
	    aluSla1(reg_aluo);
	    inst_cycle = 21;
	}
	break;
	case 21:
	{
	    inst_cycle = 22;
	}
	break;
	case 22:
	{
	    goto dvs0c;
	dvs0f:
	    // 294 dvs0f
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 23;
	}
	break;
	case 23:
	{
	    inst_cycle = 24;
	}
	break;
	case 24:
	{
	    goto dvs09;
	dvs13:
	    // 254 dvs13
	    setReg16Low(reg_at, reg_aluo);
	    aluSla1(reg_aluo);
	    inst_cycle = 27;
	}
	break;
	case 27:
	{
	    inst_cycle = 28;
	}
	break;
	case 28:
	{
	    goto dvs14;
	dvs12:
	    // 214 dvs12
	    reg_au = reg_au - 1;
	    aluSla0(reg_aluo);
	    inst_cycle = 46;
	}
	break;
	case 46:
	{
	    inst_cycle = 47;
	}
	break;
	case 47:
	{
	    goto dvs14;
	dvs14:
	    // 210 dvs14
	    aluAnd(high16(reg_at), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 29;
	}
	break;
	case 29:
	{
	    inst_cycle = 30;
	}
	break;
	case 30:
	{
	    // 211 dvs15
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_alub = reg_alue;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 31;
	}
	break;
	case 31:
	{
	    inst_cycle = 32;
	}
	break;
	case 32:
	{
	    if (reg_t)
	    {
		goto dvs1d;
	    }
	    else
	    {
		goto dvs16;
	    }
	dvs16:
	    // 041 dvs16
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    setReg16High(reg_at, reg_at);
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 33;
	}
	break;
	case 33:
	{
	    inst_cycle = 34;
	}
	break;
	case 34:
	{
	    if (reg_t)
	    {
		goto dvs1a;
	    }
	    else
	    {
		goto dvs17;
	    }
	dvs1d:
	    // 0c1 dvs1d
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    setReg16High(reg_at, reg_at);
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 40;
	}
	break;
	case 40:
	{
	    inst_cycle = 41;
	}
	break;
	case 41:
	{
	    if (reg_t)
	    {
		goto dvs1e;
	    }
	    else
	    {
		goto dvs1f;
	    }
	dvs17:
	    // 04d dvs17
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_pc + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVC();
	    if (reg_t)
	    {
		goto dvuma;
	    }
	    else
	    {
		goto leaa2;
	    }
	dvs1a:
	    // 0cd dvs1a
	    aluSub(reg_alub, 0x0000);
	    updateNZVC();
	    inst_cycle = 36;
	}
	break;
	case 36:
	{
	    inst_cycle = 37;
	}
	break;
	case 37:
	{
	    // 0ce dvs1b
	    reg_t = (reg_isr & (SrZero | SrSign)) ? 1 : 0;
	    reg_alub = reg_aluo;
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(high16(reg_at), 0x0000);
	    inst_cycle = 38;
	}
	break;
	case 38:
	{
	    inst_cycle = 39;
	}
	break;
	case 39:
	{
	    if (reg_t)
	    {
		goto dvs1c;
	    }
	    else
	    {
		goto dvum4;
	    }
	dvs1f:
	    // 08a dvs1f
	    reg_ir = reg_irc;
	    updateIPL();
	    aluSub(reg_alub, 0x0000);
	    updateNZVC();
	    inst_cycle = 42;
	}
	break;
	case 42:
	{
	    inst_cycle = 43;
	}
	break;
	case 43:
	{
	    // 049 dvs20
	    reg_aob = reg_pc;
	    reg_t = (reg_isr & (SrZero | SrSign)) ? 1 : 0;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_pc + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVC();
	    if (reg_t)
	    {
		goto leaa2;
	    }
	    else
	    {
		goto dvuma;
	    }
	dvs1e:
	    // 0ca dvs1e
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_alub = reg_aluo;
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(high16(reg_at), 0x0000);
	    inst_cycle = 44;
	}
	break;
	case 44:
	{
	    inst_cycle = 45;
	}
	break;
	case 45:
	{
	    if (reg_t)
	    {
		goto dvum4;
	    }
	    else
	    {
		goto dvs1c;
	    }
	leaa2:
	    // 066 leaa2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 35;
	}
	break;
	case 35:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvum4:
	    // 2d1 dvum4
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    goto dvuma;
	dvs1c:
	    // 251 dvs1c
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg16High(reg_at, reg_aluo);
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    goto leaa2;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 81e0 f1f8
void m68kDivsWordPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 0ac dvs01
	    reg_alub = reg_dbin;
	    reg_alue = reg_da[rx_index];
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 0c9 dvs03
	    reg_t = (reg_isr & SrZero) ? 2 : (reg_isr & SrSign) ? 1 : 0;
	    aluSub(reg_alub, 0x0000);
	    updateNZVC();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (reg_t == 0)
	    {
		goto dvs04;
	    }
	    else if (reg_t == 1)
	    {
		goto dvs05;
	    }
	    else
	    {
		goto dvur2;
	    }
	dvs04:
	    // 0a3 dvs04
	    setReg16Low(reg_at, high16(reg_da[rx_index]));
	    reg_au = merge32(0, reg_ftu) + 1;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    goto dvs06;
	dvs05:
	    // 063 dvs05
	    reg_alub = reg_aluo;
	    setReg16Low(reg_at, high16(reg_da[rx_index]));
	    reg_au = merge32(0, reg_ftu) + 1;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 53;
	}
	break;
	case 53:
	{
	    inst_cycle = 54;
	}
	break;
	case 54:
	{
	    goto dvs06;
	dvur2:
	    // 0e3 dvur2
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 55;
	}
	break;
	case 55:
	{
	    inst_cycle = 56;
	}
	break;
	case 56:
	{
	    // 217 dvur3
	    initST();
	    reg_pc = reg_au;
	    aluAnd(reg_au, 0xFFFF);
	    reg_au = reg_da[16] - 2;
	    inst_cycle = 57;
	}
	break;
	case 57:
	{
	    inst_cycle = 58;
	}
	break;
	case 58:
	{
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 59;
	}
	break;
	case 59:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x05);
	    reg_da[16] = reg_au;
	    reg_ftu = 0x0014;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 60;
	}
	break;
	case 60:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 61;
	}
	break;
	case 61:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 62;
	}
	break;
	case 62:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 63;
	}
	break;
	case 63:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 64;
	}
	break;
	case 64:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 65;
	}
	break;
	case 65:
	{
	    inst_cycle = 66;
	}
	break;
	case 66:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 67;
	}
	break;
	case 67:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvs06:
	    // 176 dvs06
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    aluSub(reg_da[rx_index], 0x0000);
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (reg_t)
	    {
		goto dvs10;
	    }
	    else
	    {
		goto dvs07;
	    }
	dvs07:
	    // 042 dvs07
	    aluSub(reg_alub, reg_at);
	    updateNZVC();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    goto dvs08;
	dvs10:
	    // 0c2 dvs10
	    reg_alue = reg_aluo;
	    aluSubc(high16(reg_da[rx_index]), 0x0000);
	    inst_cycle = 49;
	}
	break;
	case 49:
	{
	    inst_cycle = 50;
	}
	break;
	case 50:
	{
	    // 177 dvs11
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 51;
	}
	break;
	case 51:
	{
	    inst_cycle = 52;
	}
	break;
	case 52:
	{
	    goto dvs08;
	dvs08:
	    // 216 dvs08
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    inst_cycle = 14;
	}
	break;
	case 14:
	{
	    if (reg_t)
	    {
		goto dvs09;
	    }
	    else
	    {
		goto dvumz;
	    }
	dvumz:
	    // 2d5 dvumz
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    goto dvuma;
	dvs09:
	    // 295 dvs09
	    reg_au = reg_au - 1;
	    aluSla0(reg_aluo);
	    inst_cycle = 16;
	}
	break;
	case 16:
	{
	    inst_cycle = 17;
	}
	break;
	case 17:
	{
	    goto dvs0c;
	dvuma:
	    // 0e6 dvuma
	    reg_ird = reg_ir;
	    setIntState();
	    aluOver(0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 15;
	}
	break;
	case 15:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvs0c:
	    // 2d6 dvs0c
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 18;
	}
	break;
	case 18:
	{
	    inst_cycle = 19;
	}
	break;
	case 19:
	{
	    if (reg_t)
	    {
		goto dvs0e;
	    }
	    else
	    {
		goto dvs0d;
	    }
	dvs0d:
	    // 3ed dvs0d
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    inst_cycle = 20;
	}
	break;
	case 20:
	{
	    inst_cycle = 21;
	}
	break;
	case 21:
	{
	    if (reg_t)
	    {
		goto dvs0f;
	    }
	    else
	    {
		goto dvs0a;
	    }
	dvs0e:
	    // 32d dvs0e
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    inst_cycle = 26;
	}
	break;
	case 26:
	{
	    inst_cycle = 27;
	}
	break;
	case 27:
	{
	    if (reg_t)
	    {
		goto dvs12;
	    }
	    else
	    {
		goto dvs13;
	    }
	dvs0a:
	    // 2d4 dvs0a
	    reg_au = reg_au - 1;
	    aluSla1(reg_aluo);
	    inst_cycle = 22;
	}
	break;
	case 22:
	{
	    inst_cycle = 23;
	}
	break;
	case 23:
	{
	    goto dvs0c;
	dvs0f:
	    // 294 dvs0f
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 24;
	}
	break;
	case 24:
	{
	    inst_cycle = 25;
	}
	break;
	case 25:
	{
	    goto dvs09;
	dvs13:
	    // 254 dvs13
	    setReg16Low(reg_at, reg_aluo);
	    aluSla1(reg_aluo);
	    inst_cycle = 28;
	}
	break;
	case 28:
	{
	    inst_cycle = 29;
	}
	break;
	case 29:
	{
	    goto dvs14;
	dvs12:
	    // 214 dvs12
	    reg_au = reg_au - 1;
	    aluSla0(reg_aluo);
	    inst_cycle = 47;
	}
	break;
	case 47:
	{
	    inst_cycle = 48;
	}
	break;
	case 48:
	{
	    goto dvs14;
	dvs14:
	    // 210 dvs14
	    aluAnd(high16(reg_at), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 30;
	}
	break;
	case 30:
	{
	    inst_cycle = 31;
	}
	break;
	case 31:
	{
	    // 211 dvs15
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_alub = reg_alue;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 32;
	}
	break;
	case 32:
	{
	    inst_cycle = 33;
	}
	break;
	case 33:
	{
	    if (reg_t)
	    {
		goto dvs1d;
	    }
	    else
	    {
		goto dvs16;
	    }
	dvs16:
	    // 041 dvs16
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    setReg16High(reg_at, reg_at);
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 34;
	}
	break;
	case 34:
	{
	    inst_cycle = 35;
	}
	break;
	case 35:
	{
	    if (reg_t)
	    {
		goto dvs1a;
	    }
	    else
	    {
		goto dvs17;
	    }
	dvs1d:
	    // 0c1 dvs1d
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    setReg16High(reg_at, reg_at);
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 41;
	}
	break;
	case 41:
	{
	    inst_cycle = 42;
	}
	break;
	case 42:
	{
	    if (reg_t)
	    {
		goto dvs1e;
	    }
	    else
	    {
		goto dvs1f;
	    }
	dvs17:
	    // 04d dvs17
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_pc + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVC();
	    if (reg_t)
	    {
		goto dvuma;
	    }
	    else
	    {
		goto leaa2;
	    }
	dvs1a:
	    // 0cd dvs1a
	    aluSub(reg_alub, 0x0000);
	    updateNZVC();
	    inst_cycle = 37;
	}
	break;
	case 37:
	{
	    inst_cycle = 38;
	}
	break;
	case 38:
	{
	    // 0ce dvs1b
	    reg_t = (reg_isr & (SrZero | SrSign)) ? 1 : 0;
	    reg_alub = reg_aluo;
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(high16(reg_at), 0x0000);
	    inst_cycle = 39;
	}
	break;
	case 39:
	{
	    inst_cycle = 40;
	}
	break;
	case 40:
	{
	    if (reg_t)
	    {
		goto dvs1c;
	    }
	    else
	    {
		goto dvum4;
	    }
	dvs1f:
	    // 08a dvs1f
	    reg_ir = reg_irc;
	    updateIPL();
	    aluSub(reg_alub, 0x0000);
	    updateNZVC();
	    inst_cycle = 43;
	}
	break;
	case 43:
	{
	    inst_cycle = 44;
	}
	break;
	case 44:
	{
	    // 049 dvs20
	    reg_aob = reg_pc;
	    reg_t = (reg_isr & (SrZero | SrSign)) ? 1 : 0;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_pc + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVC();
	    if (reg_t)
	    {
		goto leaa2;
	    }
	    else
	    {
		goto dvuma;
	    }
	dvs1e:
	    // 0ca dvs1e
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_alub = reg_aluo;
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(high16(reg_at), 0x0000);
	    inst_cycle = 45;
	}
	break;
	case 45:
	{
	    inst_cycle = 46;
	}
	break;
	case 46:
	{
	    if (reg_t)
	    {
		goto dvum4;
	    }
	    else
	    {
		goto dvs1c;
	    }
	leaa2:
	    // 066 leaa2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 36;
	}
	break;
	case 36:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvum4:
	    // 2d1 dvum4
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    goto dvuma;
	dvs1c:
	    // 251 dvs1c
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg16High(reg_at, reg_aluo);
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    goto leaa2;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 81e8 f1f8
void m68kDivsWordDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 0ac dvs01
	    reg_alub = reg_dbin;
	    reg_alue = reg_da[rx_index];
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 0c9 dvs03
	    reg_t = (reg_isr & SrZero) ? 2 : (reg_isr & SrSign) ? 1 : 0;
	    aluSub(reg_alub, 0x0000);
	    updateNZVC();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (reg_t == 0)
	    {
		goto dvs04;
	    }
	    else if (reg_t == 1)
	    {
		goto dvs05;
	    }
	    else
	    {
		goto dvur2;
	    }
	dvs04:
	    // 0a3 dvs04
	    setReg16Low(reg_at, high16(reg_da[rx_index]));
	    reg_au = merge32(0, reg_ftu) + 1;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    goto dvs06;
	dvs05:
	    // 063 dvs05
	    reg_alub = reg_aluo;
	    setReg16Low(reg_at, high16(reg_da[rx_index]));
	    reg_au = merge32(0, reg_ftu) + 1;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 53;
	}
	break;
	case 53:
	{
	    inst_cycle = 54;
	}
	break;
	case 54:
	{
	    goto dvs06;
	dvur2:
	    // 0e3 dvur2
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 55;
	}
	break;
	case 55:
	{
	    inst_cycle = 56;
	}
	break;
	case 56:
	{
	    // 217 dvur3
	    initST();
	    reg_pc = reg_au;
	    aluAnd(reg_au, 0xFFFF);
	    reg_au = reg_da[16] - 2;
	    inst_cycle = 57;
	}
	break;
	case 57:
	{
	    inst_cycle = 58;
	}
	break;
	case 58:
	{
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 59;
	}
	break;
	case 59:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x05);
	    reg_da[16] = reg_au;
	    reg_ftu = 0x0014;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 60;
	}
	break;
	case 60:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 61;
	}
	break;
	case 61:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 62;
	}
	break;
	case 62:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 63;
	}
	break;
	case 63:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 64;
	}
	break;
	case 64:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 65;
	}
	break;
	case 65:
	{
	    inst_cycle = 66;
	}
	break;
	case 66:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 67;
	}
	break;
	case 67:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvs06:
	    // 176 dvs06
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    aluSub(reg_da[rx_index], 0x0000);
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (reg_t)
	    {
		goto dvs10;
	    }
	    else
	    {
		goto dvs07;
	    }
	dvs07:
	    // 042 dvs07
	    aluSub(reg_alub, reg_at);
	    updateNZVC();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    goto dvs08;
	dvs10:
	    // 0c2 dvs10
	    reg_alue = reg_aluo;
	    aluSubc(high16(reg_da[rx_index]), 0x0000);
	    inst_cycle = 49;
	}
	break;
	case 49:
	{
	    inst_cycle = 50;
	}
	break;
	case 50:
	{
	    // 177 dvs11
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 51;
	}
	break;
	case 51:
	{
	    inst_cycle = 52;
	}
	break;
	case 52:
	{
	    goto dvs08;
	dvs08:
	    // 216 dvs08
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    inst_cycle = 14;
	}
	break;
	case 14:
	{
	    if (reg_t)
	    {
		goto dvs09;
	    }
	    else
	    {
		goto dvumz;
	    }
	dvumz:
	    // 2d5 dvumz
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    goto dvuma;
	dvs09:
	    // 295 dvs09
	    reg_au = reg_au - 1;
	    aluSla0(reg_aluo);
	    inst_cycle = 16;
	}
	break;
	case 16:
	{
	    inst_cycle = 17;
	}
	break;
	case 17:
	{
	    goto dvs0c;
	dvuma:
	    // 0e6 dvuma
	    reg_ird = reg_ir;
	    setIntState();
	    aluOver(0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 15;
	}
	break;
	case 15:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvs0c:
	    // 2d6 dvs0c
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 18;
	}
	break;
	case 18:
	{
	    inst_cycle = 19;
	}
	break;
	case 19:
	{
	    if (reg_t)
	    {
		goto dvs0e;
	    }
	    else
	    {
		goto dvs0d;
	    }
	dvs0d:
	    // 3ed dvs0d
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    inst_cycle = 20;
	}
	break;
	case 20:
	{
	    inst_cycle = 21;
	}
	break;
	case 21:
	{
	    if (reg_t)
	    {
		goto dvs0f;
	    }
	    else
	    {
		goto dvs0a;
	    }
	dvs0e:
	    // 32d dvs0e
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    inst_cycle = 26;
	}
	break;
	case 26:
	{
	    inst_cycle = 27;
	}
	break;
	case 27:
	{
	    if (reg_t)
	    {
		goto dvs12;
	    }
	    else
	    {
		goto dvs13;
	    }
	dvs0a:
	    // 2d4 dvs0a
	    reg_au = reg_au - 1;
	    aluSla1(reg_aluo);
	    inst_cycle = 22;
	}
	break;
	case 22:
	{
	    inst_cycle = 23;
	}
	break;
	case 23:
	{
	    goto dvs0c;
	dvs0f:
	    // 294 dvs0f
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 24;
	}
	break;
	case 24:
	{
	    inst_cycle = 25;
	}
	break;
	case 25:
	{
	    goto dvs09;
	dvs13:
	    // 254 dvs13
	    setReg16Low(reg_at, reg_aluo);
	    aluSla1(reg_aluo);
	    inst_cycle = 28;
	}
	break;
	case 28:
	{
	    inst_cycle = 29;
	}
	break;
	case 29:
	{
	    goto dvs14;
	dvs12:
	    // 214 dvs12
	    reg_au = reg_au - 1;
	    aluSla0(reg_aluo);
	    inst_cycle = 47;
	}
	break;
	case 47:
	{
	    inst_cycle = 48;
	}
	break;
	case 48:
	{
	    goto dvs14;
	dvs14:
	    // 210 dvs14
	    aluAnd(high16(reg_at), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 30;
	}
	break;
	case 30:
	{
	    inst_cycle = 31;
	}
	break;
	case 31:
	{
	    // 211 dvs15
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_alub = reg_alue;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 32;
	}
	break;
	case 32:
	{
	    inst_cycle = 33;
	}
	break;
	case 33:
	{
	    if (reg_t)
	    {
		goto dvs1d;
	    }
	    else
	    {
		goto dvs16;
	    }
	dvs16:
	    // 041 dvs16
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    setReg16High(reg_at, reg_at);
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 34;
	}
	break;
	case 34:
	{
	    inst_cycle = 35;
	}
	break;
	case 35:
	{
	    if (reg_t)
	    {
		goto dvs1a;
	    }
	    else
	    {
		goto dvs17;
	    }
	dvs1d:
	    // 0c1 dvs1d
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    setReg16High(reg_at, reg_at);
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 41;
	}
	break;
	case 41:
	{
	    inst_cycle = 42;
	}
	break;
	case 42:
	{
	    if (reg_t)
	    {
		goto dvs1e;
	    }
	    else
	    {
		goto dvs1f;
	    }
	dvs17:
	    // 04d dvs17
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_pc + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVC();
	    if (reg_t)
	    {
		goto dvuma;
	    }
	    else
	    {
		goto leaa2;
	    }
	dvs1a:
	    // 0cd dvs1a
	    aluSub(reg_alub, 0x0000);
	    updateNZVC();
	    inst_cycle = 37;
	}
	break;
	case 37:
	{
	    inst_cycle = 38;
	}
	break;
	case 38:
	{
	    // 0ce dvs1b
	    reg_t = (reg_isr & (SrZero | SrSign)) ? 1 : 0;
	    reg_alub = reg_aluo;
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(high16(reg_at), 0x0000);
	    inst_cycle = 39;
	}
	break;
	case 39:
	{
	    inst_cycle = 40;
	}
	break;
	case 40:
	{
	    if (reg_t)
	    {
		goto dvs1c;
	    }
	    else
	    {
		goto dvum4;
	    }
	dvs1f:
	    // 08a dvs1f
	    reg_ir = reg_irc;
	    updateIPL();
	    aluSub(reg_alub, 0x0000);
	    updateNZVC();
	    inst_cycle = 43;
	}
	break;
	case 43:
	{
	    inst_cycle = 44;
	}
	break;
	case 44:
	{
	    // 049 dvs20
	    reg_aob = reg_pc;
	    reg_t = (reg_isr & (SrZero | SrSign)) ? 1 : 0;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_pc + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVC();
	    if (reg_t)
	    {
		goto leaa2;
	    }
	    else
	    {
		goto dvuma;
	    }
	dvs1e:
	    // 0ca dvs1e
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_alub = reg_aluo;
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(high16(reg_at), 0x0000);
	    inst_cycle = 45;
	}
	break;
	case 45:
	{
	    inst_cycle = 46;
	}
	break;
	case 46:
	{
	    if (reg_t)
	    {
		goto dvum4;
	    }
	    else
	    {
		goto dvs1c;
	    }
	leaa2:
	    // 066 leaa2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 36;
	}
	break;
	case 36:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvum4:
	    // 2d1 dvum4
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    goto dvuma;
	dvs1c:
	    // 251 dvs1c
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg16High(reg_at, reg_aluo);
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    goto leaa2;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 81f0 f1f8
void m68kDivsWordDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluOver(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 69;
	}
	break;
	case 69:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 0ac dvs01
	    reg_alub = reg_dbin;
	    reg_alue = reg_da[rx_index];
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 0c9 dvs03
	    reg_t = (reg_isr & SrZero) ? 2 : (reg_isr & SrSign) ? 1 : 0;
	    aluSub(reg_alub, 0x0000);
	    updateNZVC();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (reg_t == 0)
	    {
		goto dvs04;
	    }
	    else if (reg_t == 1)
	    {
		goto dvs05;
	    }
	    else
	    {
		goto dvur2;
	    }
	dvs04:
	    // 0a3 dvs04
	    setReg16Low(reg_at, high16(reg_da[rx_index]));
	    reg_au = merge32(0, reg_ftu) + 1;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    goto dvs06;
	dvs05:
	    // 063 dvs05
	    reg_alub = reg_aluo;
	    setReg16Low(reg_at, high16(reg_da[rx_index]));
	    reg_au = merge32(0, reg_ftu) + 1;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 54;
	}
	break;
	case 54:
	{
	    inst_cycle = 55;
	}
	break;
	case 55:
	{
	    goto dvs06;
	dvur2:
	    // 0e3 dvur2
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 56;
	}
	break;
	case 56:
	{
	    inst_cycle = 57;
	}
	break;
	case 57:
	{
	    // 217 dvur3
	    initST();
	    reg_pc = reg_au;
	    aluAnd(reg_au, 0xFFFF);
	    reg_au = reg_da[16] - 2;
	    inst_cycle = 58;
	}
	break;
	case 58:
	{
	    inst_cycle = 59;
	}
	break;
	case 59:
	{
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 60;
	}
	break;
	case 60:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x05);
	    reg_da[16] = reg_au;
	    reg_ftu = 0x0014;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 61;
	}
	break;
	case 61:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 62;
	}
	break;
	case 62:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 63;
	}
	break;
	case 63:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 64;
	}
	break;
	case 64:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 65;
	}
	break;
	case 65:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 66;
	}
	break;
	case 66:
	{
	    inst_cycle = 67;
	}
	break;
	case 67:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 68;
	}
	break;
	case 68:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvs06:
	    // 176 dvs06
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    aluSub(reg_da[rx_index], 0x0000);
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    if (reg_t)
	    {
		goto dvs10;
	    }
	    else
	    {
		goto dvs07;
	    }
	dvs07:
	    // 042 dvs07
	    aluSub(reg_alub, reg_at);
	    updateNZVC();
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    goto dvs08;
	dvs10:
	    // 0c2 dvs10
	    reg_alue = reg_aluo;
	    aluSubc(high16(reg_da[rx_index]), 0x0000);
	    inst_cycle = 50;
	}
	break;
	case 50:
	{
	    inst_cycle = 51;
	}
	break;
	case 51:
	{
	    // 177 dvs11
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 52;
	}
	break;
	case 52:
	{
	    inst_cycle = 53;
	}
	break;
	case 53:
	{
	    goto dvs08;
	dvs08:
	    // 216 dvs08
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 14;
	}
	break;
	case 14:
	{
	    inst_cycle = 15;
	}
	break;
	case 15:
	{
	    if (reg_t)
	    {
		goto dvs09;
	    }
	    else
	    {
		goto dvumz;
	    }
	dvumz:
	    // 2d5 dvumz
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    goto dvuma;
	dvs09:
	    // 295 dvs09
	    reg_au = reg_au - 1;
	    aluSla0(reg_aluo);
	    inst_cycle = 17;
	}
	break;
	case 17:
	{
	    inst_cycle = 18;
	}
	break;
	case 18:
	{
	    goto dvs0c;
	dvuma:
	    // 0e6 dvuma
	    reg_ird = reg_ir;
	    setIntState();
	    aluOver(0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 16;
	}
	break;
	case 16:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvs0c:
	    // 2d6 dvs0c
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 19;
	}
	break;
	case 19:
	{
	    inst_cycle = 20;
	}
	break;
	case 20:
	{
	    if (reg_t)
	    {
		goto dvs0e;
	    }
	    else
	    {
		goto dvs0d;
	    }
	dvs0d:
	    // 3ed dvs0d
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    inst_cycle = 21;
	}
	break;
	case 21:
	{
	    inst_cycle = 22;
	}
	break;
	case 22:
	{
	    if (reg_t)
	    {
		goto dvs0f;
	    }
	    else
	    {
		goto dvs0a;
	    }
	dvs0e:
	    // 32d dvs0e
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    inst_cycle = 27;
	}
	break;
	case 27:
	{
	    inst_cycle = 28;
	}
	break;
	case 28:
	{
	    if (reg_t)
	    {
		goto dvs12;
	    }
	    else
	    {
		goto dvs13;
	    }
	dvs0a:
	    // 2d4 dvs0a
	    reg_au = reg_au - 1;
	    aluSla1(reg_aluo);
	    inst_cycle = 23;
	}
	break;
	case 23:
	{
	    inst_cycle = 24;
	}
	break;
	case 24:
	{
	    goto dvs0c;
	dvs0f:
	    // 294 dvs0f
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 25;
	}
	break;
	case 25:
	{
	    inst_cycle = 26;
	}
	break;
	case 26:
	{
	    goto dvs09;
	dvs13:
	    // 254 dvs13
	    setReg16Low(reg_at, reg_aluo);
	    aluSla1(reg_aluo);
	    inst_cycle = 29;
	}
	break;
	case 29:
	{
	    inst_cycle = 30;
	}
	break;
	case 30:
	{
	    goto dvs14;
	dvs12:
	    // 214 dvs12
	    reg_au = reg_au - 1;
	    aluSla0(reg_aluo);
	    inst_cycle = 48;
	}
	break;
	case 48:
	{
	    inst_cycle = 49;
	}
	break;
	case 49:
	{
	    goto dvs14;
	dvs14:
	    // 210 dvs14
	    aluAnd(high16(reg_at), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 31;
	}
	break;
	case 31:
	{
	    inst_cycle = 32;
	}
	break;
	case 32:
	{
	    // 211 dvs15
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_alub = reg_alue;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 33;
	}
	break;
	case 33:
	{
	    inst_cycle = 34;
	}
	break;
	case 34:
	{
	    if (reg_t)
	    {
		goto dvs1d;
	    }
	    else
	    {
		goto dvs16;
	    }
	dvs16:
	    // 041 dvs16
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    setReg16High(reg_at, reg_at);
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 35;
	}
	break;
	case 35:
	{
	    inst_cycle = 36;
	}
	break;
	case 36:
	{
	    if (reg_t)
	    {
		goto dvs1a;
	    }
	    else
	    {
		goto dvs17;
	    }
	dvs1d:
	    // 0c1 dvs1d
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    setReg16High(reg_at, reg_at);
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 42;
	}
	break;
	case 42:
	{
	    inst_cycle = 43;
	}
	break;
	case 43:
	{
	    if (reg_t)
	    {
		goto dvs1e;
	    }
	    else
	    {
		goto dvs1f;
	    }
	dvs17:
	    // 04d dvs17
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_pc + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVC();
	    if (reg_t)
	    {
		goto dvuma;
	    }
	    else
	    {
		goto leaa2;
	    }
	dvs1a:
	    // 0cd dvs1a
	    aluSub(reg_alub, 0x0000);
	    updateNZVC();
	    inst_cycle = 38;
	}
	break;
	case 38:
	{
	    inst_cycle = 39;
	}
	break;
	case 39:
	{
	    // 0ce dvs1b
	    reg_t = (reg_isr & (SrZero | SrSign)) ? 1 : 0;
	    reg_alub = reg_aluo;
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(high16(reg_at), 0x0000);
	    inst_cycle = 40;
	}
	break;
	case 40:
	{
	    inst_cycle = 41;
	}
	break;
	case 41:
	{
	    if (reg_t)
	    {
		goto dvs1c;
	    }
	    else
	    {
		goto dvum4;
	    }
	dvs1f:
	    // 08a dvs1f
	    reg_ir = reg_irc;
	    updateIPL();
	    aluSub(reg_alub, 0x0000);
	    updateNZVC();
	    inst_cycle = 44;
	}
	break;
	case 44:
	{
	    inst_cycle = 45;
	}
	break;
	case 45:
	{
	    // 049 dvs20
	    reg_aob = reg_pc;
	    reg_t = (reg_isr & (SrZero | SrSign)) ? 1 : 0;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_pc + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVC();
	    if (reg_t)
	    {
		goto leaa2;
	    }
	    else
	    {
		goto dvuma;
	    }
	dvs1e:
	    // 0ca dvs1e
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_alub = reg_aluo;
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(high16(reg_at), 0x0000);
	    inst_cycle = 46;
	}
	break;
	case 46:
	{
	    inst_cycle = 47;
	}
	break;
	case 47:
	{
	    if (reg_t)
	    {
		goto dvum4;
	    }
	    else
	    {
		goto dvs1c;
	    }
	leaa2:
	    // 066 leaa2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 37;
	}
	break;
	case 37:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvum4:
	    // 2d1 dvum4
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    goto dvuma;
	dvs1c:
	    // 251 dvs1c
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg16High(reg_at, reg_aluo);
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    goto leaa2;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 81f8 f1ff
void m68kDivsWordAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 0ac dvs01
	    reg_alub = reg_dbin;
	    reg_alue = reg_da[rx_index];
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 0c9 dvs03
	    reg_t = (reg_isr & SrZero) ? 2 : (reg_isr & SrSign) ? 1 : 0;
	    aluSub(reg_alub, 0x0000);
	    updateNZVC();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (reg_t == 0)
	    {
		goto dvs04;
	    }
	    else if (reg_t == 1)
	    {
		goto dvs05;
	    }
	    else
	    {
		goto dvur2;
	    }
	dvs04:
	    // 0a3 dvs04
	    setReg16Low(reg_at, high16(reg_da[rx_index]));
	    reg_au = merge32(0, reg_ftu) + 1;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    goto dvs06;
	dvs05:
	    // 063 dvs05
	    reg_alub = reg_aluo;
	    setReg16Low(reg_at, high16(reg_da[rx_index]));
	    reg_au = merge32(0, reg_ftu) + 1;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 53;
	}
	break;
	case 53:
	{
	    inst_cycle = 54;
	}
	break;
	case 54:
	{
	    goto dvs06;
	dvur2:
	    // 0e3 dvur2
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 55;
	}
	break;
	case 55:
	{
	    inst_cycle = 56;
	}
	break;
	case 56:
	{
	    // 217 dvur3
	    initST();
	    reg_pc = reg_au;
	    aluAnd(reg_au, 0xFFFF);
	    reg_au = reg_da[16] - 2;
	    inst_cycle = 57;
	}
	break;
	case 57:
	{
	    inst_cycle = 58;
	}
	break;
	case 58:
	{
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 59;
	}
	break;
	case 59:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x05);
	    reg_da[16] = reg_au;
	    reg_ftu = 0x0014;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 60;
	}
	break;
	case 60:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 61;
	}
	break;
	case 61:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 62;
	}
	break;
	case 62:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 63;
	}
	break;
	case 63:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 64;
	}
	break;
	case 64:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 65;
	}
	break;
	case 65:
	{
	    inst_cycle = 66;
	}
	break;
	case 66:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 67;
	}
	break;
	case 67:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvs06:
	    // 176 dvs06
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    aluSub(reg_da[rx_index], 0x0000);
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (reg_t)
	    {
		goto dvs10;
	    }
	    else
	    {
		goto dvs07;
	    }
	dvs07:
	    // 042 dvs07
	    aluSub(reg_alub, reg_at);
	    updateNZVC();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    goto dvs08;
	dvs10:
	    // 0c2 dvs10
	    reg_alue = reg_aluo;
	    aluSubc(high16(reg_da[rx_index]), 0x0000);
	    inst_cycle = 49;
	}
	break;
	case 49:
	{
	    inst_cycle = 50;
	}
	break;
	case 50:
	{
	    // 177 dvs11
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 51;
	}
	break;
	case 51:
	{
	    inst_cycle = 52;
	}
	break;
	case 52:
	{
	    goto dvs08;
	dvs08:
	    // 216 dvs08
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    inst_cycle = 14;
	}
	break;
	case 14:
	{
	    if (reg_t)
	    {
		goto dvs09;
	    }
	    else
	    {
		goto dvumz;
	    }
	dvumz:
	    // 2d5 dvumz
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    goto dvuma;
	dvs09:
	    // 295 dvs09
	    reg_au = reg_au - 1;
	    aluSla0(reg_aluo);
	    inst_cycle = 16;
	}
	break;
	case 16:
	{
	    inst_cycle = 17;
	}
	break;
	case 17:
	{
	    goto dvs0c;
	dvuma:
	    // 0e6 dvuma
	    reg_ird = reg_ir;
	    setIntState();
	    aluOver(0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 15;
	}
	break;
	case 15:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvs0c:
	    // 2d6 dvs0c
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 18;
	}
	break;
	case 18:
	{
	    inst_cycle = 19;
	}
	break;
	case 19:
	{
	    if (reg_t)
	    {
		goto dvs0e;
	    }
	    else
	    {
		goto dvs0d;
	    }
	dvs0d:
	    // 3ed dvs0d
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    inst_cycle = 20;
	}
	break;
	case 20:
	{
	    inst_cycle = 21;
	}
	break;
	case 21:
	{
	    if (reg_t)
	    {
		goto dvs0f;
	    }
	    else
	    {
		goto dvs0a;
	    }
	dvs0e:
	    // 32d dvs0e
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    inst_cycle = 26;
	}
	break;
	case 26:
	{
	    inst_cycle = 27;
	}
	break;
	case 27:
	{
	    if (reg_t)
	    {
		goto dvs12;
	    }
	    else
	    {
		goto dvs13;
	    }
	dvs0a:
	    // 2d4 dvs0a
	    reg_au = reg_au - 1;
	    aluSla1(reg_aluo);
	    inst_cycle = 22;
	}
	break;
	case 22:
	{
	    inst_cycle = 23;
	}
	break;
	case 23:
	{
	    goto dvs0c;
	dvs0f:
	    // 294 dvs0f
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 24;
	}
	break;
	case 24:
	{
	    inst_cycle = 25;
	}
	break;
	case 25:
	{
	    goto dvs09;
	dvs13:
	    // 254 dvs13
	    setReg16Low(reg_at, reg_aluo);
	    aluSla1(reg_aluo);
	    inst_cycle = 28;
	}
	break;
	case 28:
	{
	    inst_cycle = 29;
	}
	break;
	case 29:
	{
	    goto dvs14;
	dvs12:
	    // 214 dvs12
	    reg_au = reg_au - 1;
	    aluSla0(reg_aluo);
	    inst_cycle = 47;
	}
	break;
	case 47:
	{
	    inst_cycle = 48;
	}
	break;
	case 48:
	{
	    goto dvs14;
	dvs14:
	    // 210 dvs14
	    aluAnd(high16(reg_at), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 30;
	}
	break;
	case 30:
	{
	    inst_cycle = 31;
	}
	break;
	case 31:
	{
	    // 211 dvs15
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_alub = reg_alue;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 32;
	}
	break;
	case 32:
	{
	    inst_cycle = 33;
	}
	break;
	case 33:
	{
	    if (reg_t)
	    {
		goto dvs1d;
	    }
	    else
	    {
		goto dvs16;
	    }
	dvs16:
	    // 041 dvs16
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    setReg16High(reg_at, reg_at);
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 34;
	}
	break;
	case 34:
	{
	    inst_cycle = 35;
	}
	break;
	case 35:
	{
	    if (reg_t)
	    {
		goto dvs1a;
	    }
	    else
	    {
		goto dvs17;
	    }
	dvs1d:
	    // 0c1 dvs1d
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    setReg16High(reg_at, reg_at);
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 41;
	}
	break;
	case 41:
	{
	    inst_cycle = 42;
	}
	break;
	case 42:
	{
	    if (reg_t)
	    {
		goto dvs1e;
	    }
	    else
	    {
		goto dvs1f;
	    }
	dvs17:
	    // 04d dvs17
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_pc + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVC();
	    if (reg_t)
	    {
		goto dvuma;
	    }
	    else
	    {
		goto leaa2;
	    }
	dvs1a:
	    // 0cd dvs1a
	    aluSub(reg_alub, 0x0000);
	    updateNZVC();
	    inst_cycle = 37;
	}
	break;
	case 37:
	{
	    inst_cycle = 38;
	}
	break;
	case 38:
	{
	    // 0ce dvs1b
	    reg_t = (reg_isr & (SrZero | SrSign)) ? 1 : 0;
	    reg_alub = reg_aluo;
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(high16(reg_at), 0x0000);
	    inst_cycle = 39;
	}
	break;
	case 39:
	{
	    inst_cycle = 40;
	}
	break;
	case 40:
	{
	    if (reg_t)
	    {
		goto dvs1c;
	    }
	    else
	    {
		goto dvum4;
	    }
	dvs1f:
	    // 08a dvs1f
	    reg_ir = reg_irc;
	    updateIPL();
	    aluSub(reg_alub, 0x0000);
	    updateNZVC();
	    inst_cycle = 43;
	}
	break;
	case 43:
	{
	    inst_cycle = 44;
	}
	break;
	case 44:
	{
	    // 049 dvs20
	    reg_aob = reg_pc;
	    reg_t = (reg_isr & (SrZero | SrSign)) ? 1 : 0;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_pc + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVC();
	    if (reg_t)
	    {
		goto leaa2;
	    }
	    else
	    {
		goto dvuma;
	    }
	dvs1e:
	    // 0ca dvs1e
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_alub = reg_aluo;
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(high16(reg_at), 0x0000);
	    inst_cycle = 45;
	}
	break;
	case 45:
	{
	    inst_cycle = 46;
	}
	break;
	case 46:
	{
	    if (reg_t)
	    {
		goto dvum4;
	    }
	    else
	    {
		goto dvs1c;
	    }
	leaa2:
	    // 066 leaa2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 36;
	}
	break;
	case 36:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvum4:
	    // 2d1 dvum4
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    goto dvuma;
	dvs1c:
	    // 251 dvs1c
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg16High(reg_at, reg_aluo);
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    goto leaa2;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 81f9 f1ff
void m68kDivsWordAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 0ac dvs01
	    reg_alub = reg_dbin;
	    reg_alue = reg_da[rx_index];
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 0c9 dvs03
	    reg_t = (reg_isr & SrZero) ? 2 : (reg_isr & SrSign) ? 1 : 0;
	    aluSub(reg_alub, 0x0000);
	    updateNZVC();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (reg_t == 0)
	    {
		goto dvs04;
	    }
	    else if (reg_t == 1)
	    {
		goto dvs05;
	    }
	    else
	    {
		goto dvur2;
	    }
	dvs04:
	    // 0a3 dvs04
	    setReg16Low(reg_at, high16(reg_da[rx_index]));
	    reg_au = merge32(0, reg_ftu) + 1;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    goto dvs06;
	dvs05:
	    // 063 dvs05
	    reg_alub = reg_aluo;
	    setReg16Low(reg_at, high16(reg_da[rx_index]));
	    reg_au = merge32(0, reg_ftu) + 1;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 54;
	}
	break;
	case 54:
	{
	    inst_cycle = 55;
	}
	break;
	case 55:
	{
	    goto dvs06;
	dvur2:
	    // 0e3 dvur2
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 56;
	}
	break;
	case 56:
	{
	    inst_cycle = 57;
	}
	break;
	case 57:
	{
	    // 217 dvur3
	    initST();
	    reg_pc = reg_au;
	    aluAnd(reg_au, 0xFFFF);
	    reg_au = reg_da[16] - 2;
	    inst_cycle = 58;
	}
	break;
	case 58:
	{
	    inst_cycle = 59;
	}
	break;
	case 59:
	{
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 60;
	}
	break;
	case 60:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x05);
	    reg_da[16] = reg_au;
	    reg_ftu = 0x0014;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 61;
	}
	break;
	case 61:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 62;
	}
	break;
	case 62:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 63;
	}
	break;
	case 63:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 64;
	}
	break;
	case 64:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 65;
	}
	break;
	case 65:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 66;
	}
	break;
	case 66:
	{
	    inst_cycle = 67;
	}
	break;
	case 67:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 68;
	}
	break;
	case 68:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvs06:
	    // 176 dvs06
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    aluSub(reg_da[rx_index], 0x0000);
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    if (reg_t)
	    {
		goto dvs10;
	    }
	    else
	    {
		goto dvs07;
	    }
	dvs07:
	    // 042 dvs07
	    aluSub(reg_alub, reg_at);
	    updateNZVC();
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    goto dvs08;
	dvs10:
	    // 0c2 dvs10
	    reg_alue = reg_aluo;
	    aluSubc(high16(reg_da[rx_index]), 0x0000);
	    inst_cycle = 50;
	}
	break;
	case 50:
	{
	    inst_cycle = 51;
	}
	break;
	case 51:
	{
	    // 177 dvs11
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 52;
	}
	break;
	case 52:
	{
	    inst_cycle = 53;
	}
	break;
	case 53:
	{
	    goto dvs08;
	dvs08:
	    // 216 dvs08
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 14;
	}
	break;
	case 14:
	{
	    inst_cycle = 15;
	}
	break;
	case 15:
	{
	    if (reg_t)
	    {
		goto dvs09;
	    }
	    else
	    {
		goto dvumz;
	    }
	dvumz:
	    // 2d5 dvumz
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    goto dvuma;
	dvs09:
	    // 295 dvs09
	    reg_au = reg_au - 1;
	    aluSla0(reg_aluo);
	    inst_cycle = 17;
	}
	break;
	case 17:
	{
	    inst_cycle = 18;
	}
	break;
	case 18:
	{
	    goto dvs0c;
	dvuma:
	    // 0e6 dvuma
	    reg_ird = reg_ir;
	    setIntState();
	    aluOver(0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 16;
	}
	break;
	case 16:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvs0c:
	    // 2d6 dvs0c
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 19;
	}
	break;
	case 19:
	{
	    inst_cycle = 20;
	}
	break;
	case 20:
	{
	    if (reg_t)
	    {
		goto dvs0e;
	    }
	    else
	    {
		goto dvs0d;
	    }
	dvs0d:
	    // 3ed dvs0d
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    inst_cycle = 21;
	}
	break;
	case 21:
	{
	    inst_cycle = 22;
	}
	break;
	case 22:
	{
	    if (reg_t)
	    {
		goto dvs0f;
	    }
	    else
	    {
		goto dvs0a;
	    }
	dvs0e:
	    // 32d dvs0e
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    inst_cycle = 27;
	}
	break;
	case 27:
	{
	    inst_cycle = 28;
	}
	break;
	case 28:
	{
	    if (reg_t)
	    {
		goto dvs12;
	    }
	    else
	    {
		goto dvs13;
	    }
	dvs0a:
	    // 2d4 dvs0a
	    reg_au = reg_au - 1;
	    aluSla1(reg_aluo);
	    inst_cycle = 23;
	}
	break;
	case 23:
	{
	    inst_cycle = 24;
	}
	break;
	case 24:
	{
	    goto dvs0c;
	dvs0f:
	    // 294 dvs0f
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 25;
	}
	break;
	case 25:
	{
	    inst_cycle = 26;
	}
	break;
	case 26:
	{
	    goto dvs09;
	dvs13:
	    // 254 dvs13
	    setReg16Low(reg_at, reg_aluo);
	    aluSla1(reg_aluo);
	    inst_cycle = 29;
	}
	break;
	case 29:
	{
	    inst_cycle = 30;
	}
	break;
	case 30:
	{
	    goto dvs14;
	dvs12:
	    // 214 dvs12
	    reg_au = reg_au - 1;
	    aluSla0(reg_aluo);
	    inst_cycle = 48;
	}
	break;
	case 48:
	{
	    inst_cycle = 49;
	}
	break;
	case 49:
	{
	    goto dvs14;
	dvs14:
	    // 210 dvs14
	    aluAnd(high16(reg_at), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 31;
	}
	break;
	case 31:
	{
	    inst_cycle = 32;
	}
	break;
	case 32:
	{
	    // 211 dvs15
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_alub = reg_alue;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 33;
	}
	break;
	case 33:
	{
	    inst_cycle = 34;
	}
	break;
	case 34:
	{
	    if (reg_t)
	    {
		goto dvs1d;
	    }
	    else
	    {
		goto dvs16;
	    }
	dvs16:
	    // 041 dvs16
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    setReg16High(reg_at, reg_at);
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 35;
	}
	break;
	case 35:
	{
	    inst_cycle = 36;
	}
	break;
	case 36:
	{
	    if (reg_t)
	    {
		goto dvs1a;
	    }
	    else
	    {
		goto dvs17;
	    }
	dvs1d:
	    // 0c1 dvs1d
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    setReg16High(reg_at, reg_at);
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 42;
	}
	break;
	case 42:
	{
	    inst_cycle = 43;
	}
	break;
	case 43:
	{
	    if (reg_t)
	    {
		goto dvs1e;
	    }
	    else
	    {
		goto dvs1f;
	    }
	dvs17:
	    // 04d dvs17
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_pc + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVC();
	    if (reg_t)
	    {
		goto dvuma;
	    }
	    else
	    {
		goto leaa2;
	    }
	dvs1a:
	    // 0cd dvs1a
	    aluSub(reg_alub, 0x0000);
	    updateNZVC();
	    inst_cycle = 38;
	}
	break;
	case 38:
	{
	    inst_cycle = 39;
	}
	break;
	case 39:
	{
	    // 0ce dvs1b
	    reg_t = (reg_isr & (SrZero | SrSign)) ? 1 : 0;
	    reg_alub = reg_aluo;
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(high16(reg_at), 0x0000);
	    inst_cycle = 40;
	}
	break;
	case 40:
	{
	    inst_cycle = 41;
	}
	break;
	case 41:
	{
	    if (reg_t)
	    {
		goto dvs1c;
	    }
	    else
	    {
		goto dvum4;
	    }
	dvs1f:
	    // 08a dvs1f
	    reg_ir = reg_irc;
	    updateIPL();
	    aluSub(reg_alub, 0x0000);
	    updateNZVC();
	    inst_cycle = 44;
	}
	break;
	case 44:
	{
	    inst_cycle = 45;
	}
	break;
	case 45:
	{
	    // 049 dvs20
	    reg_aob = reg_pc;
	    reg_t = (reg_isr & (SrZero | SrSign)) ? 1 : 0;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_pc + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVC();
	    if (reg_t)
	    {
		goto leaa2;
	    }
	    else
	    {
		goto dvuma;
	    }
	dvs1e:
	    // 0ca dvs1e
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_alub = reg_aluo;
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(high16(reg_at), 0x0000);
	    inst_cycle = 46;
	}
	break;
	case 46:
	{
	    inst_cycle = 47;
	}
	break;
	case 47:
	{
	    if (reg_t)
	    {
		goto dvum4;
	    }
	    else
	    {
		goto dvs1c;
	    }
	leaa2:
	    // 066 leaa2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 37;
	}
	break;
	case 37:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvum4:
	    // 2d1 dvum4
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    goto dvuma;
	dvs1c:
	    // 251 dvs1c
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg16High(reg_at, reg_aluo);
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    goto leaa2;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 81fa f1ff
void m68kDivsWordDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 0ac dvs01
	    reg_alub = reg_dbin;
	    reg_alue = reg_da[rx_index];
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 0c9 dvs03
	    reg_t = (reg_isr & SrZero) ? 2 : (reg_isr & SrSign) ? 1 : 0;
	    aluSub(reg_alub, 0x0000);
	    updateNZVC();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (reg_t == 0)
	    {
		goto dvs04;
	    }
	    else if (reg_t == 1)
	    {
		goto dvs05;
	    }
	    else
	    {
		goto dvur2;
	    }
	dvs04:
	    // 0a3 dvs04
	    setReg16Low(reg_at, high16(reg_da[rx_index]));
	    reg_au = merge32(0, reg_ftu) + 1;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    goto dvs06;
	dvs05:
	    // 063 dvs05
	    reg_alub = reg_aluo;
	    setReg16Low(reg_at, high16(reg_da[rx_index]));
	    reg_au = merge32(0, reg_ftu) + 1;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 53;
	}
	break;
	case 53:
	{
	    inst_cycle = 54;
	}
	break;
	case 54:
	{
	    goto dvs06;
	dvur2:
	    // 0e3 dvur2
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 55;
	}
	break;
	case 55:
	{
	    inst_cycle = 56;
	}
	break;
	case 56:
	{
	    // 217 dvur3
	    initST();
	    reg_pc = reg_au;
	    aluAnd(reg_au, 0xFFFF);
	    reg_au = reg_da[16] - 2;
	    inst_cycle = 57;
	}
	break;
	case 57:
	{
	    inst_cycle = 58;
	}
	break;
	case 58:
	{
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 59;
	}
	break;
	case 59:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x05);
	    reg_da[16] = reg_au;
	    reg_ftu = 0x0014;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 60;
	}
	break;
	case 60:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 61;
	}
	break;
	case 61:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 62;
	}
	break;
	case 62:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 63;
	}
	break;
	case 63:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 64;
	}
	break;
	case 64:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 65;
	}
	break;
	case 65:
	{
	    inst_cycle = 66;
	}
	break;
	case 66:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 67;
	}
	break;
	case 67:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvs06:
	    // 176 dvs06
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    aluSub(reg_da[rx_index], 0x0000);
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    if (reg_t)
	    {
		goto dvs10;
	    }
	    else
	    {
		goto dvs07;
	    }
	dvs07:
	    // 042 dvs07
	    aluSub(reg_alub, reg_at);
	    updateNZVC();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    goto dvs08;
	dvs10:
	    // 0c2 dvs10
	    reg_alue = reg_aluo;
	    aluSubc(high16(reg_da[rx_index]), 0x0000);
	    inst_cycle = 49;
	}
	break;
	case 49:
	{
	    inst_cycle = 50;
	}
	break;
	case 50:
	{
	    // 177 dvs11
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 51;
	}
	break;
	case 51:
	{
	    inst_cycle = 52;
	}
	break;
	case 52:
	{
	    goto dvs08;
	dvs08:
	    // 216 dvs08
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    inst_cycle = 14;
	}
	break;
	case 14:
	{
	    if (reg_t)
	    {
		goto dvs09;
	    }
	    else
	    {
		goto dvumz;
	    }
	dvumz:
	    // 2d5 dvumz
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    goto dvuma;
	dvs09:
	    // 295 dvs09
	    reg_au = reg_au - 1;
	    aluSla0(reg_aluo);
	    inst_cycle = 16;
	}
	break;
	case 16:
	{
	    inst_cycle = 17;
	}
	break;
	case 17:
	{
	    goto dvs0c;
	dvuma:
	    // 0e6 dvuma
	    reg_ird = reg_ir;
	    setIntState();
	    aluOver(0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 15;
	}
	break;
	case 15:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvs0c:
	    // 2d6 dvs0c
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 18;
	}
	break;
	case 18:
	{
	    inst_cycle = 19;
	}
	break;
	case 19:
	{
	    if (reg_t)
	    {
		goto dvs0e;
	    }
	    else
	    {
		goto dvs0d;
	    }
	dvs0d:
	    // 3ed dvs0d
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    inst_cycle = 20;
	}
	break;
	case 20:
	{
	    inst_cycle = 21;
	}
	break;
	case 21:
	{
	    if (reg_t)
	    {
		goto dvs0f;
	    }
	    else
	    {
		goto dvs0a;
	    }
	dvs0e:
	    // 32d dvs0e
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    inst_cycle = 26;
	}
	break;
	case 26:
	{
	    inst_cycle = 27;
	}
	break;
	case 27:
	{
	    if (reg_t)
	    {
		goto dvs12;
	    }
	    else
	    {
		goto dvs13;
	    }
	dvs0a:
	    // 2d4 dvs0a
	    reg_au = reg_au - 1;
	    aluSla1(reg_aluo);
	    inst_cycle = 22;
	}
	break;
	case 22:
	{
	    inst_cycle = 23;
	}
	break;
	case 23:
	{
	    goto dvs0c;
	dvs0f:
	    // 294 dvs0f
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 24;
	}
	break;
	case 24:
	{
	    inst_cycle = 25;
	}
	break;
	case 25:
	{
	    goto dvs09;
	dvs13:
	    // 254 dvs13
	    setReg16Low(reg_at, reg_aluo);
	    aluSla1(reg_aluo);
	    inst_cycle = 28;
	}
	break;
	case 28:
	{
	    inst_cycle = 29;
	}
	break;
	case 29:
	{
	    goto dvs14;
	dvs12:
	    // 214 dvs12
	    reg_au = reg_au - 1;
	    aluSla0(reg_aluo);
	    inst_cycle = 47;
	}
	break;
	case 47:
	{
	    inst_cycle = 48;
	}
	break;
	case 48:
	{
	    goto dvs14;
	dvs14:
	    // 210 dvs14
	    aluAnd(high16(reg_at), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 30;
	}
	break;
	case 30:
	{
	    inst_cycle = 31;
	}
	break;
	case 31:
	{
	    // 211 dvs15
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_alub = reg_alue;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 32;
	}
	break;
	case 32:
	{
	    inst_cycle = 33;
	}
	break;
	case 33:
	{
	    if (reg_t)
	    {
		goto dvs1d;
	    }
	    else
	    {
		goto dvs16;
	    }
	dvs16:
	    // 041 dvs16
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    setReg16High(reg_at, reg_at);
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 34;
	}
	break;
	case 34:
	{
	    inst_cycle = 35;
	}
	break;
	case 35:
	{
	    if (reg_t)
	    {
		goto dvs1a;
	    }
	    else
	    {
		goto dvs17;
	    }
	dvs1d:
	    // 0c1 dvs1d
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    setReg16High(reg_at, reg_at);
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 41;
	}
	break;
	case 41:
	{
	    inst_cycle = 42;
	}
	break;
	case 42:
	{
	    if (reg_t)
	    {
		goto dvs1e;
	    }
	    else
	    {
		goto dvs1f;
	    }
	dvs17:
	    // 04d dvs17
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_pc + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVC();
	    if (reg_t)
	    {
		goto dvuma;
	    }
	    else
	    {
		goto leaa2;
	    }
	dvs1a:
	    // 0cd dvs1a
	    aluSub(reg_alub, 0x0000);
	    updateNZVC();
	    inst_cycle = 37;
	}
	break;
	case 37:
	{
	    inst_cycle = 38;
	}
	break;
	case 38:
	{
	    // 0ce dvs1b
	    reg_t = (reg_isr & (SrZero | SrSign)) ? 1 : 0;
	    reg_alub = reg_aluo;
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(high16(reg_at), 0x0000);
	    inst_cycle = 39;
	}
	break;
	case 39:
	{
	    inst_cycle = 40;
	}
	break;
	case 40:
	{
	    if (reg_t)
	    {
		goto dvs1c;
	    }
	    else
	    {
		goto dvum4;
	    }
	dvs1f:
	    // 08a dvs1f
	    reg_ir = reg_irc;
	    updateIPL();
	    aluSub(reg_alub, 0x0000);
	    updateNZVC();
	    inst_cycle = 43;
	}
	break;
	case 43:
	{
	    inst_cycle = 44;
	}
	break;
	case 44:
	{
	    // 049 dvs20
	    reg_aob = reg_pc;
	    reg_t = (reg_isr & (SrZero | SrSign)) ? 1 : 0;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_pc + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVC();
	    if (reg_t)
	    {
		goto leaa2;
	    }
	    else
	    {
		goto dvuma;
	    }
	dvs1e:
	    // 0ca dvs1e
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_alub = reg_aluo;
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(high16(reg_at), 0x0000);
	    inst_cycle = 45;
	}
	break;
	case 45:
	{
	    inst_cycle = 46;
	}
	break;
	case 46:
	{
	    if (reg_t)
	    {
		goto dvum4;
	    }
	    else
	    {
		goto dvs1c;
	    }
	leaa2:
	    // 066 leaa2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 36;
	}
	break;
	case 36:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvum4:
	    // 2d1 dvum4
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    goto dvuma;
	dvs1c:
	    // 251 dvs1c
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg16High(reg_at, reg_aluo);
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    goto leaa2;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 81fb f1ff
void m68kDivsWordDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluOver(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 69;
	}
	break;
	case 69:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 0ac dvs01
	    reg_alub = reg_dbin;
	    reg_alue = reg_da[rx_index];
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 0c9 dvs03
	    reg_t = (reg_isr & SrZero) ? 2 : (reg_isr & SrSign) ? 1 : 0;
	    aluSub(reg_alub, 0x0000);
	    updateNZVC();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (reg_t == 0)
	    {
		goto dvs04;
	    }
	    else if (reg_t == 1)
	    {
		goto dvs05;
	    }
	    else
	    {
		goto dvur2;
	    }
	dvs04:
	    // 0a3 dvs04
	    setReg16Low(reg_at, high16(reg_da[rx_index]));
	    reg_au = merge32(0, reg_ftu) + 1;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    goto dvs06;
	dvs05:
	    // 063 dvs05
	    reg_alub = reg_aluo;
	    setReg16Low(reg_at, high16(reg_da[rx_index]));
	    reg_au = merge32(0, reg_ftu) + 1;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 54;
	}
	break;
	case 54:
	{
	    inst_cycle = 55;
	}
	break;
	case 55:
	{
	    goto dvs06;
	dvur2:
	    // 0e3 dvur2
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 56;
	}
	break;
	case 56:
	{
	    inst_cycle = 57;
	}
	break;
	case 57:
	{
	    // 217 dvur3
	    initST();
	    reg_pc = reg_au;
	    aluAnd(reg_au, 0xFFFF);
	    reg_au = reg_da[16] - 2;
	    inst_cycle = 58;
	}
	break;
	case 58:
	{
	    inst_cycle = 59;
	}
	break;
	case 59:
	{
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 60;
	}
	break;
	case 60:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x05);
	    reg_da[16] = reg_au;
	    reg_ftu = 0x0014;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 61;
	}
	break;
	case 61:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 62;
	}
	break;
	case 62:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 63;
	}
	break;
	case 63:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 64;
	}
	break;
	case 64:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 65;
	}
	break;
	case 65:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 66;
	}
	break;
	case 66:
	{
	    inst_cycle = 67;
	}
	break;
	case 67:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 68;
	}
	break;
	case 68:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvs06:
	    // 176 dvs06
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    aluSub(reg_da[rx_index], 0x0000);
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    if (reg_t)
	    {
		goto dvs10;
	    }
	    else
	    {
		goto dvs07;
	    }
	dvs07:
	    // 042 dvs07
	    aluSub(reg_alub, reg_at);
	    updateNZVC();
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    goto dvs08;
	dvs10:
	    // 0c2 dvs10
	    reg_alue = reg_aluo;
	    aluSubc(high16(reg_da[rx_index]), 0x0000);
	    inst_cycle = 50;
	}
	break;
	case 50:
	{
	    inst_cycle = 51;
	}
	break;
	case 51:
	{
	    // 177 dvs11
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 52;
	}
	break;
	case 52:
	{
	    inst_cycle = 53;
	}
	break;
	case 53:
	{
	    goto dvs08;
	dvs08:
	    // 216 dvs08
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 14;
	}
	break;
	case 14:
	{
	    inst_cycle = 15;
	}
	break;
	case 15:
	{
	    if (reg_t)
	    {
		goto dvs09;
	    }
	    else
	    {
		goto dvumz;
	    }
	dvumz:
	    // 2d5 dvumz
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    goto dvuma;
	dvs09:
	    // 295 dvs09
	    reg_au = reg_au - 1;
	    aluSla0(reg_aluo);
	    inst_cycle = 17;
	}
	break;
	case 17:
	{
	    inst_cycle = 18;
	}
	break;
	case 18:
	{
	    goto dvs0c;
	dvuma:
	    // 0e6 dvuma
	    reg_ird = reg_ir;
	    setIntState();
	    aluOver(0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 16;
	}
	break;
	case 16:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvs0c:
	    // 2d6 dvs0c
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 19;
	}
	break;
	case 19:
	{
	    inst_cycle = 20;
	}
	break;
	case 20:
	{
	    if (reg_t)
	    {
		goto dvs0e;
	    }
	    else
	    {
		goto dvs0d;
	    }
	dvs0d:
	    // 3ed dvs0d
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    inst_cycle = 21;
	}
	break;
	case 21:
	{
	    inst_cycle = 22;
	}
	break;
	case 22:
	{
	    if (reg_t)
	    {
		goto dvs0f;
	    }
	    else
	    {
		goto dvs0a;
	    }
	dvs0e:
	    // 32d dvs0e
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    inst_cycle = 27;
	}
	break;
	case 27:
	{
	    inst_cycle = 28;
	}
	break;
	case 28:
	{
	    if (reg_t)
	    {
		goto dvs12;
	    }
	    else
	    {
		goto dvs13;
	    }
	dvs0a:
	    // 2d4 dvs0a
	    reg_au = reg_au - 1;
	    aluSla1(reg_aluo);
	    inst_cycle = 23;
	}
	break;
	case 23:
	{
	    inst_cycle = 24;
	}
	break;
	case 24:
	{
	    goto dvs0c;
	dvs0f:
	    // 294 dvs0f
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 25;
	}
	break;
	case 25:
	{
	    inst_cycle = 26;
	}
	break;
	case 26:
	{
	    goto dvs09;
	dvs13:
	    // 254 dvs13
	    setReg16Low(reg_at, reg_aluo);
	    aluSla1(reg_aluo);
	    inst_cycle = 29;
	}
	break;
	case 29:
	{
	    inst_cycle = 30;
	}
	break;
	case 30:
	{
	    goto dvs14;
	dvs12:
	    // 214 dvs12
	    reg_au = reg_au - 1;
	    aluSla0(reg_aluo);
	    inst_cycle = 48;
	}
	break;
	case 48:
	{
	    inst_cycle = 49;
	}
	break;
	case 49:
	{
	    goto dvs14;
	dvs14:
	    // 210 dvs14
	    aluAnd(high16(reg_at), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 31;
	}
	break;
	case 31:
	{
	    inst_cycle = 32;
	}
	break;
	case 32:
	{
	    // 211 dvs15
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_alub = reg_alue;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 33;
	}
	break;
	case 33:
	{
	    inst_cycle = 34;
	}
	break;
	case 34:
	{
	    if (reg_t)
	    {
		goto dvs1d;
	    }
	    else
	    {
		goto dvs16;
	    }
	dvs16:
	    // 041 dvs16
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    setReg16High(reg_at, reg_at);
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 35;
	}
	break;
	case 35:
	{
	    inst_cycle = 36;
	}
	break;
	case 36:
	{
	    if (reg_t)
	    {
		goto dvs1a;
	    }
	    else
	    {
		goto dvs17;
	    }
	dvs1d:
	    // 0c1 dvs1d
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    setReg16High(reg_at, reg_at);
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 42;
	}
	break;
	case 42:
	{
	    inst_cycle = 43;
	}
	break;
	case 43:
	{
	    if (reg_t)
	    {
		goto dvs1e;
	    }
	    else
	    {
		goto dvs1f;
	    }
	dvs17:
	    // 04d dvs17
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_pc + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVC();
	    if (reg_t)
	    {
		goto dvuma;
	    }
	    else
	    {
		goto leaa2;
	    }
	dvs1a:
	    // 0cd dvs1a
	    aluSub(reg_alub, 0x0000);
	    updateNZVC();
	    inst_cycle = 38;
	}
	break;
	case 38:
	{
	    inst_cycle = 39;
	}
	break;
	case 39:
	{
	    // 0ce dvs1b
	    reg_t = (reg_isr & (SrZero | SrSign)) ? 1 : 0;
	    reg_alub = reg_aluo;
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(high16(reg_at), 0x0000);
	    inst_cycle = 40;
	}
	break;
	case 40:
	{
	    inst_cycle = 41;
	}
	break;
	case 41:
	{
	    if (reg_t)
	    {
		goto dvs1c;
	    }
	    else
	    {
		goto dvum4;
	    }
	dvs1f:
	    // 08a dvs1f
	    reg_ir = reg_irc;
	    updateIPL();
	    aluSub(reg_alub, 0x0000);
	    updateNZVC();
	    inst_cycle = 44;
	}
	break;
	case 44:
	{
	    inst_cycle = 45;
	}
	break;
	case 45:
	{
	    // 049 dvs20
	    reg_aob = reg_pc;
	    reg_t = (reg_isr & (SrZero | SrSign)) ? 1 : 0;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_pc + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVC();
	    if (reg_t)
	    {
		goto leaa2;
	    }
	    else
	    {
		goto dvuma;
	    }
	dvs1e:
	    // 0ca dvs1e
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_alub = reg_aluo;
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(high16(reg_at), 0x0000);
	    inst_cycle = 46;
	}
	break;
	case 46:
	{
	    inst_cycle = 47;
	}
	break;
	case 47:
	{
	    if (reg_t)
	    {
		goto dvum4;
	    }
	    else
	    {
		goto dvs1c;
	    }
	leaa2:
	    // 066 leaa2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 37;
	}
	break;
	case 37:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvum4:
	    // 2d1 dvum4
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    goto dvuma;
	dvs1c:
	    // 251 dvs1c
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg16High(reg_at, reg_aluo);
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    goto leaa2;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 81fc f1ff
void m68kDivsWordImm16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 0ae dvs02
	    reg_alub = reg_dt;
	    reg_alue = reg_da[rx_index];
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dt);
	    aluAnd(reg_dt, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 0c9 dvs03
	    reg_t = (reg_isr & SrZero) ? 2 : (reg_isr & SrSign) ? 1 : 0;
	    aluSub(reg_alub, 0x0000);
	    updateNZVC();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (reg_t == 0)
	    {
		goto dvs04;
	    }
	    else if (reg_t == 1)
	    {
		goto dvs05;
	    }
	    else
	    {
		goto dvur2;
	    }
	dvs04:
	    // 0a3 dvs04
	    setReg16Low(reg_at, high16(reg_da[rx_index]));
	    reg_au = merge32(0, reg_ftu) + 1;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    goto dvs06;
	dvs05:
	    // 063 dvs05
	    reg_alub = reg_aluo;
	    setReg16Low(reg_at, high16(reg_da[rx_index]));
	    reg_au = merge32(0, reg_ftu) + 1;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 52;
	}
	break;
	case 52:
	{
	    inst_cycle = 53;
	}
	break;
	case 53:
	{
	    goto dvs06;
	dvur2:
	    // 0e3 dvur2
	    reg_ftu = reg_sr;
	    reg_au = reg_pc - 2;
	    inst_cycle = 54;
	}
	break;
	case 54:
	{
	    inst_cycle = 55;
	}
	break;
	case 55:
	{
	    // 217 dvur3
	    initST();
	    reg_pc = reg_au;
	    aluAnd(reg_au, 0xFFFF);
	    reg_au = reg_da[16] - 2;
	    inst_cycle = 56;
	}
	break;
	case 56:
	{
	    inst_cycle = 57;
	}
	break;
	case 57:
	{
	    // 3c2 trap3
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 4;
	    aluAnd(reg_ftu, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 58;
	}
	break;
	case 58:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 360 trap4
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    trapExcept(0x05);
	    reg_da[16] = reg_au;
	    reg_ftu = 0x0014;
	    reg_au = reg_au + 2;
	    aluAnd(high16(reg_pc), 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 59;
	}
	break;
	case 59:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 0ef trap5
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_at = ext32(reg_ftu);
	    reg_au = reg_au - 4;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 60;
	}
	break;
	case 60:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 367 trap6
	    reg_aob = reg_at;
	    reg_pc = reg_at;
	    reg_au = reg_at + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 61;
	}
	break;
	case 61:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 11a trap7
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 62;
	}
	break;
	case 62:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 2b7 trap8
	    reg_aob = merge32(high16(reg_at), reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin) + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 63;
	}
	break;
	case 63:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    // 11c trap9
	    inst_cycle = 64;
	}
	break;
	case 64:
	{
	    inst_cycle = 65;
	}
	break;
	case 65:
	{
	    // 363 b
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    // 34c mmrw3
	    reg_ird = reg_ir;
	    setIntState();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 66;
	}
	break;
	case 66:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvs06:
	    // 176 dvs06
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    aluSub(reg_da[rx_index], 0x0000);
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (reg_t)
	    {
		goto dvs10;
	    }
	    else
	    {
		goto dvs07;
	    }
	dvs07:
	    // 042 dvs07
	    aluSub(reg_alub, reg_at);
	    updateNZVC();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    goto dvs08;
	dvs10:
	    // 0c2 dvs10
	    reg_alue = reg_aluo;
	    aluSubc(high16(reg_da[rx_index]), 0x0000);
	    inst_cycle = 48;
	}
	break;
	case 48:
	{
	    inst_cycle = 49;
	}
	break;
	case 49:
	{
	    // 177 dvs11
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 50;
	}
	break;
	case 50:
	{
	    inst_cycle = 51;
	}
	break;
	case 51:
	{
	    goto dvs08;
	dvs08:
	    // 216 dvs08
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    if (reg_t)
	    {
		goto dvs09;
	    }
	    else
	    {
		goto dvumz;
	    }
	dvumz:
	    // 2d5 dvumz
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    goto dvuma;
	dvs09:
	    // 295 dvs09
	    reg_au = reg_au - 1;
	    aluSla0(reg_aluo);
	    inst_cycle = 15;
	}
	break;
	case 15:
	{
	    inst_cycle = 16;
	}
	break;
	case 16:
	{
	    goto dvs0c;
	dvuma:
	    // 0e6 dvuma
	    reg_ird = reg_ir;
	    setIntState();
	    aluOver(0x0000);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 14;
	}
	break;
	case 14:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvs0c:
	    // 2d6 dvs0c
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(reg_alub, reg_aluo);
	    updateNZVC();
	    inst_cycle = 17;
	}
	break;
	case 17:
	{
	    inst_cycle = 18;
	}
	break;
	case 18:
	{
	    if (reg_t)
	    {
		goto dvs0e;
	    }
	    else
	    {
		goto dvs0d;
	    }
	dvs0d:
	    // 3ed dvs0d
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    inst_cycle = 19;
	}
	break;
	case 19:
	{
	    inst_cycle = 20;
	}
	break;
	case 20:
	{
	    if (reg_t)
	    {
		goto dvs0f;
	    }
	    else
	    {
		goto dvs0a;
	    }
	dvs0e:
	    // 32d dvs0e
	    reg_t = (reg_isr & SrCarry) ? 1 : 0;
	    inst_cycle = 25;
	}
	break;
	case 25:
	{
	    inst_cycle = 26;
	}
	break;
	case 26:
	{
	    if (reg_t)
	    {
		goto dvs12;
	    }
	    else
	    {
		goto dvs13;
	    }
	dvs0a:
	    // 2d4 dvs0a
	    reg_au = reg_au - 1;
	    aluSla1(reg_aluo);
	    inst_cycle = 21;
	}
	break;
	case 21:
	{
	    inst_cycle = 22;
	}
	break;
	case 22:
	{
	    goto dvs0c;
	dvs0f:
	    // 294 dvs0f
	    aluAnd(reg_at, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 23;
	}
	break;
	case 23:
	{
	    inst_cycle = 24;
	}
	break;
	case 24:
	{
	    goto dvs09;
	dvs13:
	    // 254 dvs13
	    setReg16Low(reg_at, reg_aluo);
	    aluSla1(reg_aluo);
	    inst_cycle = 27;
	}
	break;
	case 27:
	{
	    inst_cycle = 28;
	}
	break;
	case 28:
	{
	    goto dvs14;
	dvs12:
	    // 214 dvs12
	    reg_au = reg_au - 1;
	    aluSla0(reg_aluo);
	    inst_cycle = 46;
	}
	break;
	case 46:
	{
	    inst_cycle = 47;
	}
	break;
	case 47:
	{
	    goto dvs14;
	dvs14:
	    // 210 dvs14
	    aluAnd(high16(reg_at), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 29;
	}
	break;
	case 29:
	{
	    inst_cycle = 30;
	}
	break;
	case 30:
	{
	    // 211 dvs15
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_alub = reg_alue;
	    aluAnd(high16(reg_da[rx_index]), 0xFFFF);
	    updateNZVC();
	    inst_cycle = 31;
	}
	break;
	case 31:
	{
	    inst_cycle = 32;
	}
	break;
	case 32:
	{
	    if (reg_t)
	    {
		goto dvs1d;
	    }
	    else
	    {
		goto dvs16;
	    }
	dvs16:
	    // 041 dvs16
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    setReg16High(reg_at, reg_at);
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 33;
	}
	break;
	case 33:
	{
	    inst_cycle = 34;
	}
	break;
	case 34:
	{
	    if (reg_t)
	    {
		goto dvs1a;
	    }
	    else
	    {
		goto dvs17;
	    }
	dvs1d:
	    // 0c1 dvs1d
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    setReg16High(reg_at, reg_at);
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    inst_cycle = 40;
	}
	break;
	case 40:
	{
	    inst_cycle = 41;
	}
	break;
	case 41:
	{
	    if (reg_t)
	    {
		goto dvs1e;
	    }
	    else
	    {
		goto dvs1f;
	    }
	dvs17:
	    // 04d dvs17
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_pc + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVC();
	    if (reg_t)
	    {
		goto dvuma;
	    }
	    else
	    {
		goto leaa2;
	    }
	dvs1a:
	    // 0cd dvs1a
	    aluSub(reg_alub, 0x0000);
	    updateNZVC();
	    inst_cycle = 36;
	}
	break;
	case 36:
	{
	    inst_cycle = 37;
	}
	break;
	case 37:
	{
	    // 0ce dvs1b
	    reg_t = (reg_isr & (SrZero | SrSign)) ? 1 : 0;
	    reg_alub = reg_aluo;
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(high16(reg_at), 0x0000);
	    inst_cycle = 38;
	}
	break;
	case 38:
	{
	    inst_cycle = 39;
	}
	break;
	case 39:
	{
	    if (reg_t)
	    {
		goto dvs1c;
	    }
	    else
	    {
		goto dvum4;
	    }
	dvs1f:
	    // 08a dvs1f
	    reg_ir = reg_irc;
	    updateIPL();
	    aluSub(reg_alub, 0x0000);
	    updateNZVC();
	    inst_cycle = 42;
	}
	break;
	case 42:
	{
	    inst_cycle = 43;
	}
	break;
	case 43:
	{
	    // 049 dvs20
	    reg_aob = reg_pc;
	    reg_t = (reg_isr & (SrZero | SrSign)) ? 1 : 0;
	    setReg16Low(reg_at, reg_aluo);
	    reg_au = reg_pc + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVC();
	    if (reg_t)
	    {
		goto leaa2;
	    }
	    else
	    {
		goto dvuma;
	    }
	dvs1e:
	    // 0ca dvs1e
	    reg_t = (reg_isr & SrSign) ? 1 : 0;
	    reg_alub = reg_aluo;
	    setReg16Low(reg_at, reg_aluo);
	    aluSub(high16(reg_at), 0x0000);
	    inst_cycle = 44;
	}
	break;
	case 44:
	{
	    inst_cycle = 45;
	}
	break;
	case 45:
	{
	    if (reg_t)
	    {
		goto dvum4;
	    }
	    else
	    {
		goto dvs1c;
	    }
	leaa2:
	    // 066 leaa2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_at;
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 35;
	}
	break;
	case 35:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	dvum4:
	    // 2d1 dvum4
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_pc + 2;
	    goto dvuma;
	dvs1c:
	    // 251 dvs1c
	    reg_aob = reg_pc;
	    reg_ir = reg_irc;
	    updateIPL();
	    setReg16High(reg_at, reg_aluo);
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZVC();
	    goto leaa2;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9000 f1f8
void m68kSubByteDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluSubByte(reg_da[ry_index], reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9010 f1f8
void m68kSubByteAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSubByte(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9018 f1f8
void m68kSubByteAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSubByte(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9020 f1f8
void m68kSubBytePaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSubByte(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9028 f1f8
void m68kSubByteDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSubByte(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9030 f1f8
void m68kSubByteDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSubByte(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9038 f1ff
void m68kSubByteAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSubByte(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9039 f1ff
void m68kSubByteAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSubByte(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 903a f1ff
void m68kSubByteDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSubByte(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 903b f1ff
void m68kSubByteDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSubByte(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 903c f1ff
void m68kSubByteImm8DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    aluSubByte(reg_dt, reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9040 f1f8
void m68kSubWordDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluSub(reg_da[ry_index], reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9048 f1f8
void m68kSubWordAsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluSub(reg_da[ry_index], reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9050 f1f8
void m68kSubWordAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9058 f1f8
void m68kSubWordAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9060 f1f8
void m68kSubWordPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9068 f1f8
void m68kSubWordDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9070 f1f8
void m68kSubWordDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9078 f1ff
void m68kSubWordAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9079 f1ff
void m68kSubWordAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 907a f1ff
void m68kSubWordDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 907b f1ff
void m68kSubWordDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 907c f1ff
void m68kSubWordImm16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    aluSub(reg_dt, reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9080 f1f8
void m68kSubLongDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluSub(reg_da[ry_index], reg_da[rx_index]);
	    updateXNZVC();
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    aluSubc(high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    updateXNZVCU();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9088 f1f8
void m68kSubLongAsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluSub(reg_da[ry_index], reg_da[rx_index]);
	    updateXNZVC();
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    aluSubc(high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    updateXNZVCU();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9090 f1f8
void m68kSubLongAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluSubc(reg_alub, high16(reg_da[rx_index]));
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9098 f1f8
void m68kSubLongAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluSubc(reg_alub, high16(reg_da[rx_index]));
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 90a0 f1f8
void m68kSubLongPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluSubc(reg_alub, high16(reg_da[rx_index]));
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 90a8 f1f8
void m68kSubLongDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluSubc(reg_alub, high16(reg_da[rx_index]));
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 90b0 f1f8
void m68kSubLongDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluSubc(reg_alub, high16(reg_da[rx_index]));
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 90b8 f1ff
void m68kSubLongAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluSubc(reg_alub, high16(reg_da[rx_index]));
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 90b9 f1ff
void m68kSubLongAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 00d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluSubc(reg_alub, high16(reg_da[rx_index]));
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 90ba f1ff
void m68kSubLongDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluSubc(reg_alub, high16(reg_da[rx_index]));
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 90bb f1ff
void m68kSubLongDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluSubc(reg_alub, high16(reg_da[rx_index]));
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 90bc f1ff
void m68kSubLongImm32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    aluSub(reg_dt, reg_da[rx_index]);
	    updateXNZVC();
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    aluSubc(high16(reg_dt), high16(reg_da[rx_index]));
	    updateXNZVCU();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 90c0 f1f8
void m68kSubaWordDsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c9 rorm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluSub(reg_da[ry_index], reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    aluSubc(high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 90c8 f1f8
void m68kSubaWordAsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c9 rorm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluSub(reg_da[ry_index], reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    aluSubc(high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 90d0 f1f8
void m68kSubaWordAisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    aluSubc(high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 90d8 f1f8
void m68kSubaWordAipsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    aluSubc(high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 90e0 f1f8
void m68kSubaWordPaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    aluSubc(high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 90e8 f1f8
void m68kSubaWordDasAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    aluSubc(high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 90f0 f1f8
void m68kSubaWordDaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    aluSubc(high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 90f8 f1ff
void m68kSubaWordAdr16AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    aluSubc(high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 90f9 f1ff
void m68kSubaWordAdr32AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    aluSubc(high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 90fa f1ff
void m68kSubaWordDpcAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    aluSubc(high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 90fb f1ff
void m68kSubaWordDpciAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    aluSubc(high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 90fc f1ff
void m68kSubaWordImm16AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c9 rorm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    aluSub(reg_dt, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    aluSubc(high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9100 f1f8
void m68kSubxByteDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluSubxByte(reg_da[ry_index], reg_da[rx_index]);
	    updateXNZVCU();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9108 f1f8
void m68kSubxBytePaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 10f asxw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 131 asxw2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 132 asxw3
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 04a asxw4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_at = reg_au;
	    reg_da[rx_index] = reg_au;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 065 asxw5
	    reg_aob = reg_pc;
	    reg_au = reg_at;
	    aluSubxByte(reg_alub, reg_dbin);
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9110 f1f8
void m68kSubByteDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubByte(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9118 f1f8
void m68kSubByteDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubByte(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9120 f1f8
void m68kSubByteDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubByte(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9128 f1f8
void m68kSubByteDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubByte(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9130 f1f8
void m68kSubByteDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubByte(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9138 f1ff
void m68kSubByteDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubByte(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9139 f1ff
void m68kSubByteDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSubByte(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9140 f1f8
void m68kSubxWordDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluSubx(reg_da[ry_index], reg_da[rx_index]);
	    updateXNZVCU();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9148 f1f8
void m68kSubxWordPaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 10f asxw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 131 asxw2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 132 asxw3
	    reg_au = reg_da[rx_index] - 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 04a asxw4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_at = reg_au;
	    reg_da[rx_index] = reg_au;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 065 asxw5
	    reg_aob = reg_pc;
	    reg_au = reg_at;
	    aluSubx(reg_alub, reg_dbin);
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9150 f1f8
void m68kSubWordDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9158 f1f8
void m68kSubWordDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9160 f1f8
void m68kSubWordDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9168 f1f8
void m68kSubWordDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9170 f1f8
void m68kSubWordDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9178 f1ff
void m68kSubWordDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9179 f1ff
void m68kSubWordDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9180 f1f8
void m68kSubxLongDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluSubx(reg_da[ry_index], reg_da[rx_index]);
	    updateXNZVCU();
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    aluSubc(high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    updateXNZVCU();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9188 f1f8
void m68kSubxLongPaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 10b asxl1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 048 asxl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_au = reg_au - 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 139 asxl3
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 13a asxl4
	    reg_au = reg_da[rx_index] - 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 04c asxl5
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_au = reg_au - 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 047 asxl6
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_au + 2;
	    aluSubx(reg_aluo, reg_dbin);
	    updateXNZVCU();
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 061 asxl7
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = ext32(reg_dbin);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 062 asxl8
	    reg_aob = reg_pc;
	    reg_au = reg_at;
	    aluSubc(reg_alub, reg_dbin);
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9190 f1f8
void m68kSubLongDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluSubc(high16(reg_da[rx_index]), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 9198 f1f8
void m68kSubLongDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluSubc(high16(reg_da[rx_index]), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 91a0 f1f8
void m68kSubLongDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluSubc(high16(reg_da[rx_index]), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 91a8 f1f8
void m68kSubLongDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluSubc(high16(reg_da[rx_index]), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 91b0 f1f8
void m68kSubLongDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluSubc(high16(reg_da[rx_index]), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 91b8 f1ff
void m68kSubLongDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluSubc(high16(reg_da[rx_index]), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 91b9 f1ff
void m68kSubLongDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 00d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluSub(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluSubc(high16(reg_da[rx_index]), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 91c0 f1f8
void m68kSubaLongDsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluSub(reg_da[ry_index], reg_da[rx_index]);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    aluSubc(high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 91c8 f1f8
void m68kSubaLongAsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluSub(reg_da[ry_index], reg_da[rx_index]);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    aluSubc(high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 91d0 f1f8
void m68kSubaLongAisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluSubc(reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 91d8 f1f8
void m68kSubaLongAipsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluSubc(reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 91e0 f1f8
void m68kSubaLongPaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluSubc(reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 91e8 f1f8
void m68kSubaLongDasAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluSubc(reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 91f0 f1f8
void m68kSubaLongDaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluSubc(reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 91f8 f1ff
void m68kSubaLongAdr16AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluSubc(reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 91f9 f1ff
void m68kSubaLongAdr32AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 00d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluSubc(reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 91fa f1ff
void m68kSubaLongDpcAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluSubc(reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 91fb f1ff
void m68kSubaLongDpciAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluSubc(reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// 91fc f1ff
void m68kSubaLongImm32AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    aluSub(reg_dt, reg_da[rx_index]);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    aluSubc(high16(reg_dt), high16(reg_da[rx_index]));
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b000 f1f8
void m68kCmpByteDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1d1 cprw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluSubByte(reg_da[ry_index], reg_da[rx_index]);
	    updateNZVC();
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b010 f1f8
void m68kCmpByteAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSubByte(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b018 f1f8
void m68kCmpByteAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSubByte(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b020 f1f8
void m68kCmpBytePaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSubByte(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b028 f1f8
void m68kCmpByteDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSubByte(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b030 f1f8
void m68kCmpByteDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSubByte(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b038 f1ff
void m68kCmpByteAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSubByte(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b039 f1ff
void m68kCmpByteAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSubByte(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b03a f1ff
void m68kCmpByteDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSubByte(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b03b f1ff
void m68kCmpByteDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSubByte(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b03c f1ff
void m68kCmpByteImm8DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1d1 cprw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    aluSubByte(reg_dt, reg_da[rx_index]);
	    updateNZVC();
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b040 f1f8
void m68kCmpWordDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1d1 cprw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluSub(reg_da[ry_index], reg_da[rx_index]);
	    updateNZVC();
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b048 f1f8
void m68kCmpWordAsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1d1 cprw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluSub(reg_da[ry_index], reg_da[rx_index]);
	    updateNZVC();
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b050 f1f8
void m68kCmpWordAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b058 f1f8
void m68kCmpWordAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b060 f1f8
void m68kCmpWordPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b068 f1f8
void m68kCmpWordDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b070 f1f8
void m68kCmpWordDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b078 f1ff
void m68kCmpWordAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b079 f1ff
void m68kCmpWordAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b07a f1ff
void m68kCmpWordDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b07b f1ff
void m68kCmpWordDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1d3 cpmw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b07c f1ff
void m68kCmpWordImm16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1d1 cprw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    aluSub(reg_dt, reg_da[rx_index]);
	    updateNZVC();
	    // 23a rcaw2
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b080 f1f8
void m68kCmpLongDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1d5 cprl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluSub(reg_da[ry_index], reg_da[rx_index]);
	    updateNZVC();
	    // 173 cprl2
	    aluSubc(high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 08d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b088 f1f8
void m68kCmpLongAsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1d5 cprl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluSub(reg_da[ry_index], reg_da[rx_index]);
	    updateNZVC();
	    // 173 cprl2
	    aluSubc(high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 08d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b090 f1f8
void m68kCmpLongAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 172 cpml2
	    aluSubc(reg_alub, high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 08d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b098 f1f8
void m68kCmpLongAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 172 cpml2
	    aluSubc(reg_alub, high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 08d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b0a0 f1f8
void m68kCmpLongPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 172 cpml2
	    aluSubc(reg_alub, high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 08d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b0a8 f1f8
void m68kCmpLongDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 172 cpml2
	    aluSubc(reg_alub, high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 08d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b0b0 f1f8
void m68kCmpLongDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 172 cpml2
	    aluSubc(reg_alub, high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 08d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b0b8 f1ff
void m68kCmpLongAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 172 cpml2
	    aluSubc(reg_alub, high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 08d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b0b9 f1ff
void m68kCmpLongAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 00d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 172 cpml2
	    aluSubc(reg_alub, high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 08d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b0ba f1ff
void m68kCmpLongDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 172 cpml2
	    aluSubc(reg_alub, high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 08d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b0bb f1ff
void m68kCmpLongDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 172 cpml2
	    aluSubc(reg_alub, high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 08d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b0bc f1ff
void m68kCmpLongImm32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1d5 cprl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    aluSub(reg_dt, reg_da[rx_index]);
	    updateNZVC();
	    // 173 cprl2
	    aluSubc(high16(reg_dt), high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 08d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b0c0 f1f8
void m68kCmpaWordDsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1d9 cprm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluSub(reg_da[ry_index], reg_da[rx_index]);
	    updateNZVC();
	    // 174 cprm2
	    aluSubc(high16(reg_at), high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 08d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b0c8 f1f8
void m68kCmpaWordAsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1d9 cprm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluSub(reg_da[ry_index], reg_da[rx_index]);
	    updateNZVC();
	    // 174 cprm2
	    aluSubc(high16(reg_at), high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 08d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b0d0 f1f8
void m68kCmpaWordAisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cf cpmm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 174 cprm2
	    aluSubc(high16(reg_at), high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 08d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b0d8 f1f8
void m68kCmpaWordAipsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cf cpmm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 174 cprm2
	    aluSubc(high16(reg_at), high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 08d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b0e0 f1f8
void m68kCmpaWordPaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cf cpmm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 174 cprm2
	    aluSubc(high16(reg_at), high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 08d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b0e8 f1f8
void m68kCmpaWordDasAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cf cpmm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 174 cprm2
	    aluSubc(high16(reg_at), high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 08d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b0f0 f1f8
void m68kCmpaWordDaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cf cpmm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 174 cprm2
	    aluSubc(high16(reg_at), high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 08d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b0f8 f1ff
void m68kCmpaWordAdr16AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cf cpmm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 174 cprm2
	    aluSubc(high16(reg_at), high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 08d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b0f9 f1ff
void m68kCmpaWordAdr32AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cf cpmm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 174 cprm2
	    aluSubc(high16(reg_at), high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 08d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b0fa f1ff
void m68kCmpaWordDpcAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cf cpmm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 174 cprm2
	    aluSubc(high16(reg_at), high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 08d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b0fb f1ff
void m68kCmpaWordDpciAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cf cpmm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 174 cprm2
	    aluSubc(high16(reg_at), high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 08d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b0fc f1ff
void m68kCmpaWordImm16AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1d9 cprm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    aluSub(reg_dt, reg_da[rx_index]);
	    updateNZVC();
	    // 174 cprm2
	    aluSubc(high16(reg_at), high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 08d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b100 f1f8
void m68kEorByteDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 100 roaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    aluXorByte(reg_da[rx_index], reg_da[ry_index]);
	    updateNZVC();
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b108 f1f8
void m68kCmpmByteAipsAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 06b cmmw1
	    reg_aob = reg_da[ry_index];
	    reg_pc = reg_au;
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    // 086 cmmw2
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 122 cmmw3
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_da[rx_index] + ((rx_index < 15) ? 1 : 2);
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 170 cmmw4
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluSubByte(reg_aluo, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b110 f1f8
void m68kEorByteDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXorByte(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b118 f1f8
void m68kEorByteDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    aluXorByte(reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXorByte(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b120 f1f8
void m68kEorByteDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    aluXorByte(reg_da[rx_index], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXorByte(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b128 f1f8
void m68kEorByteDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXorByte(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b130 f1f8
void m68kEorByteDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXorByte(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b138 f1ff
void m68kEorByteDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluXorByte(reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXorByte(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b139 f1ff
void m68kEorByteDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluXorByte(reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXorByte(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b140 f1f8
void m68kEorWordDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 100 roaw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    aluXor(reg_da[rx_index], reg_da[ry_index]);
	    updateNZVC();
	    // 08b roaw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b148 f1f8
void m68kCmpmWordAipsAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 06b cmmw1
	    reg_aob = reg_da[ry_index];
	    reg_pc = reg_au;
	    reg_au = reg_da[ry_index] + 2;
	    // 086 cmmw2
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 122 cmmw3
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 170 cmmw4
	    reg_aob = reg_pc;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluSub(reg_aluo, reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b150 f1f8
void m68kEorWordDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXor(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b158 f1f8
void m68kEorWordDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluXor(reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXor(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b160 f1f8
void m68kEorWordDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    aluXor(reg_da[rx_index], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXor(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b168 f1f8
void m68kEorWordDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXor(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b170 f1f8
void m68kEorWordDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXor(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b178 f1ff
void m68kEorWordDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluXor(reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXor(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b179 f1ff
void m68kEorWordDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluXor(reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXor(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b180 f1f8
void m68kEorLongDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 10c roal1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    aluXor(reg_da[rx_index], reg_da[ry_index]);
	    updateNZVC();
	    // 259 roal2
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25a roal3
	    aluXor(high16(reg_da[rx_index]), high16(reg_da[ry_index]));
	    updateNZVCU();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25b roal4
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b188 f1f8
void m68kCmpmLongAipsAipdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 06f cmml1
	    reg_aob = reg_da[ry_index];
	    reg_pc = reg_au;
	    reg_au = reg_da[ry_index] + 2;
	    // 08e cmml2
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 154 cmml3
	    reg_aob = reg_at;
	    reg_alub = reg_dbin;
	    reg_da[ry_index] = reg_au;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 12e cmml4
	    reg_aob = reg_da[rx_index];
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_au = reg_da[rx_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 155 cmml5
	    reg_aob = reg_au;
	    reg_alue = reg_dbin;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 156 cmml6
	    reg_aob = reg_pc;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluSub(reg_aluo, reg_dbin);
	    updateNZVC();
	    // 157 cmml7
	    reg_ird = reg_ir;
	    setIntState();
	    aluSubc(reg_alub, reg_alue);
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b190 f1f8
void m68kEorLongDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXor(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluXor(high16(reg_da[rx_index]), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b198 f1f8
void m68kEorLongDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXor(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluXor(high16(reg_da[rx_index]), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b1a0 f1f8
void m68kEorLongDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXor(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluXor(high16(reg_da[rx_index]), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b1a8 f1f8
void m68kEorLongDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXor(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluXor(high16(reg_da[rx_index]), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b1b0 f1f8
void m68kEorLongDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXor(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluXor(high16(reg_da[rx_index]), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b1b8 f1ff
void m68kEorLongDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluXor(reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXor(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluXor(high16(reg_da[rx_index]), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b1b9 f1ff
void m68kEorLongDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 00d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluXor(reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluXor(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluXor(high16(reg_da[rx_index]), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b1c0 f1f8
void m68kCmpaLongDsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1d5 cprl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluSub(reg_da[ry_index], reg_da[rx_index]);
	    updateNZVC();
	    // 173 cprl2
	    aluSubc(high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 08d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b1c8 f1f8
void m68kCmpaLongAsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1d5 cprl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluSub(reg_da[ry_index], reg_da[rx_index]);
	    updateNZVC();
	    // 173 cprl2
	    aluSubc(high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 08d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b1d0 f1f8
void m68kCmpaLongAisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 172 cpml2
	    aluSubc(reg_alub, high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 08d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b1d8 f1f8
void m68kCmpaLongAipsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 172 cpml2
	    aluSubc(reg_alub, high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 08d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b1e0 f1f8
void m68kCmpaLongPaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 172 cpml2
	    aluSubc(reg_alub, high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 08d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b1e8 f1f8
void m68kCmpaLongDasAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 172 cpml2
	    aluSubc(reg_alub, high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 08d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b1f0 f1f8
void m68kCmpaLongDaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 172 cpml2
	    aluSubc(reg_alub, high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 08d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b1f8 f1ff
void m68kCmpaLongAdr16AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 172 cpml2
	    aluSubc(reg_alub, high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 08d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b1f9 f1ff
void m68kCmpaLongAdr32AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 00d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 172 cpml2
	    aluSubc(reg_alub, high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 08d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b1fa f1ff
void m68kCmpaLongDpcAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 172 cpml2
	    aluSubc(reg_alub, high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 08d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b1fb f1ff
void m68kCmpaLongDpciAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1d7 cpml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluSub(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 172 cpml2
	    aluSubc(reg_alub, high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 08d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// b1fc f1ff
void m68kCmpaLongImm32AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1d5 cprl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    aluSub(reg_dt, reg_da[rx_index]);
	    updateNZVC();
	    // 173 cprl2
	    aluSubc(high16(reg_dt), high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 08d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c000 f1f8
void m68kAndByteDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluAndByte(reg_da[ry_index], reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c010 f1f8
void m68kAndByteAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAndByte(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c018 f1f8
void m68kAndByteAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    aluAndByte(reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAndByte(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c020 f1f8
void m68kAndBytePaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    aluAndByte(reg_da[rx_index], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAndByte(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c028 f1f8
void m68kAndByteDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAndByte(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c030 f1f8
void m68kAndByteDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAndByte(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c038 f1ff
void m68kAndByteAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluAndByte(reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAndByte(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c039 f1ff
void m68kAndByteAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluAndByte(reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAndByte(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c03a f1ff
void m68kAndByteDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAndByte(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c03b f1ff
void m68kAndByteDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAndByte(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c03c f1ff
void m68kAndByteImm8DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    aluAndByte(reg_dt, reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c040 f1f8
void m68kAndWordDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluAnd(reg_da[ry_index], reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c050 f1f8
void m68kAndWordAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAnd(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c058 f1f8
void m68kAndWordAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAnd(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c060 f1f8
void m68kAndWordPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    aluAnd(reg_da[rx_index], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAnd(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c068 f1f8
void m68kAndWordDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAnd(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c070 f1f8
void m68kAndWordDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAnd(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c078 f1ff
void m68kAndWordAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluAnd(reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAnd(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c079 f1ff
void m68kAndWordAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluAnd(reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAnd(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c07a f1ff
void m68kAndWordDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAnd(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c07b f1ff
void m68kAndWordDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAnd(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c07c f1ff
void m68kAndWordImm16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    aluAnd(reg_dt, reg_da[rx_index]);
	    updateNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c080 f1f8
void m68kAndLongDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluAnd(reg_da[ry_index], reg_da[rx_index]);
	    updateNZVC();
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    aluAnd(high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    updateNZVCU();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c090 f1f8
void m68kAndLongAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAnd(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluAnd(reg_alub, high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c098 f1f8
void m68kAndLongAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAnd(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluAnd(reg_alub, high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c0a0 f1f8
void m68kAndLongPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAnd(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluAnd(reg_alub, high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c0a8 f1f8
void m68kAndLongDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAnd(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluAnd(reg_alub, high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c0b0 f1f8
void m68kAndLongDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAnd(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluAnd(reg_alub, high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c0b8 f1ff
void m68kAndLongAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluAnd(reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAnd(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluAnd(reg_alub, high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c0b9 f1ff
void m68kAndLongAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 00d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluAnd(reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAnd(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluAnd(reg_alub, high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c0ba f1ff
void m68kAndLongDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAnd(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluAnd(reg_alub, high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c0bb f1ff
void m68kAndLongDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAnd(reg_dbin, reg_da[rx_index]);
	    updateNZVC();
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluAnd(reg_alub, high16(reg_da[rx_index]));
	    updateNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c0bc f1ff
void m68kAndLongImm32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    aluAnd(reg_dt, reg_da[rx_index]);
	    updateNZVC();
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    aluAnd(high16(reg_dt), high16(reg_da[rx_index]));
	    updateNZVCU();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c0c0 f1f8
void m68kMuluWordDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 15b mulr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_da[ry_index];
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAnd(reg_da[rx_index], 0x0000);
	    updateNZVC();
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // 0e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : testbit(reg_alue, 1) ? 1 : 2;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    aluRoxrLongMu(reg_aluo);
	    updateNZVCU();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm3:
	    // 060 mulm3
	    aluAdd(reg_alub, reg_aluo);
	    updateNZVCU();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    goto mulm4;
	mulm6:
	    // 020 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVCU();
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c0d0 f1f8
void m68kMuluWordAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAnd(reg_da[rx_index], 0x0000);
	    updateNZVC();
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // 0e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : testbit(reg_alue, 1) ? 1 : 2;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    aluRoxrLongMu(reg_aluo);
	    updateNZVCU();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm3:
	    // 060 mulm3
	    aluAdd(reg_alub, reg_aluo);
	    updateNZVCU();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    goto mulm4;
	mulm6:
	    // 020 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVCU();
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c0d8 f1f8
void m68kMuluWordAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAnd(reg_da[rx_index], 0x0000);
	    updateNZVC();
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // 0e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : testbit(reg_alue, 1) ? 1 : 2;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    aluRoxrLongMu(reg_aluo);
	    updateNZVCU();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm3:
	    // 060 mulm3
	    aluAdd(reg_alub, reg_aluo);
	    updateNZVCU();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    goto mulm4;
	mulm6:
	    // 020 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVCU();
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c0e0 f1f8
void m68kMuluWordPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAnd(reg_da[rx_index], 0x0000);
	    updateNZVC();
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // 0e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : testbit(reg_alue, 1) ? 1 : 2;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    aluRoxrLongMu(reg_aluo);
	    updateNZVCU();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm3:
	    // 060 mulm3
	    aluAdd(reg_alub, reg_aluo);
	    updateNZVCU();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    goto mulm4;
	mulm6:
	    // 020 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVCU();
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c0e8 f1f8
void m68kMuluWordDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAnd(reg_da[rx_index], 0x0000);
	    updateNZVC();
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // 0e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : testbit(reg_alue, 1) ? 1 : 2;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    aluRoxrLongMu(reg_aluo);
	    updateNZVCU();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm3:
	    // 060 mulm3
	    aluAdd(reg_alub, reg_aluo);
	    updateNZVCU();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    goto mulm4;
	mulm6:
	    // 020 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVCU();
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c0f0 f1f8
void m68kMuluWordDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAnd(reg_da[rx_index], 0x0000);
	    updateNZVC();
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // 0e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : testbit(reg_alue, 1) ? 1 : 2;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    aluRoxrLongMu(reg_aluo);
	    updateNZVCU();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm3:
	    // 060 mulm3
	    aluAdd(reg_alub, reg_aluo);
	    updateNZVCU();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    goto mulm4;
	mulm6:
	    // 020 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVCU();
	    setFTUConst();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c0f8 f1ff
void m68kMuluWordAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAnd(reg_da[rx_index], 0x0000);
	    updateNZVC();
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // 0e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : testbit(reg_alue, 1) ? 1 : 2;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    aluRoxrLongMu(reg_aluo);
	    updateNZVCU();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm3:
	    // 060 mulm3
	    aluAdd(reg_alub, reg_aluo);
	    updateNZVCU();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    goto mulm4;
	mulm6:
	    // 020 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVCU();
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c0f9 f1ff
void m68kMuluWordAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAnd(reg_da[rx_index], 0x0000);
	    updateNZVC();
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // 0e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : testbit(reg_alue, 1) ? 1 : 2;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    aluRoxrLongMu(reg_aluo);
	    updateNZVCU();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm3:
	    // 060 mulm3
	    aluAdd(reg_alub, reg_aluo);
	    updateNZVCU();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    goto mulm4;
	mulm6:
	    // 020 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVCU();
	    setFTUConst();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c0fa f1ff
void m68kMuluWordDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAnd(reg_da[rx_index], 0x0000);
	    updateNZVC();
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // 0e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : testbit(reg_alue, 1) ? 1 : 2;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    aluRoxrLongMu(reg_aluo);
	    updateNZVCU();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm3:
	    // 060 mulm3
	    aluAdd(reg_alub, reg_aluo);
	    updateNZVCU();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    goto mulm4;
	mulm6:
	    // 020 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVCU();
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c0fb f1ff
void m68kMuluWordDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAnd(reg_da[rx_index], 0x0000);
	    updateNZVC();
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // 0e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : testbit(reg_alue, 1) ? 1 : 2;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    aluRoxrLongMu(reg_aluo);
	    updateNZVCU();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm3:
	    // 060 mulm3
	    aluAdd(reg_alub, reg_aluo);
	    updateNZVCU();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    goto mulm4;
	mulm6:
	    // 020 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVCU();
	    setFTUConst();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c0fc f1ff
void m68kMuluWordImm16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15b mulr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dt;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAnd(reg_da[rx_index], 0x0000);
	    updateNZVC();
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // 0e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : testbit(reg_alue, 1) ? 1 : 2;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    aluRoxrLongMu(reg_aluo);
	    updateNZVCU();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm3:
	    // 060 mulm3
	    aluAdd(reg_alub, reg_aluo);
	    updateNZVCU();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    goto mulm4;
	mulm6:
	    // 020 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVCU();
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c100 f1f8
void m68kAbcdDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1cd rbrb1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluAbcdByte(reg_da[ry_index], reg_da[rx_index]);
	    updateXNZVCU();
	    // 11b rbrb2
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 238 rbrb3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c108 f1f8
void m68kAbcdPaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 107 asbb1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 135 asbb2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 136 asbb3
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 04e asbb4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_at = reg_au;
	    reg_da[rx_index] = reg_au;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 040 asbb5
	    reg_aob = reg_pc;
	    aluAbcdByte(reg_alub, reg_dbin);
	    updateXNZVCU();
	    // 113 asbb6
	    reg_au = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c110 f1f8
void m68kAndByteDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAndByte(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c118 f1f8
void m68kAndByteDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    aluAndByte(reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAndByte(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c120 f1f8
void m68kAndByteDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    aluAndByte(reg_da[rx_index], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAndByte(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c128 f1f8
void m68kAndByteDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAndByte(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c130 f1f8
void m68kAndByteDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAndByte(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c138 f1ff
void m68kAndByteDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluAndByte(reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAndByte(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c139 f1ff
void m68kAndByteDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluAndByte(reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAndByte(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c140 f1f8
void m68kExgDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e3 exge1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[rx_index];
	    reg_au = reg_da[ry_index];
	    // 231 exge2
	    reg_da[rx_index] = reg_au;
	    reg_da[ry_index] = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 08d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c148 f1f8
void m68kExgAdAsProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e3 exge1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[rx_index];
	    reg_au = reg_da[ry_index];
	    // 231 exge2
	    reg_da[rx_index] = reg_au;
	    reg_da[ry_index] = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 08d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c150 f1f8
void m68kAndWordDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c158 f1f8
void m68kAndWordDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c160 f1f8
void m68kAndWordDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    aluAnd(reg_da[rx_index], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c168 f1f8
void m68kAndWordDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c170 f1f8
void m68kAndWordDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c178 f1ff
void m68kAndWordDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluAnd(reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c179 f1ff
void m68kAndWordDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluAnd(reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c188 f1f8
void m68kExgDdAsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 3e3 exge1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[rx_index];
	    reg_au = reg_da[ry_index];
	    // 231 exge2
	    reg_da[rx_index] = reg_au;
	    reg_da[ry_index] = reg_at;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 08d rcal3
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c190 f1f8
void m68kAndLongDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAnd(high16(reg_da[rx_index]), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c198 f1f8
void m68kAndLongDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAnd(high16(reg_da[rx_index]), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c1a0 f1f8
void m68kAndLongDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAnd(high16(reg_da[rx_index]), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c1a8 f1f8
void m68kAndLongDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAnd(high16(reg_da[rx_index]), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c1b0 f1f8
void m68kAndLongDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAnd(high16(reg_da[rx_index]), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c1b8 f1ff
void m68kAndLongDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluAnd(reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAnd(high16(reg_da[rx_index]), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c1b9 f1ff
void m68kAndLongDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 00d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluAnd(reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAnd(reg_da[rx_index], reg_dbin);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAnd(high16(reg_da[rx_index]), reg_alue);
	    updateNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c1c0 f1f8
void m68kMulsWordDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 15b mulr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_da[ry_index];
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAnd(reg_da[rx_index], 0x0000);
	    updateNZVC();
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // 0e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : ((reg_alue & 0x3) == 1) ? 1 : ((reg_alue & 0x3) == 2) ? 2 : 3;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    aluRoxrLongMs(reg_aluo);
	    updateNZVCU();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else if (reg_t == 2)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	     }
	mulm5:
	    // 0a0 mulm5
	    aluSub(reg_alub, reg_aluo);
	    updateNZVCU();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    goto mulm4;
	mulm6:
	    // 020 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVCU();
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	mulm3:
	    // 060 mulm3
	    aluAdd(reg_alub, reg_aluo);
	    updateNZVCU();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    goto mulm4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c1d0 f1f8
void m68kMulsWordAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAnd(reg_da[rx_index], 0x0000);
	    updateNZVC();
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // 0e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : ((reg_alue & 0x3) == 1) ? 1 : ((reg_alue & 0x3) == 2) ? 2 : 3;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    aluRoxrLongMs(reg_aluo);
	    updateNZVCU();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else if (reg_t == 2)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	     }
	mulm5:
	    // 0a0 mulm5
	    aluSub(reg_alub, reg_aluo);
	    updateNZVCU();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    goto mulm4;
	mulm6:
	    // 020 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVCU();
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	mulm3:
	    // 060 mulm3
	    aluAdd(reg_alub, reg_aluo);
	    updateNZVCU();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    goto mulm4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c1d8 f1f8
void m68kMulsWordAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAnd(reg_da[rx_index], 0x0000);
	    updateNZVC();
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // 0e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : ((reg_alue & 0x3) == 1) ? 1 : ((reg_alue & 0x3) == 2) ? 2 : 3;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    aluRoxrLongMs(reg_aluo);
	    updateNZVCU();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else if (reg_t == 2)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	     }
	mulm5:
	    // 0a0 mulm5
	    aluSub(reg_alub, reg_aluo);
	    updateNZVCU();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    goto mulm4;
	mulm6:
	    // 020 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVCU();
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	mulm3:
	    // 060 mulm3
	    aluAdd(reg_alub, reg_aluo);
	    updateNZVCU();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    goto mulm4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c1e0 f1f8
void m68kMulsWordPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAnd(reg_da[rx_index], 0x0000);
	    updateNZVC();
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // 0e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : ((reg_alue & 0x3) == 1) ? 1 : ((reg_alue & 0x3) == 2) ? 2 : 3;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    aluRoxrLongMs(reg_aluo);
	    updateNZVCU();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else if (reg_t == 2)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	     }
	mulm5:
	    // 0a0 mulm5
	    aluSub(reg_alub, reg_aluo);
	    updateNZVCU();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    goto mulm4;
	mulm6:
	    // 020 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVCU();
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	mulm3:
	    // 060 mulm3
	    aluAdd(reg_alub, reg_aluo);
	    updateNZVCU();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    goto mulm4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c1e8 f1f8
void m68kMulsWordDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAnd(reg_da[rx_index], 0x0000);
	    updateNZVC();
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // 0e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : ((reg_alue & 0x3) == 1) ? 1 : ((reg_alue & 0x3) == 2) ? 2 : 3;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    aluRoxrLongMs(reg_aluo);
	    updateNZVCU();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else if (reg_t == 2)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	     }
	mulm5:
	    // 0a0 mulm5
	    aluSub(reg_alub, reg_aluo);
	    updateNZVCU();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    goto mulm4;
	mulm6:
	    // 020 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVCU();
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	mulm3:
	    // 060 mulm3
	    aluAdd(reg_alub, reg_aluo);
	    updateNZVCU();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    goto mulm4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c1f0 f1f8
void m68kMulsWordDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAnd(reg_da[rx_index], 0x0000);
	    updateNZVC();
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // 0e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : ((reg_alue & 0x3) == 1) ? 1 : ((reg_alue & 0x3) == 2) ? 2 : 3;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    aluRoxrLongMs(reg_aluo);
	    updateNZVCU();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else if (reg_t == 2)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	     }
	mulm5:
	    // 0a0 mulm5
	    aluSub(reg_alub, reg_aluo);
	    updateNZVCU();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    goto mulm4;
	mulm6:
	    // 020 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVCU();
	    setFTUConst();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    nextTrace();
	    return;
	mulm3:
	    // 060 mulm3
	    aluAdd(reg_alub, reg_aluo);
	    updateNZVCU();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    goto mulm4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c1f8 f1ff
void m68kMulsWordAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAnd(reg_da[rx_index], 0x0000);
	    updateNZVC();
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // 0e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : ((reg_alue & 0x3) == 1) ? 1 : ((reg_alue & 0x3) == 2) ? 2 : 3;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    aluRoxrLongMs(reg_aluo);
	    updateNZVCU();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else if (reg_t == 2)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	     }
	mulm5:
	    // 0a0 mulm5
	    aluSub(reg_alub, reg_aluo);
	    updateNZVCU();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    goto mulm4;
	mulm6:
	    // 020 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVCU();
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	mulm3:
	    // 060 mulm3
	    aluAdd(reg_alub, reg_aluo);
	    updateNZVCU();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    goto mulm4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c1f9 f1ff
void m68kMulsWordAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAnd(reg_da[rx_index], 0x0000);
	    updateNZVC();
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // 0e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : ((reg_alue & 0x3) == 1) ? 1 : ((reg_alue & 0x3) == 2) ? 2 : 3;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    aluRoxrLongMs(reg_aluo);
	    updateNZVCU();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else if (reg_t == 2)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	     }
	mulm5:
	    // 0a0 mulm5
	    aluSub(reg_alub, reg_aluo);
	    updateNZVCU();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    goto mulm4;
	mulm6:
	    // 020 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVCU();
	    setFTUConst();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    nextTrace();
	    return;
	mulm3:
	    // 060 mulm3
	    aluAdd(reg_alub, reg_aluo);
	    updateNZVCU();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    goto mulm4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c1fa f1ff
void m68kMulsWordDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAnd(reg_da[rx_index], 0x0000);
	    updateNZVC();
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // 0e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : ((reg_alue & 0x3) == 1) ? 1 : ((reg_alue & 0x3) == 2) ? 2 : 3;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    aluRoxrLongMs(reg_aluo);
	    updateNZVCU();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else if (reg_t == 2)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	     }
	mulm5:
	    // 0a0 mulm5
	    aluSub(reg_alub, reg_aluo);
	    updateNZVCU();
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    goto mulm4;
	mulm6:
	    // 020 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVCU();
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	mulm3:
	    // 060 mulm3
	    aluAdd(reg_alub, reg_aluo);
	    updateNZVCU();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    goto mulm4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c1fb f1ff
void m68kMulsWordDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 13;
	}
	break;
	case 13:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 15a mulm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAnd(reg_da[rx_index], 0x0000);
	    updateNZVC();
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // 0e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : ((reg_alue & 0x3) == 1) ? 1 : ((reg_alue & 0x3) == 2) ? 2 : 3;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    aluRoxrLongMs(reg_aluo);
	    updateNZVCU();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else if (reg_t == 2)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	     }
	mulm5:
	    // 0a0 mulm5
	    aluSub(reg_alub, reg_aluo);
	    updateNZVCU();
	    inst_cycle = 11;
	}
	break;
	case 11:
	{
	    inst_cycle = 12;
	}
	break;
	case 12:
	{
	    goto mulm4;
	mulm6:
	    // 020 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVCU();
	    setFTUConst();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    nextTrace();
	    return;
	mulm3:
	    // 060 mulm3
	    aluAdd(reg_alub, reg_aluo);
	    updateNZVCU();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    goto mulm4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// c1fc f1ff
void m68kMulsWordImm16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 15b mulr1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_da[rx_index];
	    reg_alue = reg_dt;
	    reg_at = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAnd(reg_da[rx_index], 0x0000);
	    updateNZVC();
	    // 3c4 mulm2
	    reg_t = testbit(reg_alue, 0) ? 1 : 0;
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	    }
	mulm4:
	    // 0e0 mulm4
	    reg_t = ((reg_au & 0x3F) == 0) ? 0 : ((reg_alue & 0x3) == 1) ? 1 : ((reg_alue & 0x3) == 2) ? 2 : 3;
	    setReg16Low(reg_pc, reg_at);
	    reg_au = reg_au - 1;
	    aluRoxrLongMs(reg_aluo);
	    updateNZVCU();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (reg_t == 0)
	    {
		goto mulm6;
	    }
	    else if (reg_t == 1)
	    {
		goto mulm3;
	    }
	    else if (reg_t == 2)
	    {
		goto mulm5;
	    }
	    else
	    {
		goto mulm4;
	     }
	mulm5:
	    // 0a0 mulm5
	    aluSub(reg_alub, reg_aluo);
	    updateNZVCU();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    inst_cycle = 10;
	}
	break;
	case 10:
	{
	    goto mulm4;
	mulm6:
	    // 020 mulm6
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_pc, high16(reg_at));
	    reg_da[rx_index] = merge32(reg_aluo, reg_alue);
	    reg_au = reg_at + 2;
	    aluAnd(reg_aluo, 0xFFFF);
	    updateNZVCU();
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	mulm3:
	    // 060 mulm3
	    aluAdd(reg_alub, reg_aluo);
	    updateNZVCU();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    goto mulm4;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d000 f1f8
void m68kAddByteDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluAddByte(reg_da[ry_index], reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d010 f1f8
void m68kAddByteAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAddByte(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d018 f1f8
void m68kAddByteAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAddByte(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d020 f1f8
void m68kAddBytePaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAddByte(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d028 f1f8
void m68kAddByteDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAddByte(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d030 f1f8
void m68kAddByteDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAddByte(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d038 f1ff
void m68kAddByteAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAddByte(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d039 f1ff
void m68kAddByteAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAddByte(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d03a f1ff
void m68kAddByteDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAddByte(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d03b f1ff
void m68kAddByteDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAddByte(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d03c f1ff
void m68kAddByteImm8DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    aluAddByte(reg_dt, reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d040 f1f8
void m68kAddWordDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluAdd(reg_da[ry_index], reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d048 f1f8
void m68kAddWordAsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluAdd(reg_da[ry_index], reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d050 f1f8
void m68kAddWordAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAdd(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d058 f1f8
void m68kAddWordAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAdd(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d060 f1f8
void m68kAddWordPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAdd(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d068 f1f8
void m68kAddWordDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAdd(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d070 f1f8
void m68kAddWordDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAdd(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d078 f1ff
void m68kAddWordAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAdd(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d079 f1ff
void m68kAddWordAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAdd(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d07a f1ff
void m68kAddWordDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAdd(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d07b f1ff
void m68kAddWordDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c3 romw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAdd(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d07c f1ff
void m68kAddWordImm16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    aluAdd(reg_dt, reg_da[rx_index]);
	    updateXNZVC();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d080 f1f8
void m68kAddLongDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluAdd(reg_da[ry_index], reg_da[rx_index]);
	    updateXNZVC();
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    aluAddc(high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    updateXNZVCU();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d088 f1f8
void m68kAddLongAsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluAdd(reg_da[ry_index], reg_da[rx_index]);
	    updateXNZVC();
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    aluAddc(high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    updateXNZVCU();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d090 f1f8
void m68kAddLongAisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAdd(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluAddc(reg_alub, high16(reg_da[rx_index]));
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d098 f1f8
void m68kAddLongAipsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAdd(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluAddc(reg_alub, high16(reg_da[rx_index]));
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d0a0 f1f8
void m68kAddLongPaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAdd(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluAddc(reg_alub, high16(reg_da[rx_index]));
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d0a8 f1f8
void m68kAddLongDasDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAdd(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluAddc(reg_alub, high16(reg_da[rx_index]));
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d0b0 f1f8
void m68kAddLongDaisDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAdd(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluAddc(reg_alub, high16(reg_da[rx_index]));
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d0b8 f1ff
void m68kAddLongAdr16DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAdd(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluAddc(reg_alub, high16(reg_da[rx_index]));
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d0b9 f1ff
void m68kAddLongAdr32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 00d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAdd(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluAddc(reg_alub, high16(reg_da[rx_index]));
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d0ba f1ff
void m68kAddLongDpcDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAdd(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluAddc(reg_alub, high16(reg_da[rx_index]));
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d0bb f1ff
void m68kAddLongDpciDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAdd(reg_dbin, reg_da[rx_index]);
	    updateXNZVC();
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluAddc(reg_alub, high16(reg_da[rx_index]));
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d0bc f1ff
void m68kAddLongImm32DdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    aluAdd(reg_dt, reg_da[rx_index]);
	    updateXNZVC();
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    aluAddc(high16(reg_dt), high16(reg_da[rx_index]));
	    updateXNZVCU();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d0c0 f1f8
void m68kAddaWordDsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c9 rorm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluAdd(reg_da[ry_index], reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    aluAddc(high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d0c8 f1f8
void m68kAddaWordAsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c9 rorm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluAdd(reg_da[ry_index], reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    aluAddc(high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d0d0 f1f8
void m68kAddaWordAisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAdd(reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    aluAddc(high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d0d8 f1f8
void m68kAddaWordAipsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = 0;
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAdd(reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    aluAddc(high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d0e0 f1f8
void m68kAddaWordPaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAdd(reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    aluAddc(high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d0e8 f1f8
void m68kAddaWordDasAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAdd(reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    aluAddc(high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d0f0 f1f8
void m68kAddaWordDaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAdd(reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    aluAddc(high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d0f8 f1ff
void m68kAddaWordAdr16AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAdd(reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    aluAddc(high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d0f9 f1ff
void m68kAddaWordAdr32AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAdd(reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    aluAddc(high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d0fa f1ff
void m68kAddaWordDpcAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAdd(reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    aluAddc(high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d0fb f1ff
void m68kAddaWordDpciAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 9;
	}
	break;
	case 9:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = 0;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1c7 romm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAdd(reg_dbin, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    aluAddc(high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d0fc f1ff
void m68kAddaWordImm16AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c9 rorm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    aluAdd(reg_dt, reg_da[rx_index]);
	    // 3c8 rorm2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25f rorm3
	    aluAddc(high16(reg_at), high16(reg_da[rx_index]));
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d100 f1f8
void m68kAddxByteDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluAddxByte(reg_da[ry_index], reg_da[rx_index]);
	    updateXNZVCU();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d108 f1f8
void m68kAddxBytePaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 10f asxw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 131 asxw2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 132 asxw3
	    reg_au = reg_da[rx_index] - ((rx_index < 15) ? 1 : 2);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 04a asxw4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_at = reg_au;
	    reg_da[rx_index] = reg_au;
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 065 asxw5
	    reg_aob = reg_pc;
	    reg_au = reg_at;
	    aluAddxByte(reg_alub, reg_dbin);
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d110 f1f8
void m68kAddByteDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAddByte(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d118 f1f8
void m68kAddByteDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + ((ry_index < 15) ? 1 : 2);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAddByte(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d120 f1f8
void m68kAddByteDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - ((ry_index < 15) ? 1 : 2);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndByte(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAddByte(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d128 f1f8
void m68kAddByteDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAddByte(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d130 f1f8
void m68kAddByteDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndByte(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAddByte(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d138 f1ff
void m68kAddByteDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAddByte(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d139 f1ff
void m68kAddByteDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndByte(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readByte();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAddByte(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8ExLow(reg_dbout, reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeByte();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d140 f1f8
void m68kAddxWordDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c1 rorw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluAddx(reg_da[ry_index], reg_da[rx_index]);
	    updateXNZVCU();
	    // 27a rrgw2
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d148 f1f8
void m68kAddxWordPaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 10f asxw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 131 asxw2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 132 asxw3
	    reg_au = reg_da[rx_index] - 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 04a asxw4
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_alub = reg_dbin;
	    reg_at = reg_au;
	    reg_da[rx_index] = reg_au;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 065 asxw5
	    reg_aob = reg_pc;
	    reg_au = reg_at;
	    aluAddx(reg_alub, reg_dbin);
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d150 f1f8
void m68kAddWordDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAdd(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d158 f1f8
void m68kAddWordDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAdd(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d160 f1f8
void m68kAddWordDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAdd(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d168 f1f8
void m68kAddWordDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAdd(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d170 f1f8
void m68kAddWordDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAdd(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d178 f1ff
void m68kAddWordDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAdd(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d179 f1ff
void m68kAddWordDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 299 morw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAdd(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d180 f1f8
void m68kAddxLongDsDdProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluAddx(reg_da[ry_index], reg_da[rx_index]);
	    updateXNZVCU();
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    aluAddx(high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    updateXNZVCU();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d188 f1f8
void m68kAddxLongPaisPaidProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 10b asxl1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 048 asxl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_au = reg_au - 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 139 asxl3
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 13a asxl4
	    reg_au = reg_da[rx_index] - 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 04c asxl5
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_au = reg_au - 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 047 asxl6
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[rx_index] = reg_au;
	    reg_au = reg_au + 2;
	    aluAddx(reg_aluo, reg_dbin);
	    updateXNZVCU();
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 061 asxl7
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_dbout = reg_aluo;
	    reg_au = ext32(reg_dbin);
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 062 asxl8
	    reg_aob = reg_pc;
	    reg_au = reg_at;
	    aluAddx(reg_alub, reg_dbin);
	    updateXNZVCU();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d190 f1f8
void m68kAddLongDdAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAdd(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAddc(high16(reg_da[rx_index]), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d198 f1f8
void m68kAddLongDdAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAdd(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAddc(high16(reg_da[rx_index]), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d1a0 f1f8
void m68kAddLongDdPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAdd(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAddc(high16(reg_da[rx_index]), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d1a8 f1f8
void m68kAddLongDdDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAdd(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAddc(high16(reg_da[rx_index]), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d1b0 f1f8
void m68kAddLongDdDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAdd(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAddc(high16(reg_da[rx_index]), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d1b8 f1ff
void m68kAddLongDdAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAdd(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAddc(high16(reg_da[rx_index]), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d1b9 f1ff
void m68kAddLongDdAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 00d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 29d morl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_at;
	    aluAdd(reg_da[rx_index], reg_dbin);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 34d morl2
	    reg_aob = reg_au;
	    reg_dbout = reg_aluo;
	    reg_au = reg_au - 2;
	    aluAddc(high16(reg_da[rx_index]), reg_alue);
	    updateXNZVCU();
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d1c0 f1f8
void m68kAddaLongDsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluAdd(reg_da[ry_index], reg_da[rx_index]);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    aluAddc(high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d1c8 f1f8
void m68kAddaLongAsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_da[ry_index]);
	    aluAdd(reg_da[ry_index], reg_da[rx_index]);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    aluAddc(high16(reg_da[ry_index]), high16(reg_da[rx_index]));
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d1d0 f1f8
void m68kAddaLongAisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00b adrl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAdd(reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluAddc(reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d1d8 f1f8
void m68kAddaLongAipsAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00f pinl1
	    reg_aob = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 21a pinl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_au + 2;
	    // 21b pinl3
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAdd(reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluAddc(reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d1e0 f1f8
void m68kAddaLongPaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 179 pdcl1
	    reg_au = reg_da[ry_index] - 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17a pdcl2
	    reg_aob = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_au + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAdd(reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluAddc(reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d1e8 f1f8
void m68kAddaLongDasAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAdd(reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluAddc(reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d1f0 f1f8
void m68kAddaLongDaisAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAdd(reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluAddc(reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d1f8 f1ff
void m68kAddaLongAdr16AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00e abww1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAdd(reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluAddc(reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d1f9 f1ff
void m68kAddaLongAdr32AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e6 ablw1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 00d ablw2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = 0;
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 008 ablw3
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 005 adrl2
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 2;
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAdd(reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluAddc(reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d1fa f1ff
void m68kAddaLongDpcAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c6 adsl1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_pc;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAdd(reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluAddc(reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d1fb f1ff
void m68kAddaLongDpciAdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e7 aixw0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e6 aixw1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_pc + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixw4;
	    }
	    else
	    {
		goto aixw2;
	    }
	aixw2:
	    // 124 aixw2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	aixw4:
	    // 1e4 aixw4
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 8;
	}
	break;
	case 8:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsl2;
	adsl2:
	    // 00c adsl2
	    reg_aob = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 026 adsl3
	    reg_aob = reg_au;
	    reg_alub = reg_dbin;
	    reg_alue = reg_dbin;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 1cb roml1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dbin);
	    aluAdd(reg_dbin, reg_da[rx_index]);
	    // 25c roml2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    aluAddc(reg_alub, high16(reg_da[rx_index]));
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// d1fc f1ff
void m68kAddaLongImm32AdProgram()
{
    rx_index = mapSP(((reg_irdi >> 9) & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 0a7 e#l1
	    reg_aob = reg_au;
	    setReg16High(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 0ea e#w1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    setReg16Low(reg_dt, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 1c5 rorl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_at = ext32(reg_dt);
	    aluAdd(reg_dt, reg_da[rx_index]);
	    // 3c0 rorl2
	    setReg16Low(reg_da[rx_index], reg_aluo);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 25e rorl3
	    aluAddc(high16(reg_dt), high16(reg_da[rx_index]));
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 25d roml3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16High(reg_da[rx_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e000 f1f8
void m68kAsrByteImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAndByte(high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAndByte(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluAsrByte(reg_aluo);
	    updateXNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e008 f1f8
void m68kLsrByteImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAndByte(high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAndByte(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluLsrByte(reg_aluo);
	    updateXNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e010 f1f8
void m68kRoxrByteImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAndBytex(high16(reg_da[ry_index]), 0xFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAndBytex(reg_da[ry_index], 0xFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluRoxrByte(reg_aluo);
	    updateXNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e018 f1f8
void m68kRorByteImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAndByte(high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAndByte(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluRorByte(reg_aluo);
	    updateNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e020 f1f8
void m68kAsrByteDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    aluAndByte(high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAndByte(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluAsrByte(reg_aluo);
	    updateXNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e028 f1f8
void m68kLsrByteDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    aluAndByte(high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAndByte(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluLsrByte(reg_aluo);
	    updateXNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e030 f1f8
void m68kRoxrByteDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    aluAndBytex(high16(reg_da[ry_index]), 0xFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAndBytex(reg_da[ry_index], 0xFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluRoxrByte(reg_aluo);
	    updateXNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e038 f1f8
void m68kRorByteDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    aluAndByte(high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAndByte(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluRorByte(reg_aluo);
	    updateNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e040 f1f8
void m68kAsrWordImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluAsr(reg_aluo);
	    updateXNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e048 f1f8
void m68kLsrWordImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluLsr(reg_aluo);
	    updateXNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e050 f1f8
void m68kRoxrWordImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAndx(high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAndx(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluRoxr(reg_aluo);
	    updateXNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e058 f1f8
void m68kRorWordImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluRor(reg_aluo);
	    updateNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e060 f1f8
void m68kAsrWordDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluAsr(reg_aluo);
	    updateXNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e068 f1f8
void m68kLsrWordDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluLsr(reg_aluo);
	    updateXNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e070 f1f8
void m68kRoxrWordDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    aluAndx(high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAndx(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluRoxr(reg_aluo);
	    updateXNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e078 f1f8
void m68kRorWordDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluRor(reg_aluo);
	    updateNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e080 f1f8
void m68kAsrLongImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 385 srrl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl3:
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluAsrLong(reg_aluo);
	    updateXNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl4:
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e088 f1f8
void m68kLsrLongImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 385 srrl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl3:
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluLsrLong(reg_aluo);
	    updateXNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl4:
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e090 f1f8
void m68kRoxrLongImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 385 srrl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAndx(high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAndx(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl3:
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluRoxrLong(reg_aluo);
	    updateXNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl4:
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    aluAndx(reg_alub, 0xFFFF);
	    updateNZU();
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e098 f1f8
void m68kRorLongImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 385 srrl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl3:
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluRorLong(reg_aluo);
	    updateNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl4:
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e0a0 f1f8
void m68kAsrLongDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 386 sril1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl3:
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluAsrLong(reg_aluo);
	    updateXNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl4:
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e0a8 f1f8
void m68kLsrLongDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 386 sril1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl3:
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluLsrLong(reg_aluo);
	    updateXNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl4:
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e0b0 f1f8
void m68kRoxrLongDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 386 sril1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    aluAndx(high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAndx(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl3:
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluRoxrLong(reg_aluo);
	    updateXNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl4:
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    aluAndx(reg_alub, 0xFFFF);
	    updateNZU();
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e0b8 f1f8
void m68kRorLongDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 386 sril1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl3:
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluRorLong(reg_aluo);
	    updateNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl4:
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e0d0 fff8
void m68kAsrAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluAsr(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e0d8 fff8
void m68kAsrAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluAsr(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e0e0 fff8
void m68kAsrPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluAsr(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e0e8 fff8
void m68kAsrDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluAsr(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e0f0 fff8
void m68kAsrDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluAsr(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e0f8 ffff
void m68kAsrAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluAsr(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e0f9 ffff
void m68kAsrAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluAsr(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e100 f1f8
void m68kAslByteImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAndByte(high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAndByte(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluAslByte(reg_aluo);
	    updateXNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e108 f1f8
void m68kLslByteImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAndByte(high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAndByte(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluLslByte(reg_aluo);
	    updateXNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e110 f1f8
void m68kRoxlByteImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAndBytex(high16(reg_da[ry_index]), 0xFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAndBytex(reg_da[ry_index], 0xFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluRoxlByte(reg_aluo);
	    updateXNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e118 f1f8
void m68kRolByteImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAndByte(high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAndByte(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluRolByte(reg_aluo);
	    updateNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e120 f1f8
void m68kAslByteDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    aluAndByte(high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAndByte(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluAslByte(reg_aluo);
	    updateXNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e128 f1f8
void m68kLslByteDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    aluAndByte(high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAndByte(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluLslByte(reg_aluo);
	    updateXNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e130 f1f8
void m68kRoxlByteDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    aluAndBytex(high16(reg_da[ry_index]), 0xFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAndBytex(reg_da[ry_index], 0xFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluRoxlByte(reg_aluo);
	    updateXNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e138 f1f8
void m68kRolByteDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    aluAndByte(high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAndByte(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluRolByte(reg_aluo);
	    updateNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg8(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e140 f1f8
void m68kAslWordImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluAsl(reg_aluo);
	    updateXNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e148 f1f8
void m68kLslWordImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluLsl(reg_aluo);
	    updateXNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e150 f1f8
void m68kRoxlWordImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAndx(high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAndx(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluRoxl(reg_aluo);
	    updateXNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e158 f1f8
void m68kRolWordImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 381 srrw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluRol(reg_aluo);
	    updateNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e160 f1f8
void m68kAslWordDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluAsl(reg_aluo);
	    updateXNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e168 f1f8
void m68kLslWordDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluLsl(reg_aluo);
	    updateXNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e170 f1f8
void m68kRoxlWordDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    aluAndx(high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAndx(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluRoxl(reg_aluo);
	    updateXNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e178 f1f8
void m68kRolWordDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 382 sriw1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    // 383 srrw2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	srrw3:
	    // 2d3 srrw3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluRol(reg_aluo);
	    updateNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto nbcr3;
	    }
	    else
	    {
		goto srrw3;
	    }
	nbcr3:
	    // 253 nbcr3
	    reg_ird = reg_ir;
	    setIntState();
	    setReg16Low(reg_da[ry_index], reg_aluo);
	    reg_au = reg_pc + 2;
	    setFTUConst();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e180 f1f8
void m68kAslLongImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 385 srrl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl3:
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluAslLong(reg_aluo);
	    updateXNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl4:
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e188 f1f8
void m68kLslLongImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 385 srrl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl3:
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluLslLong(reg_aluo);
	    updateXNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl4:
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    aluAnd(reg_aluo, reg_alue);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e190 f1f8
void m68kRoxlLongImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 385 srrl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAndx(high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAndx(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl3:
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluRoxlLong(reg_aluo);
	    updateXNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl4:
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    aluAndx(reg_alub, 0xFFFF);
	    updateNZU();
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e198 f1f8
void m68kRolLongImm3DsProgram()
{
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 385 srrl1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_ftu);
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl3:
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluRolLong(reg_aluo);
	    updateNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl4:
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e1a0 f1f8
void m68kAslLongDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 386 sril1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl3:
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluAslLong(reg_aluo);
	    updateXNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl4:
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e1a8 f1f8
void m68kLslLongDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 386 sril1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl3:
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluLslLong(reg_aluo);
	    updateXNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl4:
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    aluAnd(reg_aluo, reg_alue);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e1b0 f1f8
void m68kRoxlLongDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 386 sril1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    aluAndx(high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAndx(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl3:
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluRoxlLong(reg_aluo);
	    updateXNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl4:
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    aluAndx(reg_alub, 0xFFFF);
	    updateNZU();
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e1b8 f1f8
void m68kRolLongDdDsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = (reg_irdi & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 386 sril1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = ext32(reg_da[rx_index]);
	    aluAnd(high16(reg_da[ry_index]), 0xFFFF);
	    // 387 srrl2
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_alue = reg_aluo;
	    reg_au = reg_au - 1;
	    aluAnd(reg_da[ry_index], 0xFFFF);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl3:
	    // 2d7 srrl3
	    reg_t = (((reg_au & 0x3F) == 0) ? 1 : 0);
	    reg_au = reg_au - 1;
	    aluRolLong(reg_aluo);
	    updateNZVC();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (reg_t)
	    {
		goto srrl4;
	    }
	    else
	    {
		goto srrl3;
	    }
	srrl4:
	    // 257 srrl4
	    reg_alub = reg_alue;
	    reg_da[ry_index] = merge32(reg_alue, reg_aluo);
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    // 306 srrl5
	    reg_ird = reg_ir;
	    setIntState();
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    updateNZU();
	    setFTUConst();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    inst_cycle = 7;
	}
	break;
	case 7:
	{
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e1d0 fff8
void m68kAslAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluAsl(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e1d8 fff8
void m68kAslAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluAsl(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e1e0 fff8
void m68kAslPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluAsl(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e1e8 fff8
void m68kAslDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluAsl(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e1f0 fff8
void m68kAslDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluAsl(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e1f8 ffff
void m68kAslAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluAsl(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e1f9 ffff
void m68kAslAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluAsl(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e2d0 fff8
void m68kLsrAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluLsr(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e2d8 fff8
void m68kLsrAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluLsr(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e2e0 fff8
void m68kLsrPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluLsr(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e2e8 fff8
void m68kLsrDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluLsr(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e2f0 fff8
void m68kLsrDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluLsr(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e2f8 ffff
void m68kLsrAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluLsr(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e2f9 ffff
void m68kLsrAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluLsr(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e3d0 fff8
void m68kLslAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluLsl(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e3d8 fff8
void m68kLslAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    aluAnd(reg_da[rx_index], reg_dbin);
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluLsl(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e3e0 fff8
void m68kLslPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    aluAnd(reg_da[rx_index], reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluLsl(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e3e8 fff8
void m68kLslDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluLsl(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e3f0 fff8
void m68kLslDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluLsl(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e3f8 ffff
void m68kLslAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    aluAnd(reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluLsl(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e3f9 ffff
void m68kLslAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    aluAnd(reg_da[rx_index], reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluLsl(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e4d0 fff8
void m68kRoxrAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndx(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAndx(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluRoxr(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e4d8 fff8
void m68kRoxrAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndx(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAndx(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluRoxr(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e4e0 fff8
void m68kRoxrPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndx(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAndx(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluRoxr(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e4e8 fff8
void m68kRoxrDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndx(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAndx(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluRoxr(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e4f0 fff8
void m68kRoxrDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndx(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAndx(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluRoxr(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e4f8 ffff
void m68kRoxrAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndx(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAndx(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluRoxr(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e4f9 ffff
void m68kRoxrAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndx(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAndx(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluRoxr(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e5d0 fff8
void m68kRoxlAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAndx(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAndx(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluRoxl(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e5d8 fff8
void m68kRoxlAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAndx(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAndx(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluRoxl(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e5e0 fff8
void m68kRoxlPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAndx(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAndx(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluRoxl(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e5e8 fff8
void m68kRoxlDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndx(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAndx(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluRoxl(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e5f0 fff8
void m68kRoxlDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAndx(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAndx(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluRoxl(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e5f8 ffff
void m68kRoxlAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndx(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAndx(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluRoxl(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e5f9 ffff
void m68kRoxlAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAndx(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAndx(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluRoxl(reg_aluo);
	    updateXNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e6d0 fff8
void m68kRorAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluRor(reg_aluo);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e6d8 fff8
void m68kRorAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluRor(reg_aluo);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e6e0 fff8
void m68kRorPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluRor(reg_aluo);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e6e8 fff8
void m68kRorDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluRor(reg_aluo);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e6f0 fff8
void m68kRorDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluRor(reg_aluo);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e6f8 ffff
void m68kRorAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluRor(reg_aluo);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e6f9 ffff
void m68kRorAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluRor(reg_aluo);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e7d0 fff8
void m68kRolAisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 006 adrw1
	    reg_aob = reg_da[ry_index];
	    reg_at = reg_da[ry_index];
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluRol(reg_aluo);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e7d8 fff8
void m68kRolAipsProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 21c pinw1
	    reg_aob = reg_da[ry_index];
	    reg_alub = reg_dbin;
	    reg_dcr = reg_da[rx_index];
	    reg_at = reg_da[ry_index];
	    reg_au = reg_da[ry_index] + 2;
	    // 21d pinw2
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluRol(reg_aluo);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e7e0 fff8
void m68kRolPaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 103 pdcw1
	    reg_alub = reg_dbin;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_au = reg_da[ry_index] - 2;
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 17b pdcw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_da[ry_index] = reg_au;
	    reg_au = reg_pc;
	    aluAnd(reg_alub, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluRol(reg_aluo);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e7e8 fff8
void m68kRolDasProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1c2 adsw1
	    reg_aob = reg_au;
	    reg_au = ext32(reg_dbin) + reg_da[ry_index];
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluRol(reg_aluo);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e7f0 fff8
void m68kRolDaisProgram()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    ry_index = mapSP((reg_irdi & 0x7) | 8);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e3 aixl0
	    aluExt(reg_dbin);
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    // 3e2 aixl1
	    reg_aob = reg_au;
	    reg_t = testbit(reg_irc, 11);
	    reg_au = reg_da[ry_index] + ext32(reg_aluo);
	    if (reg_t)
	    {
		goto aixl5;
	    }
	    else
	    {
		goto aixl2;
	    }
	aixl2:
	    // 120 aixl2
	    reg_au = ext32(reg_da[mapSP(reg_irc >> 12)]) + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	aixl5:
	    // 1e0 aixl5
	    reg_au = reg_da[mapSP(reg_irc >> 12)] + reg_au;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 6;
	}
	break;
	case 6:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    stepMovem();
	    goto adsw2;
	adsw2:
	    // 02a adsw2
	    reg_aob = reg_au;
	    reg_at = reg_au;
	    reg_au = reg_pc + 4;
	    aluAnd(reg_dbin, 0xFFFF);
	    // 024 adrw2
	    reg_dcr = reg_da[rx_index];
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluRol(reg_aluo);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e7f8 ffff
void m68kRolAdr16Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 00a abwl1
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    reg_at = ext32(reg_dbin);
	    reg_au = ext32(reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluRol(reg_aluo);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}

// e7f9 ffff
void m68kRolAdr32Program()
{
    rx_index = ((reg_irdi >> 9) & 0x7);
    switch (inst_cycle)
    {
	case 0:
	{
	    // 1e2 abll1
	    reg_aob = reg_au;
	    setReg16High(reg_at, reg_dbin);
	    reg_au = reg_au + 2;
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 1;
	}
	break;
	case 1:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 009 abll2
	    reg_aob = reg_au;
	    reg_pc = reg_au;
	    reg_dcr = reg_da[rx_index];
	    setReg16Low(reg_at, reg_dbin);
	    reg_au = merge32(high16(reg_at), reg_dbin);
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 2;
	}
	break;
	case 2:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 004 abll3
	    reg_aob = reg_at;
	    reg_au = reg_pc + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    setFC(true, false, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 3;
	}
	break;
	case 3:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_dbin = reg_edb;
	    // 3c7 sftm1
	    reg_aob = reg_au;
	    reg_ir = reg_irc;
	    updateIPL();
	    reg_pc = reg_au;
	    reg_au = reg_au + 2;
	    aluAnd(reg_dbin, 0xFFFF);
	    updateNZVC();
	    // 304 stmw2
	    reg_au = reg_at;
	    aluRol(reg_aluo);
	    updateNZVC();
	    setFC(false, true, true, false, false);
	    readWord();
	    startBus();
	    inst_cycle = 4;
	}
	break;
	case 4:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    reg_irc = reg_edb;
	    reg_dbin = reg_edb;
	    // 38d morw2
	    reg_aob = reg_au;
	    reg_ird = reg_ir;
	    setIntState();
	    reg_dbout = reg_aluo;
	    reg_au = reg_pc + 2;
	    setFC(true, false, false, false, false);
	    writeWord();
	    startBus();
	    inst_cycle = 5;
	}
	break;
	case 5:
	{
	    if (!isBusEnd())
	    {
		return;
	    }

	    endBus();
	    setFTUConst();
	    nextTrace();
	    return;
	}
	break;
	default:
	{
	    unrecognizedState();
	}
	break;
    }
}


vector<Kujo68KHandler> handlers = {
    {getFunction(ResetDp), false},
    {getFunction(DoubleFaultDp), false},
    {getFunction(DoubleFaultDp), false},
    {getFunction(DoubleFaultDp), false},
    {getFunction(InterruptDp), false},
    {getFunction(DoubleFaultDp), false},
    {getFunction(DoubleFaultDp), false},
    {getFunction(DoubleFaultDp), false},
    {getFunction(DoubleFaultDp), false},
    {getFunction(DoubleFaultDp), false},
    {getFunction(OriByteImm8Ds), false},
    {getFunction(OriByteImm8Ais), false},
    {getFunction(OriByteImm8Aips), false},
    {getFunction(OriByteImm8Pais), false},
    {getFunction(OriByteImm8Das), false},
    {getFunction(OriByteImm8Dais), false},
    {getFunction(OriByteImm8Adr16), false},
    {getFunction(OriByteImm8Adr32), false},
    {getFunction(OriImm8Ccr), false},
    {getFunction(OriWordImm16Ds), false},
    {getFunction(OriWordImm16Ais), false},
    {getFunction(OriWordImm16Aips), false},
    {getFunction(OriWordImm16Pais), false},
    {getFunction(OriWordImm16Das), false},
    {getFunction(OriWordImm16Dais), false},
    {getFunction(OriWordImm16Adr16), false},
    {getFunction(OriWordImm16Adr32), false},
    {getFunction(OriI16uSr), false},
    {getFunction(OriLongImm32Ds), false},
    {getFunction(OriLongImm32Ais), false},
    {getFunction(OriLongImm32Aips), false},
    {getFunction(OriLongImm32Pais), false},
    {getFunction(OriLongImm32Das), false},
    {getFunction(OriLongImm32Dais), false},
    {getFunction(OriLongImm32Adr16), false},
    {getFunction(OriLongImm32Adr32), false},
    {getFunction(BtstDdDs), false},
    {getFunction(MovepWordDasDd), false},
    {getFunction(BtstDdAis), false},
    {getFunction(BtstDdAips), false},
    {getFunction(BtstDdPais), true},
    {getFunction(BtstDdDas), false},
    {getFunction(BtstDdDais), true},
    {getFunction(BtstDdAdr16), false},
    {getFunction(BtstDdAdr32), false},
    {getFunction(BtstDdDpc), false},
    {getFunction(BtstDdDpci), true},
    {getFunction(BtstDdImm), false},
    {getFunction(BchgDdDs), false},
    {getFunction(MovepLongDasDd), false},
    {getFunction(BchgDdAis), false},
    {getFunction(BchgDdAips), false},
    {getFunction(BchgDdPais), true},
    {getFunction(BchgDdDas), false},
    {getFunction(BchgDdDais), true},
    {getFunction(BchgDdAdr16), false},
    {getFunction(BchgDdAdr32), false},
    {getFunction(BclrDdDs), false},
    {getFunction(MovepWordDdDas), false},
    {getFunction(BclrDdAis), false},
    {getFunction(BclrDdAips), false},
    {getFunction(BclrDdPais), true},
    {getFunction(BclrDdDas), false},
    {getFunction(BclrDdDais), true},
    {getFunction(BclrDdAdr16), false},
    {getFunction(BclrDdAdr32), false},
    {getFunction(BsetDdDs), false},
    {getFunction(MovepLongDdDas), false},
    {getFunction(BsetDdAis), false},
    {getFunction(BsetDdAips), false},
    {getFunction(BsetDdPais), true},
    {getFunction(BsetDdDas), false},
    {getFunction(BsetDdDais), true},
    {getFunction(BsetDdAdr16), false},
    {getFunction(BsetDdAdr32), false},
    {getFunction(AndiByteImm8Ds), false},
    {getFunction(AndiByteImm8Ais), false},
    {getFunction(AndiByteImm8Aips), false},
    {getFunction(AndiByteImm8Pais), false},
    {getFunction(AndiByteImm8Das), false},
    {getFunction(AndiByteImm8Dais), false},
    {getFunction(AndiByteImm8Adr16), false},
    {getFunction(AndiByteImm8Adr32), false},
    {getFunction(AndiImm8Ccr), false},
    {getFunction(AndiWordImm16Ds), false},
    {getFunction(AndiWordImm16Ais), false},
    {getFunction(AndiWordImm16Aips), false},
    {getFunction(AndiWordImm16Pais), false},
    {getFunction(AndiWordImm16Das), false},
    {getFunction(AndiWordImm16Dais), false},
    {getFunction(AndiWordImm16Adr16), false},
    {getFunction(AndiWordImm16Adr32), false},
    {getFunction(AndiI16uSr), false},
    {getFunction(AndiLongImm32Ds), false},
    {getFunction(AndiLongImm32Ais), false},
    {getFunction(AndiLongImm32Aips), false},
    {getFunction(AndiLongImm32Pais), false},
    {getFunction(AndiLongImm32Das), false},
    {getFunction(AndiLongImm32Dais), false},
    {getFunction(AndiLongImm32Adr16), false},
    {getFunction(AndiLongImm32Adr32), false},
    {getFunction(SubiByteImm8Ds), false},
    {getFunction(SubiByteImm8Ais), false},
    {getFunction(SubiByteImm8Aips), false},
    {getFunction(SubiByteImm8Pais), false},
    {getFunction(SubiByteImm8Das), false},
    {getFunction(SubiByteImm8Dais), false},
    {getFunction(SubiByteImm8Adr16), false},
    {getFunction(SubiByteImm8Adr32), false},
    {getFunction(SubiWordImm16Ds), false},
    {getFunction(SubiWordImm16Ais), false},
    {getFunction(SubiWordImm16Aips), false},
    {getFunction(SubiWordImm16Pais), false},
    {getFunction(SubiWordImm16Das), false},
    {getFunction(SubiWordImm16Dais), false},
    {getFunction(SubiWordImm16Adr16), false},
    {getFunction(SubiWordImm16Adr32), false},
    {getFunction(SubiLongImm32Ds), false},
    {getFunction(SubiLongImm32Ais), false},
    {getFunction(SubiLongImm32Aips), false},
    {getFunction(SubiLongImm32Pais), false},
    {getFunction(SubiLongImm32Das), false},
    {getFunction(SubiLongImm32Dais), false},
    {getFunction(SubiLongImm32Adr16), false},
    {getFunction(SubiLongImm32Adr32), false},
    {getFunction(AddiByteImm8Ds), false},
    {getFunction(AddiByteImm8Ais), false},
    {getFunction(AddiByteImm8Aips), false},
    {getFunction(AddiByteImm8Pais), false},
    {getFunction(AddiByteImm8Das), false},
    {getFunction(AddiByteImm8Dais), false},
    {getFunction(AddiByteImm8Adr16), false},
    {getFunction(AddiByteImm8Adr32), false},
    {getFunction(AddiWordImm16Ds), false},
    {getFunction(AddiWordImm16Ais), false},
    {getFunction(AddiWordImm16Aips), false},
    {getFunction(AddiWordImm16Pais), false},
    {getFunction(AddiWordImm16Das), false},
    {getFunction(AddiWordImm16Dais), false},
    {getFunction(AddiWordImm16Adr16), false},
    {getFunction(AddiWordImm16Adr32), false},
    {getFunction(AddiLongImm32Ds), false},
    {getFunction(AddiLongImm32Ais), false},
    {getFunction(AddiLongImm32Aips), false},
    {getFunction(AddiLongImm32Pais), false},
    {getFunction(AddiLongImm32Das), false},
    {getFunction(AddiLongImm32Dais), false},
    {getFunction(AddiLongImm32Adr16), false},
    {getFunction(AddiLongImm32Adr32), false},
    {getFunction(BtstImm8Ds), false},
    {getFunction(BtstImm8Ais), false},
    {getFunction(BtstImm8Aips), false},
    {getFunction(BtstImm8Pais), false},
    {getFunction(BtstImm8Das), false},
    {getFunction(BtstImm8Dais), false},
    {getFunction(BtstImm8Adr16), false},
    {getFunction(BtstImm8Adr32), false},
    {getFunction(BtstImm8Dpc), false},
    {getFunction(BtstImm8Dpci), false},
    {getFunction(BchgImm8Ds), false},
    {getFunction(BchgImm8Ais), false},
    {getFunction(BchgImm8Aips), false},
    {getFunction(BchgImm8Pais), false},
    {getFunction(BchgImm8Das), false},
    {getFunction(BchgImm8Dais), false},
    {getFunction(BchgImm8Adr16), false},
    {getFunction(BchgImm8Adr32), false},
    {getFunction(BclrImm8Ds), false},
    {getFunction(BclrImm8Ais), false},
    {getFunction(BclrImm8Aips), false},
    {getFunction(BclrImm8Pais), false},
    {getFunction(BclrImm8Das), false},
    {getFunction(BclrImm8Dais), false},
    {getFunction(BclrImm8Adr16), false},
    {getFunction(BclrImm8Adr32), false},
    {getFunction(BsetImm8Ds), false},
    {getFunction(BsetImm8Ais), false},
    {getFunction(BsetImm8Aips), false},
    {getFunction(BsetImm8Pais), false},
    {getFunction(BsetImm8Das), false},
    {getFunction(BsetImm8Dais), false},
    {getFunction(BsetImm8Adr16), false},
    {getFunction(BsetImm8Adr32), false},
    {getFunction(EoriByteImm8Ds), false},
    {getFunction(EoriByteImm8Ais), false},
    {getFunction(EoriByteImm8Aips), false},
    {getFunction(EoriByteImm8Pais), false},
    {getFunction(EoriByteImm8Das), false},
    {getFunction(EoriByteImm8Dais), false},
    {getFunction(EoriByteImm8Adr16), false},
    {getFunction(EoriByteImm8Adr32), false},
    {getFunction(EoriImm8Ccr), false},
    {getFunction(EoriWordImm16Ds), false},
    {getFunction(EoriWordImm16Ais), false},
    {getFunction(EoriWordImm16Aips), false},
    {getFunction(EoriWordImm16Pais), false},
    {getFunction(EoriWordImm16Das), false},
    {getFunction(EoriWordImm16Dais), false},
    {getFunction(EoriWordImm16Adr16), false},
    {getFunction(EoriWordImm16Adr32), false},
    {getFunction(EoriI16uSr), false},
    {getFunction(EoriLongImm32Ds), false},
    {getFunction(EoriLongImm32Ais), false},
    {getFunction(EoriLongImm32Aips), false},
    {getFunction(EoriLongImm32Pais), false},
    {getFunction(EoriLongImm32Das), false},
    {getFunction(EoriLongImm32Dais), false},
    {getFunction(EoriLongImm32Adr16), false},
    {getFunction(EoriLongImm32Adr32), false},
    {getFunction(CmpiByteImm8Ds), false},
    {getFunction(CmpiByteImm8Ais), false},
    {getFunction(CmpiByteImm8Aips), false},
    {getFunction(CmpiByteImm8Pais), false},
    {getFunction(CmpiByteImm8Das), false},
    {getFunction(CmpiByteImm8Dais), false},
    {getFunction(CmpiByteImm8Adr16), false},
    {getFunction(CmpiByteImm8Adr32), false},
    {getFunction(CmpiWordImm16Ds), false},
    {getFunction(CmpiWordImm16Ais), false},
    {getFunction(CmpiWordImm16Aips), false},
    {getFunction(CmpiWordImm16Pais), false},
    {getFunction(CmpiWordImm16Das), false},
    {getFunction(CmpiWordImm16Dais), false},
    {getFunction(CmpiWordImm16Adr16), false},
    {getFunction(CmpiWordImm16Adr32), false},
    {getFunction(CmpiLongImm32Ds), false},
    {getFunction(CmpiLongImm32Ais), false},
    {getFunction(CmpiLongImm32Aips), false},
    {getFunction(CmpiLongImm32Pais), false},
    {getFunction(CmpiLongImm32Das), false},
    {getFunction(CmpiLongImm32Dais), false},
    {getFunction(CmpiLongImm32Adr16), false},
    {getFunction(CmpiLongImm32Adr32), false},
    {getFunction(MoveByteDsDd), false},
    {getFunction(MoveByteAisDd), false},
    {getFunction(MoveByteAipsDd), false},
    {getFunction(MoveBytePaisDd), true},
    {getFunction(MoveByteDasDd), false},
    {getFunction(MoveByteDaisDd), true},
    {getFunction(MoveByteAdr16Dd), false},
    {getFunction(MoveByteAdr32Dd), false},
    {getFunction(MoveByteDpcDd), false},
    {getFunction(MoveByteDpciDd), true},
    {getFunction(MoveByteImm8Dd), false},
    {getFunction(MoveByteDsAid), false},
    {getFunction(MoveByteAisAid), false},
    {getFunction(MoveByteAipsAid), false},
    {getFunction(MoveBytePaisAid), true},
    {getFunction(MoveByteDasAid), false},
    {getFunction(MoveByteDaisAid), true},
    {getFunction(MoveByteAdr16Aid), false},
    {getFunction(MoveByteAdr32Aid), false},
    {getFunction(MoveByteDpcAid), false},
    {getFunction(MoveByteDpciAid), true},
    {getFunction(MoveByteImm8Aid), false},
    {getFunction(MoveByteDsAipd), false},
    {getFunction(MoveByteAisAipd), false},
    {getFunction(MoveByteAipsAipd), false},
    {getFunction(MoveBytePaisAipd), true},
    {getFunction(MoveByteDasAipd), false},
    {getFunction(MoveByteDaisAipd), true},
    {getFunction(MoveByteAdr16Aipd), false},
    {getFunction(MoveByteAdr32Aipd), false},
    {getFunction(MoveByteDpcAipd), false},
    {getFunction(MoveByteDpciAipd), true},
    {getFunction(MoveByteImm8Aipd), false},
    {getFunction(MoveByteDsPaid), false},
    {getFunction(MoveByteAisPaid), false},
    {getFunction(MoveByteAipsPaid), false},
    {getFunction(MoveBytePaisPaid), true},
    {getFunction(MoveByteDasPaid), false},
    {getFunction(MoveByteDaisPaid), true},
    {getFunction(MoveByteAdr16Paid), false},
    {getFunction(MoveByteAdr32Paid), false},
    {getFunction(MoveByteDpcPaid), false},
    {getFunction(MoveByteDpciPaid), true},
    {getFunction(MoveByteImm8Paid), false},
    {getFunction(MoveByteDsDad), false},
    {getFunction(MoveByteAisDad), false},
    {getFunction(MoveByteAipsDad), false},
    {getFunction(MoveBytePaisDad), true},
    {getFunction(MoveByteDasDad), false},
    {getFunction(MoveByteDaisDad), true},
    {getFunction(MoveByteAdr16Dad), false},
    {getFunction(MoveByteAdr32Dad), false},
    {getFunction(MoveByteDpcDad), false},
    {getFunction(MoveByteDpciDad), true},
    {getFunction(MoveByteImm8Dad), false},
    {getFunction(MoveByteDsDaid), true},
    {getFunction(MoveByteAisDaid), false},
    {getFunction(MoveByteAipsDaid), false},
    {getFunction(MoveBytePaisDaid), true},
    {getFunction(MoveByteDasDaid), false},
    {getFunction(MoveByteDaisDaid), true},
    {getFunction(MoveByteAdr16Daid), false},
    {getFunction(MoveByteAdr32Daid), false},
    {getFunction(MoveByteDpcDaid), false},
    {getFunction(MoveByteDpciDaid), true},
    {getFunction(MoveByteImm8Daid), false},
    {getFunction(MoveByteDsAdr16), false},
    {getFunction(MoveByteAisAdr16), false},
    {getFunction(MoveByteAipsAdr16), false},
    {getFunction(MoveBytePaisAdr16), true},
    {getFunction(MoveByteDasAdr16), false},
    {getFunction(MoveByteDaisAdr16), true},
    {getFunction(MoveByteAdr16Adr16), false},
    {getFunction(MoveByteAdr32Adr16), false},
    {getFunction(MoveByteDpcAdr16), false},
    {getFunction(MoveByteDpciAdr16), true},
    {getFunction(MoveByteImm8Adr16), false},
    {getFunction(MoveByteDsAdr32), false},
    {getFunction(MoveByteAisAdr32), false},
    {getFunction(MoveByteAipsAdr32), false},
    {getFunction(MoveBytePaisAdr32), true},
    {getFunction(MoveByteDasAdr32), false},
    {getFunction(MoveByteDaisAdr32), true},
    {getFunction(MoveByteAdr16Adr32), false},
    {getFunction(MoveByteAdr32Adr32), false},
    {getFunction(MoveByteDpcAdr32), false},
    {getFunction(MoveByteDpciAdr32), true},
    {getFunction(MoveByteImm8Adr32), false},
    {getFunction(MoveLongDsDd), false},
    {getFunction(MoveLongAsDd), false},
    {getFunction(MoveLongAisDd), false},
    {getFunction(MoveLongAipsDd), false},
    {getFunction(MoveLongPaisDd), true},
    {getFunction(MoveLongDasDd), false},
    {getFunction(MoveLongDaisDd), true},
    {getFunction(MoveLongAdr16Dd), false},
    {getFunction(MoveLongAdr32Dd), false},
    {getFunction(MoveLongDpcDd), false},
    {getFunction(MoveLongDpciDd), true},
    {getFunction(MoveLongImm32Dd), false},
    {getFunction(MoveaLongDsAd), false},
    {getFunction(MoveaLongAsAd), false},
    {getFunction(MoveaLongAisAd), false},
    {getFunction(MoveaLongAipsAd), false},
    {getFunction(MoveaLongPaisAd), true},
    {getFunction(MoveaLongDasAd), false},
    {getFunction(MoveaLongDaisAd), true},
    {getFunction(MoveaLongAdr16Ad), false},
    {getFunction(MoveaLongAdr32Ad), false},
    {getFunction(MoveaLongDpcAd), false},
    {getFunction(MoveaLongDpciAd), true},
    {getFunction(MoveaLongImm32Ad), false},
    {getFunction(MoveLongDsAid), false},
    {getFunction(MoveLongAsAid), false},
    {getFunction(MoveLongAisAid), false},
    {getFunction(MoveLongAipsAid), false},
    {getFunction(MoveLongPaisAid), true},
    {getFunction(MoveLongDasAid), false},
    {getFunction(MoveLongDaisAid), true},
    {getFunction(MoveLongAdr16Aid), false},
    {getFunction(MoveLongAdr32Aid), false},
    {getFunction(MoveLongDpcAid), false},
    {getFunction(MoveLongDpciAid), true},
    {getFunction(MoveLongImm32Aid), false},
    {getFunction(MoveLongDsAipd), false},
    {getFunction(MoveLongAsAipd), false},
    {getFunction(MoveLongAisAipd), false},
    {getFunction(MoveLongAipsAipd), false},
    {getFunction(MoveLongPaisAipd), true},
    {getFunction(MoveLongDasAipd), false},
    {getFunction(MoveLongDaisAipd), true},
    {getFunction(MoveLongAdr16Aipd), false},
    {getFunction(MoveLongAdr32Aipd), false},
    {getFunction(MoveLongDpcAipd), false},
    {getFunction(MoveLongDpciAipd), true},
    {getFunction(MoveLongImm32Aipd), false},
    {getFunction(MoveLongDsPaid), false},
    {getFunction(MoveLongAsPaid), false},
    {getFunction(MoveLongAisPaid), false},
    {getFunction(MoveLongAipsPaid), false},
    {getFunction(MoveLongPaisPaid), true},
    {getFunction(MoveLongDasPaid), false},
    {getFunction(MoveLongDaisPaid), true},
    {getFunction(MoveLongAdr16Paid), false},
    {getFunction(MoveLongAdr32Paid), false},
    {getFunction(MoveLongDpcPaid), false},
    {getFunction(MoveLongDpciPaid), true},
    {getFunction(MoveLongImm32Paid), false},
    {getFunction(MoveLongDsDad), false},
    {getFunction(MoveLongAsDad), false},
    {getFunction(MoveLongAisDad), false},
    {getFunction(MoveLongAipsDad), false},
    {getFunction(MoveLongPaisDad), true},
    {getFunction(MoveLongDasDad), false},
    {getFunction(MoveLongDaisDad), true},
    {getFunction(MoveLongAdr16Dad), false},
    {getFunction(MoveLongAdr32Dad), false},
    {getFunction(MoveLongDpcDad), false},
    {getFunction(MoveLongDpciDad), true},
    {getFunction(MoveLongImm32Dad), false},
    {getFunction(MoveLongDsDaid), true},
    {getFunction(MoveLongAsDaid), true},
    {getFunction(MoveLongAisDaid), false},
    {getFunction(MoveLongAipsDaid), false},
    {getFunction(MoveLongPaisDaid), true},
    {getFunction(MoveLongDasDaid), false},
    {getFunction(MoveLongDaisDaid), true},
    {getFunction(MoveLongAdr16Daid), false},
    {getFunction(MoveLongAdr32Daid), false},
    {getFunction(MoveLongDpcDaid), false},
    {getFunction(MoveLongDpciDaid), true},
    {getFunction(MoveLongImm32Daid), false},
    {getFunction(MoveLongDsAdr16), false},
    {getFunction(MoveLongAsAdr16), false},
    {getFunction(MoveLongAisAdr16), false},
    {getFunction(MoveLongAipsAdr16), false},
    {getFunction(MoveLongPaisAdr16), true},
    {getFunction(MoveLongDasAdr16), false},
    {getFunction(MoveLongDaisAdr16), true},
    {getFunction(MoveLongAdr16Adr16), false},
    {getFunction(MoveLongAdr32Adr16), false},
    {getFunction(MoveLongDpcAdr16), false},
    {getFunction(MoveLongDpciAdr16), true},
    {getFunction(MoveLongImm32Adr16), false},
    {getFunction(MoveLongDsAdr32), false},
    {getFunction(MoveLongAsAdr32), false},
    {getFunction(MoveLongAisAdr32), false},
    {getFunction(MoveLongAipsAdr32), false},
    {getFunction(MoveLongPaisAdr32), true},
    {getFunction(MoveLongDasAdr32), false},
    {getFunction(MoveLongDaisAdr32), true},
    {getFunction(MoveLongAdr16Adr32), false},
    {getFunction(MoveLongAdr32Adr32), false},
    {getFunction(MoveLongDpcAdr32), false},
    {getFunction(MoveLongDpciAdr32), true},
    {getFunction(MoveLongImm32Adr32), false},
    {getFunction(MoveWordDsDd), false},
    {getFunction(MoveWordAsDd), false},
    {getFunction(MoveWordAisDd), false},
    {getFunction(MoveWordAipsDd), false},
    {getFunction(MoveWordPaisDd), true},
    {getFunction(MoveWordDasDd), false},
    {getFunction(MoveWordDaisDd), true},
    {getFunction(MoveWordAdr16Dd), false},
    {getFunction(MoveWordAdr32Dd), false},
    {getFunction(MoveWordDpcDd), false},
    {getFunction(MoveWordDpciDd), true},
    {getFunction(MoveWordImm16Dd), false},
    {getFunction(MoveaWordDsAd), false},
    {getFunction(MoveaWordAsAd), false},
    {getFunction(MoveaWordAisAd), false},
    {getFunction(MoveaWordAipsAd), false},
    {getFunction(MoveaWordPaisAd), true},
    {getFunction(MoveaWordDasAd), false},
    {getFunction(MoveaWordDaisAd), true},
    {getFunction(MoveaWordAdr16Ad), false},
    {getFunction(MoveaWordAdr32Ad), false},
    {getFunction(MoveaWordDpcAd), false},
    {getFunction(MoveaWordDpciAd), true},
    {getFunction(MoveaWordImm16Ad), false},
    {getFunction(MoveWordDsAid), false},
    {getFunction(MoveWordAsAid), false},
    {getFunction(MoveWordAisAid), false},
    {getFunction(MoveWordAipsAid), false},
    {getFunction(MoveWordPaisAid), true},
    {getFunction(MoveWordDasAid), false},
    {getFunction(MoveWordDaisAid), true},
    {getFunction(MoveWordAdr16Aid), false},
    {getFunction(MoveWordAdr32Aid), false},
    {getFunction(MoveWordDpcAid), false},
    {getFunction(MoveWordDpciAid), true},
    {getFunction(MoveWordImm16Aid), false},
    {getFunction(MoveWordDsAipd), false},
    {getFunction(MoveWordAsAipd), false},
    {getFunction(MoveWordAisAipd), false},
    {getFunction(MoveWordAipsAipd), false},
    {getFunction(MoveWordPaisAipd), true},
    {getFunction(MoveWordDasAipd), false},
    {getFunction(MoveWordDaisAipd), true},
    {getFunction(MoveWordAdr16Aipd), false},
    {getFunction(MoveWordAdr32Aipd), false},
    {getFunction(MoveWordDpcAipd), false},
    {getFunction(MoveWordDpciAipd), true},
    {getFunction(MoveWordImm16Aipd), false},
    {getFunction(MoveWordDsPaid), false},
    {getFunction(MoveWordAsPaid), false},
    {getFunction(MoveWordAisPaid), false},
    {getFunction(MoveWordAipsPaid), false},
    {getFunction(MoveWordPaisPaid), true},
    {getFunction(MoveWordDasPaid), false},
    {getFunction(MoveWordDaisPaid), true},
    {getFunction(MoveWordAdr16Paid), false},
    {getFunction(MoveWordAdr32Paid), false},
    {getFunction(MoveWordDpcPaid), false},
    {getFunction(MoveWordDpciPaid), true},
    {getFunction(MoveWordImm16Paid), false},
    {getFunction(MoveWordDsDad), false},
    {getFunction(MoveWordAsDad), false},
    {getFunction(MoveWordAisDad), false},
    {getFunction(MoveWordAipsDad), false},
    {getFunction(MoveWordPaisDad), true},
    {getFunction(MoveWordDasDad), false},
    {getFunction(MoveWordDaisDad), true},
    {getFunction(MoveWordAdr16Dad), false},
    {getFunction(MoveWordAdr32Dad), false},
    {getFunction(MoveWordDpcDad), false},
    {getFunction(MoveWordDpciDad), true},
    {getFunction(MoveWordImm16Dad), false},
    {getFunction(MoveWordDsDaid), true},
    {getFunction(MoveWordAsDaid), true},
    {getFunction(MoveWordAisDaid), false},
    {getFunction(MoveWordAipsDaid), false},
    {getFunction(MoveWordPaisDaid), true},
    {getFunction(MoveWordDasDaid), false},
    {getFunction(MoveWordDaisDaid), true},
    {getFunction(MoveWordAdr16Daid), false},
    {getFunction(MoveWordAdr32Daid), false},
    {getFunction(MoveWordDpcDaid), false},
    {getFunction(MoveWordDpciDaid), true},
    {getFunction(MoveWordImm16Daid), false},
    {getFunction(MoveWordDsAdr16), false},
    {getFunction(MoveWordAsAdr16), false},
    {getFunction(MoveWordAisAdr16), false},
    {getFunction(MoveWordAipsAdr16), false},
    {getFunction(MoveWordPaisAdr16), true},
    {getFunction(MoveWordDasAdr16), false},
    {getFunction(MoveWordDaisAdr16), true},
    {getFunction(MoveWordAdr16Adr16), false},
    {getFunction(MoveWordAdr32Adr16), false},
    {getFunction(MoveWordDpcAdr16), false},
    {getFunction(MoveWordDpciAdr16), true},
    {getFunction(MoveWordImm16Adr16), false},
    {getFunction(MoveWordDsAdr32), false},
    {getFunction(MoveWordAsAdr32), false},
    {getFunction(MoveWordAisAdr32), false},
    {getFunction(MoveWordAipsAdr32), false},
    {getFunction(MoveWordPaisAdr32), true},
    {getFunction(MoveWordDasAdr32), false},
    {getFunction(MoveWordDaisAdr32), true},
    {getFunction(MoveWordAdr16Adr32), false},
    {getFunction(MoveWordAdr32Adr32), false},
    {getFunction(MoveWordDpcAdr32), false},
    {getFunction(MoveWordDpciAdr32), true},
    {getFunction(MoveWordImm16Adr32), false},
    {getFunction(NegxByteDs), false},
    {getFunction(NegxByteAis), false},
    {getFunction(NegxByteAips), false},
    {getFunction(NegxBytePais), true},
    {getFunction(NegxByteDas), false},
    {getFunction(NegxByteDais), true},
    {getFunction(NegxByteAdr16), false},
    {getFunction(NegxByteAdr32), false},
    {getFunction(NegxWordDs), false},
    {getFunction(NegxWordAis), false},
    {getFunction(NegxWordAips), false},
    {getFunction(NegxWordPais), true},
    {getFunction(NegxWordDas), false},
    {getFunction(NegxWordDais), true},
    {getFunction(NegxWordAdr16), false},
    {getFunction(NegxWordAdr32), false},
    {getFunction(NegxLongDs), false},
    {getFunction(NegxLongAis), false},
    {getFunction(NegxLongAips), false},
    {getFunction(NegxLongPais), true},
    {getFunction(NegxLongDas), false},
    {getFunction(NegxLongDais), true},
    {getFunction(NegxLongAdr16), false},
    {getFunction(NegxLongAdr32), false},
    {getFunction(MoveSrDs), false},
    {getFunction(MoveSrAis), false},
    {getFunction(MoveSrAips), false},
    {getFunction(MoveSrPais), true},
    {getFunction(MoveSrDas), false},
    {getFunction(MoveSrDais), true},
    {getFunction(MoveSrAdr16), false},
    {getFunction(MoveSrAdr32), false},
    {getFunction(ChkWordDsDd), true},
    {getFunction(ChkWordAisDd), false},
    {getFunction(ChkWordAipsDd), false},
    {getFunction(ChkWordPaisDd), true},
    {getFunction(ChkWordDasDd), false},
    {getFunction(ChkWordDaisDd), true},
    {getFunction(ChkWordAdr16Dd), false},
    {getFunction(ChkWordAdr32Dd), false},
    {getFunction(ChkWordDpcDd), false},
    {getFunction(ChkWordDpciDd), true},
    {getFunction(ChkWordImm16Dd), false},
    {getFunction(LeaAisAd), false},
    {getFunction(LeaDasAd), false},
    {getFunction(LeaDaisAd), true},
    {getFunction(LeaAdr16Ad), false},
    {getFunction(LeaAdr32Ad), false},
    {getFunction(LeaDpcAd), false},
    {getFunction(LeaDpciAd), true},
    {getFunction(ClrByteDs), false},
    {getFunction(ClrByteAis), false},
    {getFunction(ClrByteAips), false},
    {getFunction(ClrBytePais), true},
    {getFunction(ClrByteDas), false},
    {getFunction(ClrByteDais), true},
    {getFunction(ClrByteAdr16), false},
    {getFunction(ClrByteAdr32), false},
    {getFunction(ClrWordDs), false},
    {getFunction(ClrWordAis), false},
    {getFunction(ClrWordAips), false},
    {getFunction(ClrWordPais), true},
    {getFunction(ClrWordDas), false},
    {getFunction(ClrWordDais), true},
    {getFunction(ClrWordAdr16), false},
    {getFunction(ClrWordAdr32), false},
    {getFunction(ClrLongDs), false},
    {getFunction(ClrLongAis), false},
    {getFunction(ClrLongAips), false},
    {getFunction(ClrLongPais), true},
    {getFunction(ClrLongDas), false},
    {getFunction(ClrLongDais), true},
    {getFunction(ClrLongAdr16), false},
    {getFunction(ClrLongAdr32), false},
    {getFunction(NegByteDs), false},
    {getFunction(NegByteAis), false},
    {getFunction(NegByteAips), false},
    {getFunction(NegBytePais), true},
    {getFunction(NegByteDas), false},
    {getFunction(NegByteDais), true},
    {getFunction(NegByteAdr16), false},
    {getFunction(NegByteAdr32), false},
    {getFunction(NegWordDs), false},
    {getFunction(NegWordAis), false},
    {getFunction(NegWordAips), false},
    {getFunction(NegWordPais), true},
    {getFunction(NegWordDas), false},
    {getFunction(NegWordDais), true},
    {getFunction(NegWordAdr16), false},
    {getFunction(NegWordAdr32), false},
    {getFunction(NegLongDs), false},
    {getFunction(NegLongAis), false},
    {getFunction(NegLongAips), false},
    {getFunction(NegLongPais), true},
    {getFunction(NegLongDas), false},
    {getFunction(NegLongDais), true},
    {getFunction(NegLongAdr16), false},
    {getFunction(NegLongAdr32), false},
    {getFunction(MoveDsCcr), true},
    {getFunction(MoveAisCcr), false},
    {getFunction(MoveAipsCcr), false},
    {getFunction(MovePaisCcr), true},
    {getFunction(MoveDasCcr), false},
    {getFunction(MoveDaisCcr), true},
    {getFunction(MoveAdr16Ccr), false},
    {getFunction(MoveAdr32Ccr), false},
    {getFunction(MoveDpcCcr), false},
    {getFunction(MoveDpciCcr), true},
    {getFunction(MoveImm8Ccr), false},
    {getFunction(NotByteDs), false},
    {getFunction(NotByteAis), false},
    {getFunction(NotByteAips), false},
    {getFunction(NotBytePais), true},
    {getFunction(NotByteDas), false},
    {getFunction(NotByteDais), true},
    {getFunction(NotByteAdr16), false},
    {getFunction(NotByteAdr32), false},
    {getFunction(NotWordDs), false},
    {getFunction(NotWordAis), false},
    {getFunction(NotWordAips), false},
    {getFunction(NotWordPais), true},
    {getFunction(NotWordDas), false},
    {getFunction(NotWordDais), true},
    {getFunction(NotWordAdr16), false},
    {getFunction(NotWordAdr32), false},
    {getFunction(NotLongDs), false},
    {getFunction(NotLongAis), false},
    {getFunction(NotLongAips), false},
    {getFunction(NotLongPais), true},
    {getFunction(NotLongDas), false},
    {getFunction(NotLongDais), true},
    {getFunction(NotLongAdr16), false},
    {getFunction(NotLongAdr32), false},
    {getFunction(MoveDsSr), true},
    {getFunction(MoveAisSr), false},
    {getFunction(MoveAipsSr), false},
    {getFunction(MovePaisSr), true},
    {getFunction(MoveDasSr), false},
    {getFunction(MoveDaisSr), true},
    {getFunction(MoveAdr16Sr), false},
    {getFunction(MoveAdr32Sr), false},
    {getFunction(MoveDpcSr), false},
    {getFunction(MoveDpciSr), true},
    {getFunction(MoveI16uSr), false},
    {getFunction(NbcdByteDs), false},
    {getFunction(NbcdByteAis), false},
    {getFunction(NbcdByteAips), false},
    {getFunction(NbcdBytePais), true},
    {getFunction(NbcdByteDas), false},
    {getFunction(NbcdByteDais), true},
    {getFunction(NbcdByteAdr16), false},
    {getFunction(NbcdByteAdr32), false},
    {getFunction(SwapDs), false},
    {getFunction(PeaAis), false},
    {getFunction(PeaDas), false},
    {getFunction(PeaDais), true},
    {getFunction(PeaAdr16), false},
    {getFunction(PeaAdr32), false},
    {getFunction(PeaDpc), false},
    {getFunction(PeaDpci), true},
    {getFunction(ExtWordDs), false},
    {getFunction(MovemWordListAis), false},
    {getFunction(MovemWordListpPais), false},
    {getFunction(MovemWordListDas), false},
    {getFunction(MovemWordListDais), false},
    {getFunction(MovemWordListAdr16), false},
    {getFunction(MovemWordListAdr32), false},
    {getFunction(ExtLongDs), false},
    {getFunction(MovemLongListAis), false},
    {getFunction(MovemLongListpPais), false},
    {getFunction(MovemLongListDas), false},
    {getFunction(MovemLongListDais), false},
    {getFunction(MovemLongListAdr16), false},
    {getFunction(MovemLongListAdr32), false},
    {getFunction(TstByteDs), false},
    {getFunction(TstByteAis), false},
    {getFunction(TstByteAips), false},
    {getFunction(TstBytePais), true},
    {getFunction(TstByteDas), false},
    {getFunction(TstByteDais), true},
    {getFunction(TstByteAdr16), false},
    {getFunction(TstByteAdr32), false},
    {getFunction(TstWordDs), false},
    {getFunction(TstWordAis), false},
    {getFunction(TstWordAips), false},
    {getFunction(TstWordPais), true},
    {getFunction(TstWordDas), false},
    {getFunction(TstWordDais), true},
    {getFunction(TstWordAdr16), false},
    {getFunction(TstWordAdr32), false},
    {getFunction(TstLongDs), false},
    {getFunction(TstLongAis), false},
    {getFunction(TstLongAips), false},
    {getFunction(TstLongPais), true},
    {getFunction(TstLongDas), false},
    {getFunction(TstLongDais), true},
    {getFunction(TstLongAdr16), false},
    {getFunction(TstLongAdr32), false},
    {getFunction(TasDs), false},
    {getFunction(TasAis), false},
    {getFunction(TasAips), false},
    {getFunction(TasPais), true},
    {getFunction(TasDas), false},
    {getFunction(TasDais), true},
    {getFunction(TasAdr16), false},
    {getFunction(TasAdr32), false},
    {getFunction(MovemWordAisList), false},
    {getFunction(MovemWordAipsList), false},
    {getFunction(MovemWordDasList), false},
    {getFunction(MovemWordDaisList), false},
    {getFunction(MovemWordAdr16List), false},
    {getFunction(MovemWordAdr32List), false},
    {getFunction(MovemWordDpcList), false},
    {getFunction(MovemWordDpciList), false},
    {getFunction(MovemLongAisList), false},
    {getFunction(MovemLongAipsList), false},
    {getFunction(MovemLongDasList), false},
    {getFunction(MovemLongDaisList), false},
    {getFunction(MovemLongAdr16List), false},
    {getFunction(MovemLongAdr32List), false},
    {getFunction(MovemLongDpcList), false},
    {getFunction(MovemLongDpciList), false},
    {getFunction(TrapImm4), true},
    {getFunction(LinkAsImm16), false},
    {getFunction(UnlkAs), false},
    {getFunction(MoveAsUsp), false},
    {getFunction(MoveUspAs), false},
    {getFunction(Reset), true},
    {getFunction(Nop), false},
    {getFunction(StopI16u), true},
    {getFunction(Rte), false},
    {getFunction(Rts), false},
    {getFunction(Trapv), false},
    {getFunction(Rtr), false},
    {getFunction(JsrAis), false},
    {getFunction(JsrDas), true},
    {getFunction(JsrDais), true},
    {getFunction(JsrAdr16), true},
    {getFunction(JsrAdr32), false},
    {getFunction(JsrDpc), true},
    {getFunction(JsrDpci), true},
    {getFunction(JmpAis), false},
    {getFunction(JmpDas), true},
    {getFunction(JmpDais), true},
    {getFunction(JmpAdr16), true},
    {getFunction(JmpAdr32), false},
    {getFunction(JmpDpc), true},
    {getFunction(JmpDpci), true},
    {getFunction(AddqByteImm3Ds), false},
    {getFunction(AddqByteImm3Ais), false},
    {getFunction(AddqByteImm3Aips), false},
    {getFunction(AddqByteImm3Pais), true},
    {getFunction(AddqByteImm3Das), false},
    {getFunction(AddqByteImm3Dais), true},
    {getFunction(AddqByteImm3Adr16), false},
    {getFunction(AddqByteImm3Adr32), false},
    {getFunction(AddqWordImm3Ds), false},
    {getFunction(AddqWordImm3As), false},
    {getFunction(AddqWordImm3Ais), false},
    {getFunction(AddqWordImm3Aips), false},
    {getFunction(AddqWordImm3Pais), true},
    {getFunction(AddqWordImm3Das), false},
    {getFunction(AddqWordImm3Dais), true},
    {getFunction(AddqWordImm3Adr16), false},
    {getFunction(AddqWordImm3Adr32), false},
    {getFunction(AddqLongImm3Ds), false},
    {getFunction(AddqLongImm3As), false},
    {getFunction(AddqLongImm3Ais), false},
    {getFunction(AddqLongImm3Aips), false},
    {getFunction(AddqLongImm3Pais), true},
    {getFunction(AddqLongImm3Das), false},
    {getFunction(AddqLongImm3Dais), true},
    {getFunction(AddqLongImm3Adr16), false},
    {getFunction(AddqLongImm3Adr32), false},
    {getFunction(StDs), false},
    {getFunction(DbtDsRel16), true},
    {getFunction(StAis), false},
    {getFunction(StAips), false},
    {getFunction(StPais), true},
    {getFunction(StDas), false},
    {getFunction(StDais), true},
    {getFunction(StAdr16), false},
    {getFunction(StAdr32), false},
    {getFunction(SubqByteImm3Ds), false},
    {getFunction(SubqByteImm3Ais), false},
    {getFunction(SubqByteImm3Aips), false},
    {getFunction(SubqByteImm3Pais), true},
    {getFunction(SubqByteImm3Das), false},
    {getFunction(SubqByteImm3Dais), true},
    {getFunction(SubqByteImm3Adr16), false},
    {getFunction(SubqByteImm3Adr32), false},
    {getFunction(SubqWordImm3Ds), false},
    {getFunction(SubqWordImm3As), false},
    {getFunction(SubqWordImm3Ais), false},
    {getFunction(SubqWordImm3Aips), false},
    {getFunction(SubqWordImm3Pais), true},
    {getFunction(SubqWordImm3Das), false},
    {getFunction(SubqWordImm3Dais), true},
    {getFunction(SubqWordImm3Adr16), false},
    {getFunction(SubqWordImm3Adr32), false},
    {getFunction(SubqLongImm3Ds), false},
    {getFunction(SubqLongImm3As), false},
    {getFunction(SubqLongImm3Ais), false},
    {getFunction(SubqLongImm3Aips), false},
    {getFunction(SubqLongImm3Pais), true},
    {getFunction(SubqLongImm3Das), false},
    {getFunction(SubqLongImm3Dais), true},
    {getFunction(SubqLongImm3Adr16), false},
    {getFunction(SubqLongImm3Adr32), false},
    {getFunction(SfDs), false},
    {getFunction(DbraDsRel16), true},
    {getFunction(SfAis), false},
    {getFunction(SfAips), false},
    {getFunction(SfPais), true},
    {getFunction(SfDas), false},
    {getFunction(SfDais), true},
    {getFunction(SfAdr16), false},
    {getFunction(SfAdr32), false},
    {getFunction(ShiDs), false},
    {getFunction(DbhiDsRel16), true},
    {getFunction(ShiAis), false},
    {getFunction(ShiAips), false},
    {getFunction(ShiPais), true},
    {getFunction(ShiDas), false},
    {getFunction(ShiDais), true},
    {getFunction(ShiAdr16), false},
    {getFunction(ShiAdr32), false},
    {getFunction(SlsDs), false},
    {getFunction(DblsDsRel16), true},
    {getFunction(SlsAis), false},
    {getFunction(SlsAips), false},
    {getFunction(SlsPais), true},
    {getFunction(SlsDas), false},
    {getFunction(SlsDais), true},
    {getFunction(SlsAdr16), false},
    {getFunction(SlsAdr32), false},
    {getFunction(SccDs), false},
    {getFunction(DbccDsRel16), true},
    {getFunction(SccAis), false},
    {getFunction(SccAips), false},
    {getFunction(SccPais), true},
    {getFunction(SccDas), false},
    {getFunction(SccDais), true},
    {getFunction(SccAdr16), false},
    {getFunction(SccAdr32), false},
    {getFunction(ScsDs), false},
    {getFunction(DbcsDsRel16), true},
    {getFunction(ScsAis), false},
    {getFunction(ScsAips), false},
    {getFunction(ScsPais), true},
    {getFunction(ScsDas), false},
    {getFunction(ScsDais), true},
    {getFunction(ScsAdr16), false},
    {getFunction(ScsAdr32), false},
    {getFunction(SneDs), false},
    {getFunction(DbneDsRel16), true},
    {getFunction(SneAis), false},
    {getFunction(SneAips), false},
    {getFunction(SnePais), true},
    {getFunction(SneDas), false},
    {getFunction(SneDais), true},
    {getFunction(SneAdr16), false},
    {getFunction(SneAdr32), false},
    {getFunction(SeqDs), false},
    {getFunction(DbeqDsRel16), true},
    {getFunction(SeqAis), false},
    {getFunction(SeqAips), false},
    {getFunction(SeqPais), true},
    {getFunction(SeqDas), false},
    {getFunction(SeqDais), true},
    {getFunction(SeqAdr16), false},
    {getFunction(SeqAdr32), false},
    {getFunction(SvcDs), false},
    {getFunction(DbvcDsRel16), true},
    {getFunction(SvcAis), false},
    {getFunction(SvcAips), false},
    {getFunction(SvcPais), true},
    {getFunction(SvcDas), false},
    {getFunction(SvcDais), true},
    {getFunction(SvcAdr16), false},
    {getFunction(SvcAdr32), false},
    {getFunction(SvsDs), false},
    {getFunction(DbvsDsRel16), true},
    {getFunction(SvsAis), false},
    {getFunction(SvsAips), false},
    {getFunction(SvsPais), true},
    {getFunction(SvsDas), false},
    {getFunction(SvsDais), true},
    {getFunction(SvsAdr16), false},
    {getFunction(SvsAdr32), false},
    {getFunction(SplDs), false},
    {getFunction(DbplDsRel16), true},
    {getFunction(SplAis), false},
    {getFunction(SplAips), false},
    {getFunction(SplPais), true},
    {getFunction(SplDas), false},
    {getFunction(SplDais), true},
    {getFunction(SplAdr16), false},
    {getFunction(SplAdr32), false},
    {getFunction(SmiDs), false},
    {getFunction(DbmiDsRel16), true},
    {getFunction(SmiAis), false},
    {getFunction(SmiAips), false},
    {getFunction(SmiPais), true},
    {getFunction(SmiDas), false},
    {getFunction(SmiDais), true},
    {getFunction(SmiAdr16), false},
    {getFunction(SmiAdr32), false},
    {getFunction(SgeDs), false},
    {getFunction(DbgeDsRel16), true},
    {getFunction(SgeAis), false},
    {getFunction(SgeAips), false},
    {getFunction(SgePais), true},
    {getFunction(SgeDas), false},
    {getFunction(SgeDais), true},
    {getFunction(SgeAdr16), false},
    {getFunction(SgeAdr32), false},
    {getFunction(SltDs), false},
    {getFunction(DbltDsRel16), true},
    {getFunction(SltAis), false},
    {getFunction(SltAips), false},
    {getFunction(SltPais), true},
    {getFunction(SltDas), false},
    {getFunction(SltDais), true},
    {getFunction(SltAdr16), false},
    {getFunction(SltAdr32), false},
    {getFunction(SgtDs), false},
    {getFunction(DbgtDsRel16), true},
    {getFunction(SgtAis), false},
    {getFunction(SgtAips), false},
    {getFunction(SgtPais), true},
    {getFunction(SgtDas), false},
    {getFunction(SgtDais), true},
    {getFunction(SgtAdr16), false},
    {getFunction(SgtAdr32), false},
    {getFunction(SleDs), false},
    {getFunction(DbleDsRel16), true},
    {getFunction(SleAis), false},
    {getFunction(SleAips), false},
    {getFunction(SlePais), true},
    {getFunction(SleDas), false},
    {getFunction(SleDais), true},
    {getFunction(SleAdr16), false},
    {getFunction(SleAdr32), false},
    {getFunction(BraRel16), true},
    {getFunction(BraRel8), true},
    {getFunction(BsrRel16), true},
    {getFunction(BsrRel8), true},
    {getFunction(BhiRel16), true},
    {getFunction(BhiRel8), true},
    {getFunction(BlsRel16), true},
    {getFunction(BlsRel8), true},
    {getFunction(BccRel16), true},
    {getFunction(BccRel8), true},
    {getFunction(BcsRel16), true},
    {getFunction(BcsRel8), true},
    {getFunction(BneRel16), true},
    {getFunction(BneRel8), true},
    {getFunction(BeqRel16), true},
    {getFunction(BeqRel8), true},
    {getFunction(BvcRel16), true},
    {getFunction(BvcRel8), true},
    {getFunction(BvsRel16), true},
    {getFunction(BvsRel8), true},
    {getFunction(BplRel16), true},
    {getFunction(BplRel8), true},
    {getFunction(BmiRel16), true},
    {getFunction(BmiRel8), true},
    {getFunction(BgeRel16), true},
    {getFunction(BgeRel8), true},
    {getFunction(BltRel16), true},
    {getFunction(BltRel8), true},
    {getFunction(BgtRel16), true},
    {getFunction(BgtRel8), true},
    {getFunction(BleRel16), true},
    {getFunction(BleRel8), true},
    {getFunction(MoveqImm8oDd), false},
    {getFunction(OrByteDsDd), false},
    {getFunction(OrByteAisDd), false},
    {getFunction(OrByteAipsDd), false},
    {getFunction(OrBytePaisDd), true},
    {getFunction(OrByteDasDd), false},
    {getFunction(OrByteDaisDd), true},
    {getFunction(OrByteAdr16Dd), false},
    {getFunction(OrByteAdr32Dd), false},
    {getFunction(OrByteDpcDd), false},
    {getFunction(OrByteDpciDd), true},
    {getFunction(OrByteImm8Dd), false},
    {getFunction(OrWordDsDd), false},
    {getFunction(OrWordAisDd), false},
    {getFunction(OrWordAipsDd), false},
    {getFunction(OrWordPaisDd), true},
    {getFunction(OrWordDasDd), false},
    {getFunction(OrWordDaisDd), true},
    {getFunction(OrWordAdr16Dd), false},
    {getFunction(OrWordAdr32Dd), false},
    {getFunction(OrWordDpcDd), false},
    {getFunction(OrWordDpciDd), true},
    {getFunction(OrWordImm16Dd), false},
    {getFunction(OrLongDsDd), false},
    {getFunction(OrLongAisDd), false},
    {getFunction(OrLongAipsDd), false},
    {getFunction(OrLongPaisDd), true},
    {getFunction(OrLongDasDd), false},
    {getFunction(OrLongDaisDd), true},
    {getFunction(OrLongAdr16Dd), false},
    {getFunction(OrLongAdr32Dd), false},
    {getFunction(OrLongDpcDd), false},
    {getFunction(OrLongDpciDd), true},
    {getFunction(OrLongImm32Dd), false},
    {getFunction(DivuWordDsDd), true},
    {getFunction(DivuWordAisDd), false},
    {getFunction(DivuWordAipsDd), false},
    {getFunction(DivuWordPaisDd), true},
    {getFunction(DivuWordDasDd), false},
    {getFunction(DivuWordDaisDd), true},
    {getFunction(DivuWordAdr16Dd), false},
    {getFunction(DivuWordAdr32Dd), false},
    {getFunction(DivuWordDpcDd), false},
    {getFunction(DivuWordDpciDd), true},
    {getFunction(DivuWordImm16Dd), false},
    {getFunction(SbcdDsDd), false},
    {getFunction(SbcdPaisPaid), true},
    {getFunction(OrByteDdAis), false},
    {getFunction(OrByteDdAips), false},
    {getFunction(OrByteDdPais), true},
    {getFunction(OrByteDdDas), false},
    {getFunction(OrByteDdDais), true},
    {getFunction(OrByteDdAdr16), false},
    {getFunction(OrByteDdAdr32), false},
    {getFunction(OrWordDdAis), false},
    {getFunction(OrWordDdAips), false},
    {getFunction(OrWordDdPais), true},
    {getFunction(OrWordDdDas), false},
    {getFunction(OrWordDdDais), true},
    {getFunction(OrWordDdAdr16), false},
    {getFunction(OrWordDdAdr32), false},
    {getFunction(OrLongDdAis), false},
    {getFunction(OrLongDdAips), false},
    {getFunction(OrLongDdPais), true},
    {getFunction(OrLongDdDas), false},
    {getFunction(OrLongDdDais), true},
    {getFunction(OrLongDdAdr16), false},
    {getFunction(OrLongDdAdr32), false},
    {getFunction(DivsWordDsDd), true},
    {getFunction(DivsWordAisDd), false},
    {getFunction(DivsWordAipsDd), false},
    {getFunction(DivsWordPaisDd), true},
    {getFunction(DivsWordDasDd), false},
    {getFunction(DivsWordDaisDd), true},
    {getFunction(DivsWordAdr16Dd), false},
    {getFunction(DivsWordAdr32Dd), false},
    {getFunction(DivsWordDpcDd), false},
    {getFunction(DivsWordDpciDd), true},
    {getFunction(DivsWordImm16Dd), false},
    {getFunction(SubByteDsDd), false},
    {getFunction(SubByteAisDd), false},
    {getFunction(SubByteAipsDd), false},
    {getFunction(SubBytePaisDd), true},
    {getFunction(SubByteDasDd), false},
    {getFunction(SubByteDaisDd), true},
    {getFunction(SubByteAdr16Dd), false},
    {getFunction(SubByteAdr32Dd), false},
    {getFunction(SubByteDpcDd), false},
    {getFunction(SubByteDpciDd), true},
    {getFunction(SubByteImm8Dd), false},
    {getFunction(SubWordDsDd), false},
    {getFunction(SubWordAsDd), false},
    {getFunction(SubWordAisDd), false},
    {getFunction(SubWordAipsDd), false},
    {getFunction(SubWordPaisDd), true},
    {getFunction(SubWordDasDd), false},
    {getFunction(SubWordDaisDd), true},
    {getFunction(SubWordAdr16Dd), false},
    {getFunction(SubWordAdr32Dd), false},
    {getFunction(SubWordDpcDd), false},
    {getFunction(SubWordDpciDd), true},
    {getFunction(SubWordImm16Dd), false},
    {getFunction(SubLongDsDd), false},
    {getFunction(SubLongAsDd), false},
    {getFunction(SubLongAisDd), false},
    {getFunction(SubLongAipsDd), false},
    {getFunction(SubLongPaisDd), true},
    {getFunction(SubLongDasDd), false},
    {getFunction(SubLongDaisDd), true},
    {getFunction(SubLongAdr16Dd), false},
    {getFunction(SubLongAdr32Dd), false},
    {getFunction(SubLongDpcDd), false},
    {getFunction(SubLongDpciDd), true},
    {getFunction(SubLongImm32Dd), false},
    {getFunction(SubaWordDsAd), false},
    {getFunction(SubaWordAsAd), false},
    {getFunction(SubaWordAisAd), false},
    {getFunction(SubaWordAipsAd), false},
    {getFunction(SubaWordPaisAd), true},
    {getFunction(SubaWordDasAd), false},
    {getFunction(SubaWordDaisAd), true},
    {getFunction(SubaWordAdr16Ad), false},
    {getFunction(SubaWordAdr32Ad), false},
    {getFunction(SubaWordDpcAd), false},
    {getFunction(SubaWordDpciAd), true},
    {getFunction(SubaWordImm16Ad), false},
    {getFunction(SubxByteDsDd), false},
    {getFunction(SubxBytePaisPaid), true},
    {getFunction(SubByteDdAis), false},
    {getFunction(SubByteDdAips), false},
    {getFunction(SubByteDdPais), true},
    {getFunction(SubByteDdDas), false},
    {getFunction(SubByteDdDais), true},
    {getFunction(SubByteDdAdr16), false},
    {getFunction(SubByteDdAdr32), false},
    {getFunction(SubxWordDsDd), false},
    {getFunction(SubxWordPaisPaid), true},
    {getFunction(SubWordDdAis), false},
    {getFunction(SubWordDdAips), false},
    {getFunction(SubWordDdPais), true},
    {getFunction(SubWordDdDas), false},
    {getFunction(SubWordDdDais), true},
    {getFunction(SubWordDdAdr16), false},
    {getFunction(SubWordDdAdr32), false},
    {getFunction(SubxLongDsDd), false},
    {getFunction(SubxLongPaisPaid), true},
    {getFunction(SubLongDdAis), false},
    {getFunction(SubLongDdAips), false},
    {getFunction(SubLongDdPais), true},
    {getFunction(SubLongDdDas), false},
    {getFunction(SubLongDdDais), true},
    {getFunction(SubLongDdAdr16), false},
    {getFunction(SubLongDdAdr32), false},
    {getFunction(SubaLongDsAd), false},
    {getFunction(SubaLongAsAd), false},
    {getFunction(SubaLongAisAd), false},
    {getFunction(SubaLongAipsAd), false},
    {getFunction(SubaLongPaisAd), true},
    {getFunction(SubaLongDasAd), false},
    {getFunction(SubaLongDaisAd), true},
    {getFunction(SubaLongAdr16Ad), false},
    {getFunction(SubaLongAdr32Ad), false},
    {getFunction(SubaLongDpcAd), false},
    {getFunction(SubaLongDpciAd), true},
    {getFunction(SubaLongImm32Ad), false},
    {getFunction(CmpByteDsDd), false},
    {getFunction(CmpByteAisDd), false},
    {getFunction(CmpByteAipsDd), false},
    {getFunction(CmpBytePaisDd), true},
    {getFunction(CmpByteDasDd), false},
    {getFunction(CmpByteDaisDd), true},
    {getFunction(CmpByteAdr16Dd), false},
    {getFunction(CmpByteAdr32Dd), false},
    {getFunction(CmpByteDpcDd), false},
    {getFunction(CmpByteDpciDd), true},
    {getFunction(CmpByteImm8Dd), false},
    {getFunction(CmpWordDsDd), false},
    {getFunction(CmpWordAsDd), false},
    {getFunction(CmpWordAisDd), false},
    {getFunction(CmpWordAipsDd), false},
    {getFunction(CmpWordPaisDd), true},
    {getFunction(CmpWordDasDd), false},
    {getFunction(CmpWordDaisDd), true},
    {getFunction(CmpWordAdr16Dd), false},
    {getFunction(CmpWordAdr32Dd), false},
    {getFunction(CmpWordDpcDd), false},
    {getFunction(CmpWordDpciDd), true},
    {getFunction(CmpWordImm16Dd), false},
    {getFunction(CmpLongDsDd), false},
    {getFunction(CmpLongAsDd), false},
    {getFunction(CmpLongAisDd), false},
    {getFunction(CmpLongAipsDd), false},
    {getFunction(CmpLongPaisDd), true},
    {getFunction(CmpLongDasDd), false},
    {getFunction(CmpLongDaisDd), true},
    {getFunction(CmpLongAdr16Dd), false},
    {getFunction(CmpLongAdr32Dd), false},
    {getFunction(CmpLongDpcDd), false},
    {getFunction(CmpLongDpciDd), true},
    {getFunction(CmpLongImm32Dd), false},
    {getFunction(CmpaWordDsAd), false},
    {getFunction(CmpaWordAsAd), false},
    {getFunction(CmpaWordAisAd), false},
    {getFunction(CmpaWordAipsAd), false},
    {getFunction(CmpaWordPaisAd), true},
    {getFunction(CmpaWordDasAd), false},
    {getFunction(CmpaWordDaisAd), true},
    {getFunction(CmpaWordAdr16Ad), false},
    {getFunction(CmpaWordAdr32Ad), false},
    {getFunction(CmpaWordDpcAd), false},
    {getFunction(CmpaWordDpciAd), true},
    {getFunction(CmpaWordImm16Ad), false},
    {getFunction(EorByteDdDs), false},
    {getFunction(CmpmByteAipsAipd), false},
    {getFunction(EorByteDdAis), false},
    {getFunction(EorByteDdAips), false},
    {getFunction(EorByteDdPais), true},
    {getFunction(EorByteDdDas), false},
    {getFunction(EorByteDdDais), true},
    {getFunction(EorByteDdAdr16), false},
    {getFunction(EorByteDdAdr32), false},
    {getFunction(EorWordDdDs), false},
    {getFunction(CmpmWordAipsAipd), false},
    {getFunction(EorWordDdAis), false},
    {getFunction(EorWordDdAips), false},
    {getFunction(EorWordDdPais), true},
    {getFunction(EorWordDdDas), false},
    {getFunction(EorWordDdDais), true},
    {getFunction(EorWordDdAdr16), false},
    {getFunction(EorWordDdAdr32), false},
    {getFunction(EorLongDdDs), false},
    {getFunction(CmpmLongAipsAipd), false},
    {getFunction(EorLongDdAis), false},
    {getFunction(EorLongDdAips), false},
    {getFunction(EorLongDdPais), true},
    {getFunction(EorLongDdDas), false},
    {getFunction(EorLongDdDais), true},
    {getFunction(EorLongDdAdr16), false},
    {getFunction(EorLongDdAdr32), false},
    {getFunction(CmpaLongDsAd), false},
    {getFunction(CmpaLongAsAd), false},
    {getFunction(CmpaLongAisAd), false},
    {getFunction(CmpaLongAipsAd), false},
    {getFunction(CmpaLongPaisAd), true},
    {getFunction(CmpaLongDasAd), false},
    {getFunction(CmpaLongDaisAd), true},
    {getFunction(CmpaLongAdr16Ad), false},
    {getFunction(CmpaLongAdr32Ad), false},
    {getFunction(CmpaLongDpcAd), false},
    {getFunction(CmpaLongDpciAd), true},
    {getFunction(CmpaLongImm32Ad), false},
    {getFunction(AndByteDsDd), false},
    {getFunction(AndByteAisDd), false},
    {getFunction(AndByteAipsDd), false},
    {getFunction(AndBytePaisDd), true},
    {getFunction(AndByteDasDd), false},
    {getFunction(AndByteDaisDd), true},
    {getFunction(AndByteAdr16Dd), false},
    {getFunction(AndByteAdr32Dd), false},
    {getFunction(AndByteDpcDd), false},
    {getFunction(AndByteDpciDd), true},
    {getFunction(AndByteImm8Dd), false},
    {getFunction(AndWordDsDd), false},
    {getFunction(AndWordAisDd), false},
    {getFunction(AndWordAipsDd), false},
    {getFunction(AndWordPaisDd), true},
    {getFunction(AndWordDasDd), false},
    {getFunction(AndWordDaisDd), true},
    {getFunction(AndWordAdr16Dd), false},
    {getFunction(AndWordAdr32Dd), false},
    {getFunction(AndWordDpcDd), false},
    {getFunction(AndWordDpciDd), true},
    {getFunction(AndWordImm16Dd), false},
    {getFunction(AndLongDsDd), false},
    {getFunction(AndLongAisDd), false},
    {getFunction(AndLongAipsDd), false},
    {getFunction(AndLongPaisDd), true},
    {getFunction(AndLongDasDd), false},
    {getFunction(AndLongDaisDd), true},
    {getFunction(AndLongAdr16Dd), false},
    {getFunction(AndLongAdr32Dd), false},
    {getFunction(AndLongDpcDd), false},
    {getFunction(AndLongDpciDd), true},
    {getFunction(AndLongImm32Dd), false},
    {getFunction(MuluWordDsDd), false},
    {getFunction(MuluWordAisDd), false},
    {getFunction(MuluWordAipsDd), false},
    {getFunction(MuluWordPaisDd), true},
    {getFunction(MuluWordDasDd), false},
    {getFunction(MuluWordDaisDd), true},
    {getFunction(MuluWordAdr16Dd), false},
    {getFunction(MuluWordAdr32Dd), false},
    {getFunction(MuluWordDpcDd), false},
    {getFunction(MuluWordDpciDd), true},
    {getFunction(MuluWordImm16Dd), false},
    {getFunction(AbcdDsDd), false},
    {getFunction(AbcdPaisPaid), true},
    {getFunction(AndByteDdAis), false},
    {getFunction(AndByteDdAips), false},
    {getFunction(AndByteDdPais), true},
    {getFunction(AndByteDdDas), false},
    {getFunction(AndByteDdDais), true},
    {getFunction(AndByteDdAdr16), false},
    {getFunction(AndByteDdAdr32), false},
    {getFunction(ExgDdDs), false},
    {getFunction(ExgAdAs), false},
    {getFunction(AndWordDdAis), false},
    {getFunction(AndWordDdAips), false},
    {getFunction(AndWordDdPais), true},
    {getFunction(AndWordDdDas), false},
    {getFunction(AndWordDdDais), true},
    {getFunction(AndWordDdAdr16), false},
    {getFunction(AndWordDdAdr32), false},
    {getFunction(ExgDdAs), false},
    {getFunction(AndLongDdAis), false},
    {getFunction(AndLongDdAips), false},
    {getFunction(AndLongDdPais), true},
    {getFunction(AndLongDdDas), false},
    {getFunction(AndLongDdDais), true},
    {getFunction(AndLongDdAdr16), false},
    {getFunction(AndLongDdAdr32), false},
    {getFunction(MulsWordDsDd), false},
    {getFunction(MulsWordAisDd), false},
    {getFunction(MulsWordAipsDd), false},
    {getFunction(MulsWordPaisDd), true},
    {getFunction(MulsWordDasDd), false},
    {getFunction(MulsWordDaisDd), true},
    {getFunction(MulsWordAdr16Dd), false},
    {getFunction(MulsWordAdr32Dd), false},
    {getFunction(MulsWordDpcDd), false},
    {getFunction(MulsWordDpciDd), true},
    {getFunction(MulsWordImm16Dd), false},
    {getFunction(AddByteDsDd), false},
    {getFunction(AddByteAisDd), false},
    {getFunction(AddByteAipsDd), false},
    {getFunction(AddBytePaisDd), true},
    {getFunction(AddByteDasDd), false},
    {getFunction(AddByteDaisDd), true},
    {getFunction(AddByteAdr16Dd), false},
    {getFunction(AddByteAdr32Dd), false},
    {getFunction(AddByteDpcDd), false},
    {getFunction(AddByteDpciDd), true},
    {getFunction(AddByteImm8Dd), false},
    {getFunction(AddWordDsDd), false},
    {getFunction(AddWordAsDd), false},
    {getFunction(AddWordAisDd), false},
    {getFunction(AddWordAipsDd), false},
    {getFunction(AddWordPaisDd), true},
    {getFunction(AddWordDasDd), false},
    {getFunction(AddWordDaisDd), true},
    {getFunction(AddWordAdr16Dd), false},
    {getFunction(AddWordAdr32Dd), false},
    {getFunction(AddWordDpcDd), false},
    {getFunction(AddWordDpciDd), true},
    {getFunction(AddWordImm16Dd), false},
    {getFunction(AddLongDsDd), false},
    {getFunction(AddLongAsDd), false},
    {getFunction(AddLongAisDd), false},
    {getFunction(AddLongAipsDd), false},
    {getFunction(AddLongPaisDd), true},
    {getFunction(AddLongDasDd), false},
    {getFunction(AddLongDaisDd), true},
    {getFunction(AddLongAdr16Dd), false},
    {getFunction(AddLongAdr32Dd), false},
    {getFunction(AddLongDpcDd), false},
    {getFunction(AddLongDpciDd), true},
    {getFunction(AddLongImm32Dd), false},
    {getFunction(AddaWordDsAd), false},
    {getFunction(AddaWordAsAd), false},
    {getFunction(AddaWordAisAd), false},
    {getFunction(AddaWordAipsAd), false},
    {getFunction(AddaWordPaisAd), true},
    {getFunction(AddaWordDasAd), false},
    {getFunction(AddaWordDaisAd), true},
    {getFunction(AddaWordAdr16Ad), false},
    {getFunction(AddaWordAdr32Ad), false},
    {getFunction(AddaWordDpcAd), false},
    {getFunction(AddaWordDpciAd), true},
    {getFunction(AddaWordImm16Ad), false},
    {getFunction(AddxByteDsDd), false},
    {getFunction(AddxBytePaisPaid), true},
    {getFunction(AddByteDdAis), false},
    {getFunction(AddByteDdAips), false},
    {getFunction(AddByteDdPais), true},
    {getFunction(AddByteDdDas), false},
    {getFunction(AddByteDdDais), true},
    {getFunction(AddByteDdAdr16), false},
    {getFunction(AddByteDdAdr32), false},
    {getFunction(AddxWordDsDd), false},
    {getFunction(AddxWordPaisPaid), true},
    {getFunction(AddWordDdAis), false},
    {getFunction(AddWordDdAips), false},
    {getFunction(AddWordDdPais), true},
    {getFunction(AddWordDdDas), false},
    {getFunction(AddWordDdDais), true},
    {getFunction(AddWordDdAdr16), false},
    {getFunction(AddWordDdAdr32), false},
    {getFunction(AddxLongDsDd), false},
    {getFunction(AddxLongPaisPaid), true},
    {getFunction(AddLongDdAis), false},
    {getFunction(AddLongDdAips), false},
    {getFunction(AddLongDdPais), true},
    {getFunction(AddLongDdDas), false},
    {getFunction(AddLongDdDais), true},
    {getFunction(AddLongDdAdr16), false},
    {getFunction(AddLongDdAdr32), false},
    {getFunction(AddaLongDsAd), false},
    {getFunction(AddaLongAsAd), false},
    {getFunction(AddaLongAisAd), false},
    {getFunction(AddaLongAipsAd), false},
    {getFunction(AddaLongPaisAd), true},
    {getFunction(AddaLongDasAd), false},
    {getFunction(AddaLongDaisAd), true},
    {getFunction(AddaLongAdr16Ad), false},
    {getFunction(AddaLongAdr32Ad), false},
    {getFunction(AddaLongDpcAd), false},
    {getFunction(AddaLongDpciAd), true},
    {getFunction(AddaLongImm32Ad), false},
    {getFunction(AsrByteImm3Ds), false},
    {getFunction(LsrByteImm3Ds), false},
    {getFunction(RoxrByteImm3Ds), false},
    {getFunction(RorByteImm3Ds), false},
    {getFunction(AsrByteDdDs), false},
    {getFunction(LsrByteDdDs), false},
    {getFunction(RoxrByteDdDs), false},
    {getFunction(RorByteDdDs), false},
    {getFunction(AsrWordImm3Ds), false},
    {getFunction(LsrWordImm3Ds), false},
    {getFunction(RoxrWordImm3Ds), false},
    {getFunction(RorWordImm3Ds), false},
    {getFunction(AsrWordDdDs), false},
    {getFunction(LsrWordDdDs), false},
    {getFunction(RoxrWordDdDs), false},
    {getFunction(RorWordDdDs), false},
    {getFunction(AsrLongImm3Ds), false},
    {getFunction(LsrLongImm3Ds), false},
    {getFunction(RoxrLongImm3Ds), false},
    {getFunction(RorLongImm3Ds), false},
    {getFunction(AsrLongDdDs), false},
    {getFunction(LsrLongDdDs), false},
    {getFunction(RoxrLongDdDs), false},
    {getFunction(RorLongDdDs), false},
    {getFunction(AsrAis), false},
    {getFunction(AsrAips), false},
    {getFunction(AsrPais), true},
    {getFunction(AsrDas), false},
    {getFunction(AsrDais), true},
    {getFunction(AsrAdr16), false},
    {getFunction(AsrAdr32), false},
    {getFunction(AslByteImm3Ds), false},
    {getFunction(LslByteImm3Ds), false},
    {getFunction(RoxlByteImm3Ds), false},
    {getFunction(RolByteImm3Ds), false},
    {getFunction(AslByteDdDs), false},
    {getFunction(LslByteDdDs), false},
    {getFunction(RoxlByteDdDs), false},
    {getFunction(RolByteDdDs), false},
    {getFunction(AslWordImm3Ds), false},
    {getFunction(LslWordImm3Ds), false},
    {getFunction(RoxlWordImm3Ds), false},
    {getFunction(RolWordImm3Ds), false},
    {getFunction(AslWordDdDs), false},
    {getFunction(LslWordDdDs), false},
    {getFunction(RoxlWordDdDs), false},
    {getFunction(RolWordDdDs), false},
    {getFunction(AslLongImm3Ds), false},
    {getFunction(LslLongImm3Ds), false},
    {getFunction(RoxlLongImm3Ds), false},
    {getFunction(RolLongImm3Ds), false},
    {getFunction(AslLongDdDs), false},
    {getFunction(LslLongDdDs), false},
    {getFunction(RoxlLongDdDs), false},
    {getFunction(RolLongDdDs), false},
    {getFunction(AslAis), false},
    {getFunction(AslAips), false},
    {getFunction(AslPais), true},
    {getFunction(AslDas), false},
    {getFunction(AslDais), true},
    {getFunction(AslAdr16), false},
    {getFunction(AslAdr32), false},
    {getFunction(LsrAis), false},
    {getFunction(LsrAips), false},
    {getFunction(LsrPais), true},
    {getFunction(LsrDas), false},
    {getFunction(LsrDais), true},
    {getFunction(LsrAdr16), false},
    {getFunction(LsrAdr32), false},
    {getFunction(LslAis), false},
    {getFunction(LslAips), false},
    {getFunction(LslPais), true},
    {getFunction(LslDas), false},
    {getFunction(LslDais), true},
    {getFunction(LslAdr16), false},
    {getFunction(LslAdr32), false},
    {getFunction(RoxrAis), false},
    {getFunction(RoxrAips), false},
    {getFunction(RoxrPais), true},
    {getFunction(RoxrDas), false},
    {getFunction(RoxrDais), true},
    {getFunction(RoxrAdr16), false},
    {getFunction(RoxrAdr32), false},
    {getFunction(RoxlAis), false},
    {getFunction(RoxlAips), false},
    {getFunction(RoxlPais), true},
    {getFunction(RoxlDas), false},
    {getFunction(RoxlDais), true},
    {getFunction(RoxlAdr16), false},
    {getFunction(RoxlAdr32), false},
    {getFunction(RorAis), false},
    {getFunction(RorAips), false},
    {getFunction(RorPais), true},
    {getFunction(RorDas), false},
    {getFunction(RorDais), true},
    {getFunction(RorAdr16), false},
    {getFunction(RorAdr32), false},
    {getFunction(RolAis), false},
    {getFunction(RolAips), false},
    {getFunction(RolPais), true},
    {getFunction(RolDas), false},
    {getFunction(RolDais), true},
    {getFunction(RolAdr16), false},
    {getFunction(RolAdr32), false}
};